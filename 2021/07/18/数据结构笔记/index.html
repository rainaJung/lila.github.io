<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="数据结构笔记汇总, Lila">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>数据结构笔记汇总 | Lila</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Lila</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Lila</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/23.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">数据结构笔记汇总</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Data-Structure/">
                                <span class="chip bg-color">Data Structure</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Notes/" class="post-category">
                                Notes
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-07-18
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    28.5k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    119 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>[TOC]</p>
<h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1 绪论"></a>1 绪论</h1><h1 id="2-线性表"><a href="#2-线性表" class="headerlink" title="2 线性表"></a>2 线性表</h1><h2 id="2-1-线性表的逻辑结构"><a href="#2-1-线性表的逻辑结构" class="headerlink" title="2.1 线性表的逻辑结构"></a>2.1 线性表的逻辑结构</h2><ol>
<li>线性结构</li>
</ol>
<p>线性结构的基本特征为：一个数据元素的有序（次序）集</p>
<ol start="2">
<li> 线性表的抽象数据类型</li>
</ol>
<p>线性表是一种最简单的线性结构，线性表的抽象数据类型定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">ADT List<span class="token punctuation">{</span>

数据对象：

D<span class="token operator">=</span><span class="token punctuation">{</span>ai<span class="token operator">|</span>ai∈ElemSet<span class="token punctuation">,</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>n，n<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">}</span>

称n为线性表的表长，称n<span class="token operator">=</span><span class="token number">0</span>时的线性表为空表

数据关系：

R1<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">&lt;</span>ai<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>ai<span class="token operator">&gt;</span><span class="token operator">|</span>ai<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>ai∈D，i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>n<span class="token punctuation">}</span>

<span class="token punctuation">{</span> 设线性表为（a1<span class="token punctuation">,</span>a2<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>ai<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>an<span class="token punctuation">}</span>称i为ai在线性表中的位序<span class="token punctuation">}</span>

基本操作：

结构初始化操作

结构销毁操作

引用型操作

销毁操作

<span class="token punctuation">}</span>ADT；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<ol start="3">
<li><p>线性表的基本操作</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>结构初始化操作

InitList（<span class="token operator">&amp;</span>L）

（<span class="token number">2</span>）结构销毁操作

<span class="token function">DestroyList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>L<span class="token punctuation">)</span>

（<span class="token number">3</span>）引用型操作

ListEmpty（L） （线性表判空）

ListLength（L）  （求线性表的长度）

PriorElem（L，cur_e<span class="token punctuation">,</span><span class="token operator">&amp;</span>pre_e<span class="token punctuation">)</span><span class="token punctuation">(</span>求数据元素的前驱<span class="token punctuation">)</span>

<span class="token function">NextElem</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span>cur_e<span class="token punctuation">,</span><span class="token operator">&amp;</span>next_e<span class="token punctuation">)</span>（求数据元素的后继）

<span class="token function">GetElem</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token operator">&amp;</span>e<span class="token punctuation">)</span>（求线性表某个数据元素，返回线性表中第i个元素的值）

<span class="token function">LocateElem</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span>e<span class="token punctuation">,</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> （定位函数，返回L中第一个与e相等的位序）

<span class="token function">ListTraverse</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>（遍历线性表，初始条件是线性表L存在）

（<span class="token number">4</span>）结构初始化操作

ClearList（<span class="token operator">&amp;</span>L）（线性表置空）

PutElem（<span class="token operator">&amp;</span>L，i，e）（将e的值赋给第i个元素）

ListInsert（<span class="token operator">&amp;</span>L，i，e）（插入数据元素，在第i个元素前插入新的元素e，L的长度增<span class="token number">1</span>）

ListDelete（<span class="token operator">&amp;</span>L，i<span class="token punctuation">,</span><span class="token operator">&amp;</span>e<span class="token punctuation">)</span>（删除L的第i个元素，并用e返回其值，L的长度减<span class="token number">1</span>）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h3 id="2-1-1-例题"><a href="#2-1-1-例题" class="headerlink" title="2.1.1 例题"></a>2.1.1 例题</h3><ol>
<li>选修同一门课的学生是线性结构（√）</li>
<li>农贸市场的人群是线性结构（x）</li>
<li>将线性表置为空表，就是销毁这个线性表（x）</li>
<li>线性表的长度必然大于零（X）</li>
<li>线性表中的每个元素，既有前驱，又有后继（X)</li>
</ol>
<h2 id="2-2-线性表的操作"><a href="#2-2-线性表的操作" class="headerlink" title="2.2 线性表的操作"></a>2.2 线性表的操作</h2><h3 id="2-2-1-合并集合"><a href="#2-2-1-合并集合" class="headerlink" title="2.2.1 合并集合"></a>2.2.1 合并集合</h3><p>假设有两个集合A和B分别用两个线性表LA和LB表示，即线性表中的数据元素即为集合中的成员，现在求一个新的集合，要求</p>
<p>A=A∪B</p>
<p>A={1,2,4,6,7}</p>
<p>B={1,3,9,8}</p>
<ul>
<li>操作步骤</li>
</ul>
<ol>
<li>从线性表LB中依次查看每个数据元素</li>
<li>依值在线性表LA中进行查访</li>
<li>若不存在，则插入之</li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token keyword">union</span><span class="token punctuation">(</span>List <span class="token operator">&amp;</span>la<span class="token punctuation">,</span>List lb<span class="token punctuation">)</span><span class="token punctuation">{</span>
    la_len<span class="token operator">=</span><span class="token function">listlength</span><span class="token punctuation">(</span>la<span class="token punctuation">)</span><span class="token punctuation">;</span>
    lb_len<span class="token operator">=</span><span class="token function">listlength</span><span class="token punctuation">(</span>lb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>lb_len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">GetElem</span><span class="token punctuation">(</span>lb<span class="token punctuation">,</span>i<span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">LocateElem</span><span class="token punctuation">(</span>la<span class="token punctuation">,</span>e<span class="token punctuation">,</span><span class="token function">equal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">ListInsert</span><span class="token punctuation">(</span>la<span class="token punctuation">,</span><span class="token operator">++</span>la_len<span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-2-2-过滤集合中的重复元素"><a href="#2-2-2-过滤集合中的重复元素" class="headerlink" title="2.2.2 过滤集合中的重复元素"></a>2.2.2 过滤集合中的重复元素</h3><p>已知一个非纯集合B，试构造一个纯集合A，使A 中只包含B中所有各不相同的数据元素</p>
<p>初始：A={ }，B={6,2,9,3,6}</p>
<p>结果： A={6,2,9,3}</p>
<p>上述问题可以演绎为：</p>
<p>将存在于集合B中的元素逐个放入空集合A中，但A中不能有重复元素，算法策略与例1相同。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token keyword">union</span><span class="token punctuation">(</span>List<span class="token operator">&amp;</span>la<span class="token punctuation">,</span>list lb<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token function">InitList</span><span class="token punctuation">(</span>la<span class="token punctuation">)</span><span class="token punctuation">;</span>
la_len<span class="token operator">=</span><span class="token function">ListLength</span><span class="token punctuation">(</span>la<span class="token punctuation">)</span><span class="token punctuation">;</span>
lb_len<span class="token operator">=</span><span class="token function">listlength</span><span class="token punctuation">(</span>lb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>lb_len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">GetElem</span><span class="token punctuation">(</span>lb<span class="token punctuation">,</span>i<span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">LocateElem</span><span class="token punctuation">(</span>la<span class="token punctuation">,</span>e<span class="token punctuation">,</span><span class="token function">equal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">ListInsert</span><span class="token punctuation">(</span>la<span class="token punctuation">,</span><span class="token operator">++</span>la_len<span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-2-3合并有序表"><a href="#2-2-3合并有序表" class="headerlink" title="2.2.3合并有序表"></a>2.2.3合并有序表</h3><ul>
<li>有序表</li>
</ul>
<p>若线性表中的数据元素相互之间可以比较，并且数据元素在线性表中依值非递减或者非递增有序排列，则称改线性表为有序表（Ordered List）</p>
<p>A={1,4,5,7,9,12,15,17,20}</p>
<p>B={2,3,6,6,8}</p>
<p>C=A∪B={1,2,3,4,5,6,6,7,8,9,12,151,7,20}</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">MergeList</span><span class="token punctuation">(</span>List la<span class="token punctuation">,</span>List lb<span class="token punctuation">,</span>List<span class="token operator">&amp;</span>lc<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token comment">//本算法将非递减的有序表la和lb归并为lc</span>
<span class="token function">InitList</span><span class="token punctuation">(</span>LC<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//构造空的线性表lc</span>
i<span class="token operator">=</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
la_len<span class="token operator">=</span><span class="token function">listlength</span><span class="token punctuation">(</span>la<span class="token punctuation">)</span><span class="token punctuation">;</span>
lb_le<span class="token operator">=</span><span class="token function">listlength</span><span class="token punctuation">(</span>lb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>la_len<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>j<span class="token operator">&lt;=</span>lb_len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//la和lb均不为空</span>
<span class="token comment">//la和lb均不为空</span>
	<span class="token function">GetElem</span><span class="token punctuation">(</span>la<span class="token punctuation">,</span>i<span class="token punctuation">,</span>ai<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">GetElem</span><span class="token punctuation">(</span>lb<span class="token punctuation">,</span>j<span class="token punctuation">,</span>bj<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>ai<span class="token operator">&lt;=</span>bj<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">ListInsert</span><span class="token punctuation">(</span>lc<span class="token punctuation">,</span><span class="token operator">++</span>k<span class="token punctuation">,</span>ai<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将ai插入到lc中</span>
	<span class="token operator">++</span>i<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	eles<span class="token punctuation">{</span>
	<span class="token function">ListInsert</span><span class="token punctuation">(</span>lc<span class="token punctuation">,</span><span class="token operator">++</span>k<span class="token punctuation">,</span>bj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将bj插入到lc中</span>
	<span class="token operator">++</span>j<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
 <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>la_len<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//当la不为空时</span>
     <span class="token function">GetElem</span><span class="token punctuation">(</span>la<span class="token punctuation">,</span>i<span class="token operator">++</span><span class="token punctuation">,</span>ai<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token function">ListInsert</span><span class="token punctuation">(</span>lc<span class="token punctuation">,</span><span class="token operator">++</span>k<span class="token punctuation">,</span>ai<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token comment">//插入la表中的剩余元素</span>
 <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;=</span>lb_len<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//当lb不为空时</span>
 	<span class="token function">GetElem</span><span class="token punctuation">(</span>lb<span class="token punctuation">,</span><span class="token operator">++</span>j<span class="token punctuation">,</span>bj<span class="token punctuation">)</span><span class="token punctuation">;</span>
 	<span class="token function">ListInsert</span><span class="token punctuation">(</span>lc<span class="token punctuation">,</span><span class="token operator">++</span>k<span class="token punctuation">,</span>bj<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token comment">//插入lb表中的剩余元素</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="2-3-顺序表"><a href="#2-3-顺序表" class="headerlink" title="2.3 顺序表"></a>2.3 顺序表</h2><p>LOC(ai)=LOC(a1)+（i-1）xl</p>
<h3 id="2-3-1线性表的顺序存储结构"><a href="#2-3-1线性表的顺序存储结构" class="headerlink" title="2.3.1线性表的顺序存储结构"></a>2.3.1线性表的顺序存储结构</h3><h4 id="2-3-1-1-顺序表初始化"><a href="#2-3-1-1-顺序表初始化" class="headerlink" title="2.3.1.1 顺序表初始化"></a>2.3.1.1 顺序表初始化</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LIST_INIT_SIZE</span> <span class="token expression"><span class="token number">100</span>  </span><span class="token comment">//线性表存储空间的初始分配量</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LISTINCREMENT</span> <span class="token expression"><span class="token number">10</span> </span><span class="token comment">//线性表存储空间的分配增量</span></span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>
ElemType <span class="token operator">*</span>elem<span class="token punctuation">;</span> <span class="token comment">//存储空间基址</span>
<span class="token keyword">int</span> length<span class="token punctuation">;</span><span class="token comment">//当前长度</span>
<span class="token keyword">int</span> listsize<span class="token punctuation">;</span><span class="token comment">//当前分配的存储容量</span>
<span class="token punctuation">}</span>SqList<span class="token punctuation">;</span> <span class="token comment">//称为 顺序表</span>

<span class="token comment">//顺序表的初始化</span>
Status <span class="token function">InitList_Sq</span><span class="token punctuation">(</span>SqList<span class="token operator">&amp;</span> L<span class="token punctuation">)</span><span class="token punctuation">{</span>
    L<span class="token punctuation">.</span>elem<span class="token operator">=</span><span class="token punctuation">(</span>ElemType<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>LIST_init_SIZE<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ElemType<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">)</span><span class="token function">exit</span><span class="token punctuation">(</span>OVERFLOW<span class="token punctuation">)</span><span class="token punctuation">;</span>
    L<span class="token punctuation">.</span>length<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    L<span class="token punctuation">.</span>listsize<span class="token operator">=</span>LIST_INIT_SIZE<span class="token punctuation">;</span>
    <span class="token keyword">return</span> OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token comment">//Init_Sq</span>

<span class="token comment">//算法时间复杂度O（1）</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="2-3-1-2-顺序表的查找"><a href="#2-3-1-2-顺序表的查找" class="headerlink" title="2.3.1.2 顺序表的查找"></a>2.3.1.2 顺序表的查找</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">LocateElem_Sq</span><span class="token punctuation">(</span>SqList L<span class="token punctuation">,</span>ElemType e<span class="token punctuation">,</span><span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>compare<span class="token punctuation">)</span><span class="token punctuation">(</span>ElemType<span class="token punctuation">,</span>ElemType<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//在顺序表中查询第一个满足判定条件的数据元素</span>
    <span class="token comment">//若存在，则返回它的位序，否则返回0</span>
	i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//i 的初值为第1元素的位序</span>
    p<span class="token operator">=</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>L<span class="token punctuation">.</span>length<span class="token operator">&amp;&amp;</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">*</span>compare<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token operator">++</span><span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">++</span>i<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>L<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token keyword">return</span> i<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token comment">//LocateElem_Sq</span>

<span class="token comment">//算法时间复杂度O（ListLength(L)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="2-3-1-3-例题"><a href="#2-3-1-3-例题" class="headerlink" title="2.3.1.3 例题"></a>2.3.1.3 例题</h4><ol>
<li>编程时如何定义顺序表</li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> <span class="token operator">*</span>elem<span class="token punctuation">;</span><span class="token comment">//存储空间基址</span>
	<span class="token keyword">int</span> length<span class="token punctuation">;</span><span class="token comment">//当前长度</span>
	<span class="token keyword">int</span> listsize<span class="token punctuation">;</span> <span class="token comment">//当前分配的存储容量，以sizeof(ElemType)为单位</span>
<span class="token punctuation">}</span>SqList<span class="token punctuation">;</span> <span class="token comment">//称为顺序表</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="2">
<li>malloc函数如何使用</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">L.elem=(int*)malloc(LIST_INIT_SIZE*sizeof(int));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol start="3">
<li>如何引用顺序表中的变量</li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 第一个元素a0:   L-&gt;elem[0]//第i个元素ai:	L-&gt;elem[i-1]//第n个元素an：	L-&gt;elem[n-1]  或者L-&gt;elem[L-&gt;length-1]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="2-3-2-顺序表的插入"><a href="#2-3-2-顺序表的插入" class="headerlink" title="2.3.2  顺序表的插入"></a>2.3.2  顺序表的插入</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">Status <span class="token function">LisInsert_Sq</span><span class="token punctuation">(</span>SqList<span class="token operator">&amp;</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>ElemType e<span class="token punctuation">)</span><span class="token punctuation">{</span>	<span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">||</span>i<span class="token operator">&gt;</span>L<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">return</span> ERROR<span class="token punctuation">;</span> <span class="token comment">//插入位置不合法    if(L.length&gt;=L.listsize){//分配存储空间        newbase=(ElemType *)realloc(L.elem,(L.listsize+LISTINCREMENT)*sizeof(ElemType));        if(!newbase)exit(OVERFLOW);        L.elem=newbase;        L.listsize+=LISTINCREMENT;    }    q=&amp;(L.elem[i-1]);//q指示插入位置    for(p=&amp;(L.elem[L.length-1]);p&gt;=q;--p)*(p+1)=*p; //插入位置及之后位置向后移位    *q=e;  //插入e    ++L.length; //表长增1    return OK}//时间性能  若在线性表中任何一个位置上进行插入的概率都是相等的，则移动元素的期望值为： n/2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="2-3-2-1例题"><a href="#2-3-2-1例题" class="headerlink" title="2.3.2.1例题"></a>2.3.2.1例题</h4><ol>
<li><p>长度为n的顺序表，一共有 n+1 个插入位置，在第i个元素前插入一个新的元素，要移动的元素个数是 n-i+1</p>
</li>
<li><p>指针q指向顺序表的第i个元素用c语言程序表示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">q<span class="token operator">=</span><span class="token operator">&amp;</span>（L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li><p>在顺序表中，指针p所指向的元素后移一位：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">*</span>p<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ol>
<h3 id="2-3-3-顺序表的删除"><a href="#2-3-3-顺序表的删除" class="headerlink" title="2.3.3 顺序表的删除"></a>2.3.3 顺序表的删除</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ListDelete</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-c" data-language="c"><code class="language-c">Status <span class="token function">ListDelete_Sq</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token punctuation">(</span>i<span class="token operator">&gt;</span>L<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> ERROR<span class="token punctuation">;</span><span class="token comment">//删除位置不合法	p=&amp;(L.elem[i-1]);// p为被删除元素的位置	e=*p; //被删除元素的值赋给e	q=L.elem+L.length-1; //表尾元素的位置	for(++p;p&lt;=q;++p)*(p-1)=*p;//被删除元素之后的元素左移	--L.length;//表长减1	return OK}//删除算法的时间性能// E=qi(n-i) 求和（i-1到n）//若假定在线性表中任何一个位置上进行删除的元素概率相等 则 E=n-1/2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="2-3-3-1-例题"><a href="#2-3-3-1-例题" class="headerlink" title="2.3.3.1 例题"></a>2.3.3.1 例题</h3><ol>
<li>长度为n的顺序表，一共有 n 个删除位置，如果要删除第i个元素，要移动的元素个数是 n-i个</li>
<li>指针q指向顺序表（表长为n）的元素用c语言程序表示</li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">q<span class="token operator">=</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//或q=L.elem+L.length-1;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol start="3">
<li><p>在顺序表中，指针p所指向的元素前移一位如何用c语言程序表示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">*</span>p<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ol>
<h2 id="2-3-单链表"><a href="#2-3-单链表" class="headerlink" title="2.3 单链表"></a>2.3 单链表</h2><p>用一组地址任意的存储单元存放线性表中的数据元素</p>
<p>结点和单链表的类C语言描述</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">Typedef <span class="token keyword">struct</span> <span class="token class-name">LNode</span><span class="token punctuation">{</span>		ElemType data<span class="token punctuation">;</span>  <span class="token comment">//数据域		struct LNode *next  //指针域}LNode,*LinkList;LinkList L;  //L为单链表的头指针</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="2-3-1-生成链表"><a href="#2-3-1-生成链表" class="headerlink" title="2.3.1 生成链表"></a>2.3.1 生成链表</h3><p>生成链表的过程是结点逐个插入的过程</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">CreateList_L</span><span class="token punctuation">(</span>LinkList<span class="token operator">&amp;</span> L<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//逆序输入n个数据元素，建立带头结点的单链表	L=(LinkList)malloc(sizeof(LNode));	L-&gt;next=NULL;  //先建立一个带头结点的单链表	for(i=n;i&gt;0;--i){		p=(LinkList)malloc(sizeof(LNode));		scanf(&amp;p-&gt;data); //输入元素值		p-&gt;next=L-&gt;next;		L-&gt;next=p;   //插入	}}//插入</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="2-3-2-获取元素"><a href="#2-3-2-获取元素" class="headerlink" title="2.3.2 获取元素"></a>2.3.2 获取元素</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">GetElem(L,i,&amp;e)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-c" data-language="c"><code class="language-c">Status <span class="token function">GetElem</span><span class="token punctuation">(</span>LinkList L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>	p<span class="token operator">=</span>L<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>	j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>	<span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">&amp;&amp;</span>j<span class="token operator">&lt;</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>	p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>	<span class="token operator">++</span>j<span class="token punctuation">;</span>	<span class="token punctuation">}</span>		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token operator">||</span>j<span class="token operator">&gt;</span>i<span class="token punctuation">)</span><span class="token keyword">return</span> ERROR<span class="token punctuation">;</span><span class="token comment">//第i个元素不存在	e=p-&gt;data;  //取得第i个元素 	return OK;   }//算法时间复杂度 O（n）  n为单链表的长度</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="2-3-3-单链表存储结构改进"><a href="#2-3-3-单链表存储结构改进" class="headerlink" title="2.3.3 单链表存储结构改进"></a>2.3.3 单链表存储结构改进</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LNode</span><span class="token punctuation">{</span>	ElemType data<span class="token punctuation">;</span>	<span class="token keyword">struct</span> <span class="token class-name">LNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>	<span class="token punctuation">}</span><span class="token operator">*</span>Link<span class="token punctuation">,</span><span class="token operator">*</span>Position<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    Link head<span class="token punctuation">,</span>tail<span class="token punctuation">;</span><span class="token comment">//分别指向头结点和最后一个结点的指针    int len;//指示链表长度    Link current;//指向当前被访问的结点的指针，初始位置指向头结点}LinkList;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="2-3-4-例题"><a href="#2-3-4-例题" class="headerlink" title="2.3.4 例题"></a>2.3.4 例题</h3><ol>
<li>L是单链表的头指针，L指向头结点，单链表的第一个元素如何指向</li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">L<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol start="2">
<li>指针p指向单链表中的第i个元素ai，ai+2如何指向？</li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">p<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol start="3">
<li>欲在单链表的尾部增加一个新结点，必须遍历整个链表？</li>
</ol>
<p>要看单链表的结构而定</p>
<h3 id="2-3-5-单链表的插入"><a href="#2-3-5-单链表的插入" class="headerlink" title="2.3.5 单链表的插入"></a>2.3.5 单链表的插入</h3><ol>
<li>找到线性表中第i-1个结点</li>
<li>修改其指向后继的指针</li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">Status <span class="token function">ListInsert_L</span><span class="token punctuation">(</span>LinkList L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>ElemType e<span class="token punctuation">)</span><span class="token punctuation">{</span>	<span class="token comment">//本算法在链表中第i个结点之前插入新的元素e	p=L;	j=0;	while(p&amp;&amp;j&lt;i-1){	p=p-&gt;next;  	++j; //寻找第i-1个结点	}	if(!p||j&gt;i-1)return ERROR;   //i大于表长或者小于1	S=(LinkList)malloc(sizeof(LNode));   //生成新结点	s-&gt;data=e;	s-&gt;next=p-&gt;next;	p-&gt;next=s;  //插入}//算法时间复杂度 O(n)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="2-3-5-1-例题"><a href="#2-3-5-1-例题" class="headerlink" title="2.3.5.1 例题"></a>2.3.5.1 例题</h4><ol>
<li>指针p指向单链表的第i个元素ai，欲在ai后面连续插入两个元素m和n，写出主要算法</li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">s<span class="token operator">=</span><span class="token punctuation">(</span>LinkList<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token operator">-&gt;</span>data<span class="token operator">=</span>m<span class="token punctuation">;</span>s<span class="token operator">-&gt;</span>next<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>p<span class="token operator">-&gt;</span>next<span class="token operator">=</span>s<span class="token punctuation">;</span>p<span class="token operator">=</span>s<span class="token punctuation">;</span>s<span class="token operator">=</span><span class="token punctuation">(</span>LinkList<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token operator">-&gt;</span>data<span class="token operator">=</span>n<span class="token punctuation">;</span>s<span class="token operator">-&gt;</span>next<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>p<span class="token operator">-&gt;</span>next<span class="token operator">=</span>s<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="2-3-6-单链表的删除"><a href="#2-3-6-单链表的删除" class="headerlink" title="2.3.6 单链表的删除"></a>2.3.6 单链表的删除</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ListDelete</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将链表第i个元素删除</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-c" data-language="c"><code class="language-c">Status <span class="token function">ListDelte</span><span class="token punctuation">(</span>LinkList L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>Elmetype <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>    p<span class="token operator">=</span>L<span class="token punctuation">;</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>next<span class="token operator">&amp;&amp;</span>j<span class="token operator">&lt;</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        p<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        <span class="token operator">++</span>j<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token operator">||</span>j<span class="token operator">&gt;</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>    q<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    p<span class="token operator">-&gt;</span>next<span class="token operator">=</span>q<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    e<span class="token operator">=</span>q<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//清空链表void ClearList(&amp;L){    while(L-&gt;next){        p=L-&gt;next;        L-&gt;next=p-&gt;next;        free(p);    }}//算法时间复杂度 O(n)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="2-3-6-1-例题"><a href="#2-3-6-1-例题" class="headerlink" title="2.3.6.1 例题"></a>2.3.6.1 例题</h4><ol>
<li>连续删除两个元素</li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">q<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>p<span class="token operator">-&gt;</span>next<span class="token operator">=</span>q<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>p<span class="token operator">-&gt;</span>next<span class="token operator">=</span>q<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="2-4-单循环链表"><a href="#2-4-单循环链表" class="headerlink" title="2.4 单循环链表"></a>2.4 单循环链表</h2><p>最后一个结点的指针域的指针又指回头结点的链表</p>
<p>判别链表最后一个结点的条件是： 后继结点是否指向头结点</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">Typedef <span class="token keyword">struct</span> <span class="token class-name">LNode</span><span class="token punctuation">{</span>		ElemType data<span class="token punctuation">;</span>  <span class="token comment">//数据域		struct LNode *next  //指针域}LNode,*LinkList;void CreatList(LinkList L,int n){    int i;    Lnode *p,*s;    p=L;     for(i=1;i&lt;n;i++){        s=(LinkList)malloc(sizeof(LNode));        s-&gt;data=i+1;        s-&gt;next=p-&gt;next;        p-&gt;next=s;        p=s;    }}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="2-7-双向链表"><a href="#2-7-双向链表" class="headerlink" title="2.7 双向链表"></a>2.7 双向链表</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">DuLNode</span><span class="token punctuation">{</span>	ElemType data<span class="token punctuation">;</span> <span class="token comment">//数据域    struct DuLNode *prior;  //指向前驱的指针域    struct DuLNode *next; //指向后继的指针域}DuLNode, *DuLinkList;void CreatListHead(DuLinkList L,int n){    int i;    LNode *p,*s;        p=L;    for(int i=0;i&lt;n;i++){        printf("请输入第%d个元素：",i+1);        s=(DuLinkList)malloc(sizeof(LNode));        scanf("%d",&amp;s-&gt;data);        s-&gt;next=p-&gt;next;        s-&gt;prior=p;        p-&gt;next=s;        if(s-&gt;next)s-&gt;next-&gt;prior=s;    }}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="2-7-1-双向链表的插入"><a href="#2-7-1-双向链表的插入" class="headerlink" title="2.7.1 双向链表的插入"></a>2.7.1 双向链表的插入</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">s<span class="token operator">-&gt;</span>next<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>p<span class="token operator">-</span>next<span class="token operator">=</span>s<span class="token punctuation">;</span>s<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>prior<span class="token operator">=</span>s<span class="token punctuation">;</span>s<span class="token operator">-&gt;</span>prior<span class="token operator">=</span>p<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="2-7-2例题"><a href="#2-7-2例题" class="headerlink" title="2.7.2例题"></a>2.7.2例题</h3><p>在双向链表中的元素ai前插入一个新元素e，指针p指向结点ai，写出相应的算法语句</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">s<span class="token operator">=</span><span class="token punctuation">(</span>DuLinkList<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>DulNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token operator">-&gt;</span>data<span class="token operator">=</span>e<span class="token punctuation">;</span>s<span class="token operator">-&gt;</span>prior<span class="token operator">=</span>p<span class="token operator">-&gt;</span>prior<span class="token punctuation">;</span>p<span class="token operator">-&gt;</span>prior<span class="token operator">-&gt;</span>next<span class="token operator">=</span>s<span class="token punctuation">;</span>s<span class="token operator">-&gt;</span>next<span class="token operator">=</span>p<span class="token punctuation">;</span>p<span class="token operator">-&gt;</span>prior<span class="token operator">=</span>s<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="2-7-3双向链表的删除"><a href="#2-7-3双向链表的删除" class="headerlink" title="2.7.3双向链表的删除"></a>2.7.3双向链表的删除</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">q<span class="token operator">=</span>p<span class="token operator">-&gt;</span>nextp<span class="token operator">-&gt;</span>next<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>q<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>prior<span class="token operator">=</span>p<span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="2-7-3-1-例题"><a href="#2-7-3-1-例题" class="headerlink" title="2.7.3.1 例题"></a>2.7.3.1 例题</h4><ol>
<li>删除双向链表中的元素ai，指针p指向结点ai，写出相应的算法语句</li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">e<span class="token operator">=</span>p<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>p<span class="token operator">-&gt;</span>prior<span class="token operator">-&gt;</span>next<span class="token operator">=</span>p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>p<span class="token operator">-&gt;</span>next<span class="token operator">-&gt;</span>prior<span class="token operator">=</span>p<span class="token operator">-&gt;</span>prior<span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h3 id="2-7-2-双向链表的删除"><a href="#2-7-2-双向链表的删除" class="headerlink" title="2.7.2 双向链表的删除"></a>2.7.2 双向链表的删除</h3><h3 id="2-4-1例题"><a href="#2-4-1例题" class="headerlink" title="2.4.1例题"></a>2.4.1例题</h3><ul>
<li>单循环列表的转置</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">Status <span class="token function">Contrary</span><span class="token punctuation">(</span>LinkList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">{</span>t<span class="token operator">=</span>L<span class="token punctuation">;</span>   <span class="token comment">//t指向单循环链表的头结点p=t-&gt;next;  //p指向单循环链表的第一个结点q=p-&gt;next;  //q指向单循环链表的第二个结点while(p!=L){p-&gt;next=t;  //让p结点next域指针指向其前驱t=p; //顺链向后移动指针tp=q;   //顺链向后移动指针pq=p-&gt;next;  //顺链向后移动指针q}L-&gt;next=t;   //让L的next域指针指向新链表的第一个结点return OK;}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>约瑟夫环</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h1 id="3-栈"><a href="#3-栈" class="headerlink" title="3. 栈"></a>3. 栈</h1><h2 id="3-1-栈的逻辑结构"><a href="#3-1-栈的逻辑结构" class="headerlink" title="3.1 栈的逻辑结构"></a>3.1 栈的逻辑结构</h2><p>栈是限定插入和删除只能在“固定端”进行的线性表。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">ADT Stack<span class="token punctuation">{</span>    数据对象：        D<span class="token operator">=</span><span class="token punctuation">{</span>ai<span class="token operator">|</span>ai∈ElemSet，i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>n<span class="token punctuation">,</span>n<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">}</span>    数据关系：        R1<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">&lt;</span>ai<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>ai<span class="token operator">&gt;</span><span class="token operator">|</span>ai<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>ai∈D<span class="token punctuation">,</span>i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>n<span class="token punctuation">}</span>    基本操作：        <span class="token function">InitStack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span>        <span class="token function">DestroyStack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span>        <span class="token function">StackLength</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span>        <span class="token function">StackEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span>        <span class="token function">GetTop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span><span class="token operator">&amp;</span>e<span class="token punctuation">)</span>        <span class="token function">ClearStack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span>        <span class="token function">Push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span>e<span class="token punctuation">)</span>        <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span>e<span class="token punctuation">)</span>        <span class="token function">StackTravers</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>ADT Stack<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="3-1-1-例题"><a href="#3-1-1-例题" class="headerlink" title="3.1.1 例题"></a>3.1.1 例题</h3><ol>
<li>栈中的元素是先进先出，后进后出（x)</li>
<li>栈有1个插入位置和2个删除位置（x)</li>
<li>栈底不进行元素的删除操作（X)</li>
</ol>
<h2 id="3-2-栈的顺序存储表示"><a href="#3-2-栈的顺序存储表示" class="headerlink" title="3.2 栈的顺序存储表示"></a>3.2 栈的顺序存储表示</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">STACK_INIT_SIZE</span> <span class="token expression"><span class="token number">100</span><span class="token punctuation">;</span>#define STACKINCREMENT <span class="token number">10</span><span class="token punctuation">;</span></span><span class="token comment">//栈的顺序存储表示typedef struct{    SElemType *base;    SElemType *top;    int stacksize;}SqStack;//顺序栈的初始化Status InitStack(SqStack &amp;S){    //构造一个空栈S    S.base=(ElemType*)malloc(STACK_INIT_SIZE*sizeof(ElemType));    if(!S.base)exit(OVERFLOW);//存储分配失败    S.top=S.base;//栈空的标志    S.stacksize=STACK_INIT_SIZE;    return OK;}//顺序栈的插入Status Push(SqStack &amp;S,SElemType e){    if(S.top-S.base&gt;=S.stacksize){        S.base=(ElemType*)realloc(S.base,S.stacksize+STACKINCREMENT)*sizeof(ElemType);        if(!S.base)exit(OVERFLOW);        S.top=S.base+S.stacksize;        S.stacksize+=STACKINCREMENT;    }    *S.top++=e;    return OK;}//顺序栈的删除Status Pop(SqStack &amp;S,SElemType e){	//若栈不空，则删除S的栈顶元素,用e返回其值，并返回OK    //否则返回ERROR    if(S.top==S.base)return ERROR;    e=*--S.top;    return OK;}</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="3-2-1例题"><a href="#3-2-1例题" class="headerlink" title="3.2.1例题"></a>3.2.1例题</h3><ol>
<li><p>顺序栈中的元素进制的顺序是 1、2、3、4、5、6，那么元素出栈的顺序不可能是</p>
<p>2 3 5 1 4 6</p>
</li>
</ol>
<h2 id="3-3-栈的应用"><a href="#3-3-栈的应用" class="headerlink" title="3.3 栈的应用"></a>3.3 栈的应用</h2><h3 id="3-3-1-编辑命令行"><a href="#3-3-1-编辑命令行" class="headerlink" title="3.3.1 编辑命令行"></a>3.3.1 编辑命令行</h3><p>“每接受一个字符即存入存储器” 并不恰当！</p>
<p>在用户输入一行的过程中，运行用户输入出 差错，并在发现有误时可以即时更正。</p>
<p>合理的作法是：设立一个输入缓冲区，用以接受用户输入的一行字符，然后逐行存入用户数据区，并假设“#”为退格符，“@”为退行符。</p>
<p>假设从终端接受了这样两行字符：</p>
<p>whli##ilr#e(s#*s)</p>
<p>outcha@putchar(*s=#++);</p>
<p>实际有效的是这两行：</p>
<p>while(*s)</p>
<p>putchar(*s++);</p>
<p>编辑命令行的算法</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">LineEdit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">InitStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>    ch<span class="token operator">=</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//从终端接受下一个字符    while(ch!=EOF){  //以EOF为全文结束符        while(ch!=EOF&amp;&amp;ch!='\n'){  //读入每一行            switch(ch){                    case'#':Pop(S,c);break;                    case'@':ClearStack(S);break;                default:Push(S,ch);break;            }            ch=getchar();//从终端接受下一字符        }        //将从栈底到栈顶的字符传送至调用过程的数据区        ClearStack(S);  //重置S为空栈        if(ch!=EOF)ch=getchar();    }    DestroyStack(S);}//LineEdit</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="3-3-1-1-例题"><a href="#3-3-1-1-例题" class="headerlink" title="3.3.1.1  例题"></a>3.3.1.1  例题</h3><p>假设从终端接受了这样两行字符：</p>
<p>*s.#.top####-+#&gt;s#top:=##=x;</p>
<p>top+@o#s-&gt;&lt;#top++;</p>
<p>实际的有效输入：</p>
<p>*s-&gt;top=x;</p>
<p>s-&gt;top++;</p>
<h3 id="3-3-2-数值转换"><a href="#3-3-2-数值转换" class="headerlink" title="3.3.2  数值转换"></a>3.3.2  数值转换</h3><p>算法原理：N=(N div d)x d+N mod d</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//数值转换算法void conversion(){    InitStack(S);    scanf("%d",N);    while(N){        Push(S,N%8);        N=N/8;    }    while(!StackEmpty(S)){        Pop(S,e);        printf("%d",e);    }}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="3-3-3-括号匹配"><a href="#3-3-3-括号匹配" class="headerlink" title="3.3.3 括号匹配"></a>3.3.3 括号匹配</h3><p>原理：</p>
<ol>
<li><p>凡是出现左括弧，则进栈</p>
</li>
<li><p>凡是出现右括弧：</p>
<p>若栈空： 则多余</p>
<p>若栈不空，则与栈顶元素比较，若相匹配，则左括弧出栈，否则不匹配</p>
</li>
<li><p>表达式检验结束时，若栈空，则表明表达式中匹配正确，否则表明“左括弧”有余。</p>
</li>
</ol>
<h4 id="3-3-3-1-例题"><a href="#3-3-3-1-例题" class="headerlink" title="3.3.3.1 例题"></a>3.3.3.1 例题</h4><p>&lt; ( { [ ] } ( [ ( ) ] ) ) &gt;     √<br>{ ( ( ) [ &lt; &gt;]){ } { }          X<br>( ( ) } [ &lt; &gt;]){ } { }          X</p>
<h3 id="3-3-4-迷宫求解"><a href="#3-3-4-迷宫求解" class="headerlink" title="3.3.4  迷宫求解"></a>3.3.4  迷宫求解</h3><p>常用穷举求解的方法</p>
<p>若当前位置“可通”，则纳入路径，继续前进;<br>若当前位置“不可通”，则后退，换方向继续探索;<br>若四周“均无通路”，则将当前位置从路径中删除出去。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">求迷宫中一条从入口到出口的路径的算法：设定当前位置的初值为入口位置； <span class="token keyword">do</span>｛   若当前位置可通，   则｛将当前位置插入栈顶；            若该位置是出口位置，则算法结束；                       否则切换当前位置的东邻方块为                   新的当前位置；   ｝   否则 <span class="token punctuation">{</span>  ……   ｝｝<span class="token keyword">while</span> <span class="token punctuation">(</span>栈不空）；若栈空，则表明迷宫没有通路。     <span class="token comment">// ……        若栈不空且栈顶位置尚有其他方向未被探索，          则设定新的当前位置为: 沿顺时针方向旋转找到的栈顶位置的下一相邻块；      若栈不空但栈顶位置的四周均不可通，      则｛删去栈顶位置；      // 从路径中删去该通道块                                 若栈不空，则重新测试新的栈顶位置，                     直至找到一个可通的相邻块或出栈至栈空；           ｝</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="3-3-5-表达式求值"><a href="#3-3-5-表达式求值" class="headerlink" title="3.3.5 表达式求值"></a>3.3.5 表达式求值</h3><ul>
<li>运算符的优先级等级比较</li>
</ul>
<table>
<thead>
<tr>
<th>c1\c2</th>
<th>+</th>
<th>-</th>
<th>*</th>
<th>/</th>
<th>(</th>
<th>)</th>
<th>#</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>&gt;</td>
<td>&gt;</td>
<td>&lt;</td>
<td>&lt;</td>
<td>&lt;</td>
<td>&gt;</td>
<td>&gt;</td>
</tr>
<tr>
<td>-</td>
<td>&gt;</td>
<td>&gt;</td>
<td>&lt;</td>
<td>&lt;</td>
<td>&lt;</td>
<td>&gt;</td>
<td>&gt;</td>
</tr>
<tr>
<td>*</td>
<td>&gt;</td>
<td>&gt;</td>
<td>&gt;</td>
<td>&gt;</td>
<td>&lt;</td>
<td>&gt;</td>
<td>&gt;</td>
</tr>
<tr>
<td>/</td>
<td>&gt;</td>
<td>&gt;</td>
<td>&gt;</td>
<td>&gt;</td>
<td>&lt;</td>
<td>&gt;</td>
<td>&gt;</td>
</tr>
<tr>
<td>(</td>
<td>&lt;</td>
<td>&lt;</td>
<td>&lt;</td>
<td>&lt;</td>
<td>&lt;</td>
<td>=</td>
<td></td>
</tr>
<tr>
<td>)</td>
<td>&gt;</td>
<td>&gt;</td>
<td>&gt;</td>
<td>&gt;</td>
<td></td>
<td>&gt;</td>
<td>&gt;</td>
</tr>
<tr>
<td>#</td>
<td>&lt;</td>
<td>&lt;</td>
<td>&lt;</td>
<td>&lt;</td>
<td>&lt;</td>
<td></td>
<td>&gt;</td>
</tr>
</tbody></table>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">OperandType <span class="token function">EvaluateExpression</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>	<span class="token function">InitStack</span><span class="token punctuation">(</span>OPTR，<span class="token string">"#"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//OPTR是运算符栈	InitStack(OPND);c=getchar();//OPND是运算符栈	while(c!='#'||GetTop(OPTR)!='#'){	if(!ln(c,OP)){	Push(OPND,c);	c=getchar();	else{		}//while	return GetTop(OPND)	}	}	Push(OPTR)}//switch(Precede(GetTop(OPTR),c)){        case'&lt;':Push(OPTR,c);c=getchar();break;        case'=':Push(OPTR,x);c=getchar();break;        case'&gt;':Pop(OPTR,theta);Pop(OPND,b);Pop(OPND,a);//退栈        Push(OPND,Operate(a,theta,b));break;//将运算符结果入栈}//switch</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="3-3-5-1-前缀表达式"><a href="#3-3-5-1-前缀表达式" class="headerlink" title="3.3.5.1 前缀表达式"></a>3.3.5.1 前缀表达式</h4><h4 id="3-3-5-2-中缀表达式"><a href="#3-3-5-2-中缀表达式" class="headerlink" title="3.3.5.2 中缀表达式"></a>3.3.5.2 中缀表达式</h4><h4 id="3-3-5-3-后缀表达式"><a href="#3-3-5-3-后缀表达式" class="headerlink" title="3.3.5.3 后缀表达式"></a>3.3.5.3 后缀表达式</h4><h2 id="2-3-用栈实现递归"><a href="#2-3-用栈实现递归" class="headerlink" title="2.3 用栈实现递归"></a>2.3 用栈实现递归</h2><ul>
<li><p>当在一个函数的运行期间调用另一个函数时，在运行该被调用函数之前，需先完成三项任务： </p>
<p>​    将所有的实在参数、返回地址等信息传递给被调用函数保存；</p>
<p>​    为被调用函数的局部变量分配存储区； </p>
<p>​    将控制转移到被调用函数的入口。</p>
</li>
<li><p>从被调用函数返回调用函数之前，应该完成下列三项任务：</p>
<p>​    保存被调函数的计算结果；</p>
<pre><code> 释放被调函数的数据区；
 依照被调函数保存的返回地址将控制转移到调用函数。
</code></pre>
</li>
</ul>
<p><strong>后调用先返回 ！</strong></p>
<p>汉诺塔问题：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">hanoi</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">char</span> x<span class="token punctuation">,</span> <span class="token keyword">char</span> y<span class="token punctuation">,</span> <span class="token keyword">char</span> z<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 将塔座x上按直径由小到大且至上而下编号为1至n// 的n个圆盘按规则搬到塔座z上，y可用作辅助塔座。   if (n==1)   move(x, 1, z);   // 将编号为１的圆盘从x移到z  else {    hanoi(n-1, x, z, y);  // 将x上编号为１至n-1的圆盘移到y, z作辅助塔    move(x, n, z);         // 将编号为n的圆盘从x移到z    hanoi(n-1, y, x, z);  // 将y上编号为１至n-1的圆盘移到z, x作辅助塔  } }void hanoi (int n, char x, char y, char z) {  if (n==1)   move(x, 1, z);     else {    hanoi(n-1, x, z, y);     move(x, n, z);         hanoi(n-1, y, x, z);   }}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="3-8-八皇后问题"><a href="#3-8-八皇后问题" class="headerlink" title="3.8 八皇后问题"></a>3.8 八皇后问题</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span><span class="token directive-hash">#</span><span class="token directive keyword">define</span>  <span class="token macro-name">n</span>  <span class="token expression"><span class="token number">8</span>   </span><span class="token comment">// n为皇后个数，m为摆法计数int m=0,a[n];  // a[i]存放第i个皇后放置的行号int ok(int i, int j)  //检查(i,j)上能否放棋子{  j1=j; i1=i;  ok1=1;  //检查第i行上能否放棋子  while( (j1&gt;1)&amp;&amp;ok1)       {j1--;         ok1=a[j1]!=i ;}   j1=j; i1=i;    //检查对角线上能否放棋子  while( (j1&gt;1)&amp;&amp;(i1&gt;1)&amp;&amp;ok1)        {j1--; i1--; ok1=a[j1]!=i1 ;}    j1=j; i1=i;     //检查另一对角线上能否放棋子   while( (j1&gt;1)&amp;&amp;(i1&lt;n)&amp;&amp;ok1)          {j1--; i1++; ok1=a[j1]!=i1 ;}   return  ok1}Void  queen(int j) //从第j列开始逐个试探{  if (j&gt;n)       { m++;  printf("m=%d   ",m);         for (i=1;i&lt;=n;i++)  printf("    %d",a[i]);         printf(“\n”);       }       else  for( i=1; i&lt;=n;i++)             if(ok(i,j))    //检查(i,j)上能否放棋子                { a[j]=i;  //在(i,j)上放一个棋子                   queen(j+1) ;                 } }main()  {queen(1);}</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="3-9-四色问题"><a href="#3-9-四色问题" class="headerlink" title="3.9 四色问题"></a>3.9 四色问题</h2><p>​    “四染色”定理是计算机科学中著名的定理之一。使地图中相邻的国家或行政区域不重色，最少可用四种颜色对地图着色。利用栈采用<strong>回溯法</strong>对地图着色。<br>​    思想：对每个行政区编号：1-7；对颜色编号；a、b、c、d。从第一号行政区开始逐一染色，每一个区域逐次用四种颜色进行试探，若所取颜色与周围不重，则用栈记下来该区域的色数，否则依次用下一色数进行试探。若出现a-d均与周围发生重色，则需退栈回溯，修改当前栈顶的色数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span>  <span class="token function">mapcolor</span><span class="token punctuation">(</span><span class="token keyword">int</span> R<span class="token punctuation">[</span> <span class="token punctuation">]</span><span class="token punctuation">[</span> <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> s<span class="token punctuation">[</span> <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 1号区域染1色    a=2;  J=1;    // a为区域号，J为染色号    while ( a&lt;=n)    { while(( J&lt;=4)&amp;&amp;(a&lt;=n))           { k=1;     // k表示已经着色的区域号           while(( k&lt;a)&amp;&amp;(s[k]R[a-1][k-1]!=J))    k=k+1;  // 若不相邻，或若相邻且不重色，对下一个相邻已染色区域判断                            if (k&lt;a)   J=J+1； //相邻且重色           else { s[a]=J;  a=a+1;  J=1; } //相邻且不重色          }       if (J&gt;4) { a=a-1; J=s[a]+1  } //回到上一个区域，选择下一号颜色试探    } }</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h1 id="4-队列"><a href="#4-队列" class="headerlink" title="4. 队列"></a>4. 队列</h1><p>队列是限定插入在表尾和删除在表头进行的线性表。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">ADT Queue <span class="token punctuation">{</span>    数据对象：      D＝<span class="token punctuation">{</span>ai <span class="token operator">|</span> ai∈ElemSet<span class="token punctuation">,</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>n<span class="token punctuation">,</span> n≥<span class="token number">0</span><span class="token punctuation">}</span>    数据关系：      R1＝<span class="token punctuation">{</span> <span class="token operator">&lt;</span>a i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>ai <span class="token operator">&gt;</span> <span class="token operator">|</span> ai<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> ai ∈D<span class="token punctuation">,</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>n<span class="token punctuation">}</span>  <span class="token comment">//约定其中a1 端为队列头， an 端为队列尾    基本操作：      InitQueue(&amp;Q)                  DestroyQueue(&amp;Q)      QueueEmpty(Q)                QueueLength(Q)      GetHead(Q, &amp;e)                ClearQueue(&amp;Q)      EnQueue(&amp;Q, e)               DeQueue(&amp;Q, &amp;e)      QueueTravers(Q, visit())} ADT Queue</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">InitQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Q<span class="token punctuation">)</span><span class="token comment">//操作结果：构造一个空队列Q。    DestroyQueue(&amp;Q)//初始条件：队列Q已存在。操作结果：队列Q被销毁，不再存在。ClearQueue(&amp;Q)//初始条件：队列Q已存在。操作结果：将Q清为空队列。</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="4-1-队列的链式实现"><a href="#4-1-队列的链式实现" class="headerlink" title="4.1 队列的链式实现"></a>4.1 队列的链式实现</h2><p>介绍队列的链表实现方式</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">QNode</span> <span class="token punctuation">{</span> <span class="token comment">// 结点类型   QElemType      data;   struct QNode  *next;} QNode, *QueuePtr;typedef struct { // 链队列类型    QueuePtr  front;  // 队头指针    QueuePtr  rear;   // 队尾指针} LinkQueue;//链队列的初始化Status InitQueue(LinkQueue &amp;Q){    //构造一个空队列Q    Q.front=Q.rear=(QueuePtr)malloc(sizeof(QNode));    if(!Q.front)exit(OVERFLOW);//存储分配失败    Q.front-&gt;next=NULL;    return OK;}//链队列的删除Status DeQueue(LinkQueue &amp;Q, QElemType &amp;e){    //若队列不为空，则删除Q的队头元素    //用e返回其值，并返回OK，否则返回ERROR    if(Q.front==Q.rear)return ERROR;    p=Q.front-&gt;next;    e=p-&gt;data;    Q.front-&gt;next=p-&gt;next;    if(Q.rear==p)Q.rear=Q.front;    free(p); return OK;}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="4-2-队列的顺序实现"><a href="#4-2-队列的顺序实现" class="headerlink" title="4.2 队列的顺序实现"></a>4.2 队列的顺序实现</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXQSIZE</span>  <span class="token expression"><span class="token number">100</span>  </span><span class="token comment">//最大队列长度  typedef struct {    QElemType  *base;  // 动态分配存储空间    int  front;     // 头指针，若队列不空，指向队列头元素    int  rear;      // 尾指针，若队列不空，指向队列尾元素的下一个位置  } SqQueue;//循环队列的插入Status EnQueue (SqQueue &amp;Q, ElemType e) {   // 插入元素e为Q的新的队尾元素    if ((Q.rear+1) % MAXQSIZE == Q.front)         return ERROR; //队列满    Q.base[Q.rear] = e;    Q.rear = (Q.rear+1) % MAXQSIZE;    return OK;}//循环队列的删除Status DeQueue (SqQueue &amp;Q, ElemType &amp;e) {  // 若队列不空，则删除Q的队头元素，   // 用e返回其值，并返回OK;  否则返回ERROR    if (Q.front == Q.rear)  return ERROR;    e = Q.base[Q.front];    Q.front = (Q.front+1) % MAXQSIZE;    return OK;}//循环队列的长度</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="4-2-1-例题"><a href="#4-2-1-例题" class="headerlink" title="4.2.1 例题"></a>4.2.1 例题</h3><p>1.循环队列存储在数组A[0..9]中，其头、尾指针分别是front=3和rear=1，则队列中的元素个数为__8___。</p>
<ol start="2">
<li>设数组A[m]作为循环队列sq的存储空间，front为队头指针，rear为队尾指针，则执行出队操作时修改指针的语句是（A）。<br>sq.front=( sq.front+1)%m<br>sq.front=( sq.front+1)%(m+1 )<br>sq.rear=( sq.rear+1)%m<br>sq.rear=( sq.rear+1)%(m+1)</li>
</ol>
<h3 id="4-2-2-斐波那契序列"><a href="#4-2-2-斐波那契序列" class="headerlink" title="4.2.2 斐波那契序列"></a>4.2.2 斐波那契序列</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">fb</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>k<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span> cq<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token comment">//为前k-1个元素赋初值0，并放入队列cq   cq.elem[k-1]=f[k-1]=1;    //为第k个元素赋值，并放入队列cq  cq.rear=k-1;   n=k;  while(cq.elem[cq. rear]&lt;max)    //利用循环队列依次求f[n]       {f[n]=0;         for(j=0;j&lt;k;j++)  f[n]=f[n]+cq.elem[j];         cq.rear=(cq.rear +1) % k;         cq.elem[cq.rear]=f[n];         n++;       }                       //利用循环队列依次求f[n]   if(cq.elem[cq.rear]&gt;max)  n=n-2; else n=n-1;}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h1 id="5-串"><a href="#5-串" class="headerlink" title="5 串"></a>5 串</h1><h2 id="5-1-串的逻辑结构"><a href="#5-1-串的逻辑结构" class="headerlink" title="5.1 串的逻辑结构"></a>5.1 串的逻辑结构</h2><ul>
<li><p>串时有限长的字符序列，由一对单括号相括，如’a string’</p>
</li>
<li><p>串的逻辑结构与线性表相似，区别仅在于串的数据对象约束为字符集</p>
</li>
<li><p>串的基本操作和线性表有很大差别：</p>
<p>在线性表的基本操作中，大多以“单个元素”作为操作对象；</p>
<p>在串的基本操作中，通常以“串的整体”作为操作对象。</p>
</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">ADT String<span class="token punctuation">{</span>数据对象：D<span class="token operator">=</span><span class="token punctuation">{</span>ai<span class="token operator">|</span>ai∈CharacterSet<span class="token punctuation">,</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>n<span class="token punctuation">,</span> n<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">}</span>数据关系：R1<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">&lt;</span>ai<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>ai<span class="token operator">&gt;</span><span class="token operator">|</span>ai<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>ai∈D<span class="token punctuation">,</span>i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>n<span class="token punctuation">}</span>基本操作：<span class="token function">StrAssign</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>T<span class="token punctuation">,</span>chars<span class="token punctuation">)</span><span class="token function">DestroyString</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token function">StrCopy</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>T<span class="token punctuation">,</span> S<span class="token punctuation">)</span>                 <span class="token function">StrLength</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token function">StrCompare</span> <span class="token punctuation">(</span>S<span class="token punctuation">,</span> T<span class="token punctuation">)</span>             <span class="token function">Concat</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>T<span class="token punctuation">,</span> S1<span class="token punctuation">,</span> S2<span class="token punctuation">)</span><span class="token function">StrEmpty</span> <span class="token punctuation">(</span>S<span class="token punctuation">)</span>                    <span class="token function">SubString</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>Sub<span class="token punctuation">,</span> S<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token function">ClearString</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span>              <span class="token function">Index</span> <span class="token punctuation">(</span>S<span class="token punctuation">,</span> T<span class="token punctuation">,</span> pos<span class="token punctuation">)</span><span class="token function">Replace</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span> T<span class="token punctuation">,</span> V<span class="token punctuation">)</span>           <span class="token function">StrInsert</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token function">StrDelete</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">}</span>ADT String<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="5-1-1-例题"><a href="#5-1-1-例题" class="headerlink" title="5.1.1 例题"></a>5.1.1 例题</h3><ol>
<li>串的数据对象约束为 字符集</li>
<li>空串‘’的长度为零</li>
<li>在串的基本操作中，通常以 串的整体 作为操作对象</li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">StrAssign</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>T<span class="token punctuation">,</span> chars<span class="token punctuation">)</span>  初始条件：chars 是字符串常量。  操作结果：把 chars 赋为 T 的值。<span class="token function">StrCopy</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>T<span class="token punctuation">,</span> S<span class="token punctuation">)</span>  初始条件：串 S 存在。  操作结果：由串 S 复制得串 T。<span class="token function">DestroyString</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span>  初始条件：串 S 存在。  操作结果：串 S 被销毁。<span class="token function">StrEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span>  初始条件：串S存在。  操作结果：若 S 为空串，则返回TRUE，否则返回 FALSE。 （<span class="token string">''</span> 表示空串，空串的长度为零。）<span class="token function">StrCompare</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>T<span class="token punctuation">)</span>   初始条件：串 S 和 T 存在。   操作结果：    若S <span class="token operator">&gt;</span> T，则返回值 <span class="token operator">&gt;</span> <span class="token number">0</span>；     若S <span class="token operator">=</span> T，则返回值 <span class="token operator">=</span> <span class="token number">0</span>；     若S <span class="token operator">&lt;</span> T，则返回值 <span class="token operator">&lt;</span> <span class="token number">0</span> 。例如：<span class="token function">StrCompare</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token string">'state'</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span>            <span class="token function">StrCompare</span><span class="token punctuation">(</span><span class="token string">'cat'</span><span class="token punctuation">,</span> <span class="token string">'case'</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span>StrLength<span class="token punctuation">(</span>S<span class="token punctuation">)</span>  初始条件：串 S 存在。  操作结果：返回 S 的元素个数， 称为串的长度。<span class="token function">Concat</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>T<span class="token punctuation">,</span>S1<span class="token punctuation">,</span>S2<span class="token punctuation">)</span>  初始条件：串 S1 和 S2 存在。  操作结果：用 T 返回由 S1 和 S2联接而成的新串。例如： <span class="token function">Concat</span><span class="token punctuation">(</span> T<span class="token punctuation">,</span> <span class="token string">'man'</span><span class="token punctuation">,</span> <span class="token string">'kind'</span><span class="token punctuation">)</span>          求得  T <span class="token operator">=</span> <span class="token string">'mankind'</span>    <span class="token function">SubString</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>Sub<span class="token punctuation">,</span> S<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> len<span class="token punctuation">)</span>初始条件：串 S 存在，<span class="token number">1</span>≤pos≤<span class="token function">StrLength</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span>，且<span class="token number">0</span>≤len≤<span class="token function">StrLength</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token operator">-</span>pos<span class="token operator">+</span><span class="token number">1</span>。操作结果：        用 Sub 返回串 S 的第 pos 个字符起长度为 len 的子串，子串为“串” 中的一个字符子序列。<span class="token function">Index</span> <span class="token punctuation">(</span>S<span class="token punctuation">,</span> T<span class="token punctuation">,</span> pos<span class="token punctuation">)</span> 初始条件：串S和T存在，T是非空串，<span class="token number">1</span>≤pos≤<span class="token function">StrLength</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span>。  操作结果： 若主串 S 中存在和串 T 值相同的子串<span class="token punctuation">,</span> 则返回它在主串 S 中第pos个字符之后第一次出现的位置；否则函数值为<span class="token number">0</span>。（ “子串在主串中的位置”意指子串中的第一个字符在主串中的位序。）假设 S <span class="token operator">=</span> <span class="token string">'abcaabcaaabc'</span><span class="token punctuation">,</span>  T <span class="token operator">=</span> <span class="token string">'bca'</span> <span class="token function">Index</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> T<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2</span>；<span class="token function">Index</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> T<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">6</span>；<span class="token function">Index</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> T<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span> 。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="5-1-2-例题"><a href="#5-1-2-例题" class="headerlink" title="5.1.2 例题"></a>5.1.2 例题</h3><ol>
<li>Concat( T, ‘human’, ‘bing’), 求得  T = ‘humanbing’ 。</li>
<li>SubString( sub, ‘discovery’, 4, 5), 求得  sub = ‘cover’。</li>
<li>假设 S = ‘alphaphazero’,  T = ‘pha’ , Index(S, T, 2) = 3。</li>
<li>假设 S = ‘alphaphamaster’, <pre><code>StrDelete (&amp;S, 6, 3), 则S= 'alphamaster'。
</code></pre>
</li>
<li>若串S1=‘ABCDEFG’,S2= ‘1223’,S3=‘###’,执行Substring(&amp;Sub, S1, Strlength(S3) ,Index(S2, ‘2’,1))，<pre><code>则Sub= ‘CD’。
</code></pre>
</li>
</ol>
<h2 id="5-2串的定长顺序表示"><a href="#5-2串的定长顺序表示" class="headerlink" title="5.2串的定长顺序表示"></a>5.2串的定长顺序表示</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSTRLRN</span> <span class="token expression"><span class="token number">255</span></span><span class="token comment">//用户可在255内定义最大串长typedef unsigned char SString [MAXSTRLEN+1];//0号单元存放串的长度Status Concar(SString S1,SString S2,SString &amp;T){    //用T返回S1和S2联结而成的新串。若未截断，则返回TRUE，否则返回Flase    if(S1[0]+S2[0]&lt;=MAXSTRLEN){//未截断        T[1...S1[0]]=S1[1....S1[0]];        T[S1[0]+1...S1[0]+S2[0]]=S2[1...S2[0]];        T[0]=S1[0]+S2[0];        uncut=TRUE;    }    else if(S1[0]&lt;MAXSTRLEN)//截断    {        T[1...S1[0]]=S1[1..S1[0]];        T[S1[0]+1...MAXSTRLEN]=S2[1...MAXSTRLEN-S1[0]];        T[0]=MAXSTRLEN;        uncut=FALSE;}    else{        T[0...MAXSTRLEN]=S1[0...MAXSTRLEN];        uncut=FALSE;    }    return uncut;}//Concat</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="5-3-串的堆分配存储表示"><a href="#5-3-串的堆分配存储表示" class="headerlink" title="5.3 串的堆分配存储表示"></a>5.3 串的堆分配存储表示</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>ch<span class="token punctuation">;</span>  <span class="token comment">//若是非空串，则按串长分配存储区，否则ch为NULL    int length;  //串长度}Hstring    Status Concat(HString &amp;T, HString S1, HString S2) {  // 用T返回由S1和S2联接而成的新串   if (T.ch)  free(T.ch);        // 释放旧空间   if (!(T.ch = (char *)               malloc((S1.length+S2.length)*sizeof(char))))         exit (OVERFLOW);   T.ch[0..S1.length-1] = S1.ch[0..S1.length-1];   T.length = S1.length + S2.length;   T.ch[S1.length..T.length-1] = S2.ch[0..S2.length-1];   return OK;} // Concat Status SubString(HString &amp;Sub, HString S, int pos, int len) {                               // 用Sub返回串S的第pos个字符起长度为len的子串   if (pos &lt; 1  ||  pos &gt; S.length  ||  len &lt; 0  ||  len &gt; S.length-pos+1)         return ERROR;   if (Sub.ch)  free (Sub.ch);             // 释放旧空间   if (!len)   { Sub.ch = NULL;  Sub.length = 0; }        // 空子串   else {  Sub.ch = (char *)malloc(len*sizeof(char));              Sub.ch[0..len-1] = S[pos-1..pos+len-2];              Sub.length = len;  }        // 子串的长度   return OK;} // SubString</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="5-4-串的块链存储表示"><a href="#5-4-串的块链存储表示" class="headerlink" title="5.4 串的块链存储表示"></a>5.4 串的块链存储表示</h2><h3 id="5-4-1-用链表存储串"><a href="#5-4-1-用链表存储串" class="headerlink" title="5.4.1 用链表存储串"></a>5.4.1 用链表存储串</h3><p>也可用链表来存储串值，由于串中的每一个字符是只有 8 位的二进制数，因此用链表存储串时，通常一个结点中存放的不是一个字符，而是一个子串。<br>存储密度 = 数据元素所占存储位/实际分配的存储位<br>存储密度小，处理方便，但是存储量大。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span>  <span class="token macro-name">CHUNKSIZE</span>  <span class="token expression"><span class="token number">80</span>  </span><span class="token comment">// 可由用户定义的块大小  typedef  struct Chunk {  // 结点结构    char  ch[CUNKSIZE];    struct Chunk  *next;  } Chunk;  typedef struct {  // 串的链表结构    Chunk *head, *tail; // 串的头和尾指针     int   curlen;     // 串的当前长度  } LString;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="5-5-串的模式匹配"><a href="#5-5-串的模式匹配" class="headerlink" title="5.5 串的模式匹配*"></a>5.5 串的模式匹配*</h2><h3 id="5-5-1-一般算法"><a href="#5-5-1-一般算法" class="headerlink" title="5.5.1 一般算法"></a>5.5.1 一般算法</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">Index</span><span class="token punctuation">(</span>SStirng S<span class="token punctuation">,</span>SString T<span class="token punctuation">,</span><span class="token keyword">int</span> pos<span class="token punctuation">)</span><span class="token punctuation">{</span>i<span class="token operator">=</span>pos<span class="token punctuation">;</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>S<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>j<span class="token operator">&lt;=</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">++</span>i<span class="token punctuation">;</span><span class="token operator">++</span>j<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//继续比较后继字符        else{            i=i-j+2;  //指针后退重新开始匹配            j=1;}    }    if(j&gt;T[0])return i-T[0];    else return 0;}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="5-5-2-KMP"><a href="#5-5-2-KMP" class="headerlink" title="5.5.2 KMP"></a>5.5.2 KMP</h3><p>KMP算法的时间复杂度可以达到O(m+n), 基本思想是每当字符比较不等时，不需回溯i指针，而是利用已经得到的“部分匹配的结果”将模式向右“滑动”尽可能远的距离，继续进行比较。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">Index_KMP</span><span class="token punctuation">(</span>SString S<span class="token punctuation">,</span> SString T<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 1≤pos≤StrLength(S)     i = pos;   j = 1;     while (i &lt;= S[0] &amp;&amp; j &lt;= T[0]) {         if (j = 0 || S[i] == T[j]) { ++i;  ++j; } // 继续比较后继字符         else  j = next[j];         // 模式串向右移动     }    if (j &gt; T[0])  return  i-T[0];    // 匹配成功    else return 0;} // Index_KMP void get_next(SString &amp;T, int &amp;next[] ) {     // 求模式串T的next函数值并存入数组next     i = 1;   next[1] = 0;   j = 0;      while (i &lt; T[0]) {           if (j = 0 || T[i] == T[j])                 {++i;  ++j; next[i] = j; }           else  j = next[j];      }    } // get_nextvoid get_nextval(SString &amp;T, int &amp;nextval[]) {      i = 1;   nextval[1] = 0;   j = 0;      while (i &lt; T[0]) {          if (j = 0 || T[i] == T[j]) {              ++i;  ++j;              if (T[i] != T[j])  nextval[i] = j;              else  nextval[i] = nextval[j];         }        else  j = nextval[j];     }  } // get_nextval</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h1 id="6-数组和广义表"><a href="#6-数组和广义表" class="headerlink" title="6.数组和广义表"></a>6.数组和广义表</h1><h2 id="6-1-数组"><a href="#6-1-数组" class="headerlink" title="6.1 数组"></a>6.1 数组</h2><p>介绍数组的抽象数据类型</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">ADT Array<span class="token punctuation">{</span>    数据对象：        D<span class="token operator">=</span><span class="token punctuation">{</span>aj1<span class="token punctuation">,</span>j2<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>ji<span class="token operator">|</span>ji<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>bi<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>n<span class="token punctuation">,</span><span class="token function">n</span><span class="token punctuation">(</span><span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span>是数组的维数，bi是数组第i维的长度<span class="token punctuation">}</span>    数据关系：        R<span class="token operator">=</span><span class="token punctuation">{</span>R1<span class="token punctuation">,</span>R2<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>RN<span class="token punctuation">}</span>    	RI<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">&lt;</span>aj1<span class="token punctuation">,</span>j2<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>aji<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>jn<span class="token operator">|</span><span class="token number">0</span><span class="token operator">&lt;=</span>jk<span class="token operator">&lt;=</span>bk<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">&lt;=</span>k<span class="token operator">&lt;=</span>n且k≠i，<span class="token number">0</span><span class="token operator">&lt;=</span>j1<span class="token operator">&lt;=</span>bi<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>n<span class="token punctuation">}</span>    基本操作：        <span class="token function">InitArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        若维数n和各维长度合法，则构造相应的数组A，并返回OK。        <span class="token function">DestroyArray</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token punctuation">)</span>        销毁数组A        <span class="token function">Value</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span><span class="token operator">&amp;</span>e<span class="token punctuation">,</span>index1<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>indexn<span class="token punctuation">)</span>        初始条件：A是n维数组，e为元素变量，随后是n个下标值        操作结果：若各下标不超界，则e赋值为所指定的A的元素值，并返回OK        <span class="token function">Assign</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token punctuation">,</span>e<span class="token punctuation">,</span>index1<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>indexn<span class="token punctuation">)</span>        初始条件：A是n维数组，e为元素变量，随后是n个下标值。        操作结果：若下标不超界，则将e的值赋给所指定的A的元素，并返回OK<span class="token punctuation">}</span>ADT Array<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="6-1-1数组的顺序实现"><a href="#6-1-1数组的顺序实现" class="headerlink" title="6.1.1数组的顺序实现"></a>6.1.1数组的顺序实现</h3><p>两种顺序映像方式：</p>
<ol>
<li><p>以行序为主序（低下标优先）</p>
<p>二维数组A中任一元素ai,j 的存储位置</p>
<pre><code> LOC(i,j) = LOC(0,0) + (b2×i＋j)×L
</code></pre>
</li>
<li><p>以列序为主序（高下标优先）</p>
</li>
</ol>
<p>推广到一般情况，可得到 n 维数组数据元素存储位置的映象关系。</p>
<p>LOC(j1, j2, …, jn ) = LOC(0,0,…,0) + ∑ ci ji </p>
<p>其中 cn = L，ci-1 = bi ×ci ,  1 &lt; i &lt;= n</p>
<p>称为 n 维数组的映象函数, 数组元素的存储位置是其下标的线性函数。</p>
<h4 id="6-1-1-1-例题"><a href="#6-1-1-1-例题" class="headerlink" title="6.1.1.1 例题"></a>6.1.1.1 例题</h4><ol>
<li>设有数组A[i,j]，数组的每个元素长度为3字节，i的值为1到8，j的值为1到10，数组从内存首地址BA开始顺序存放，当用以列为主存放时，元素A[5，8]的存储首地址为( B )。<pre><code>A．BA+141            B．BA+180
C．BA+222            D．BA+225
</code></pre>
</li>
<li>设有二维数组A[0..9,0..19],其每个元素占两个字节，第一个元素的存储地址为100，若按列优先顺序存储，则元素A[6,6]存储地址为（232）。</li>
<li>假设以行序为主序存储二维数组A=array[1..100，1..100]，设每个数据元素占2个存储单元，基地址为10，则LOC[5，5]=（  B  ）。<pre><code>A. 808              B. 818              C. 1010             D. 1020
</code></pre>
</li>
</ol>
<h2 id="6-2-特殊矩阵"><a href="#6-2-特殊矩阵" class="headerlink" title="6.2 特殊矩阵"></a>6.2 特殊矩阵</h2><h3 id="6-2-1-稀疏矩阵"><a href="#6-2-1-稀疏矩阵" class="headerlink" title="6.2.1 稀疏矩阵"></a>6.2.1 稀疏矩阵</h3><p>假设 m 行 n 列的矩阵含 t 个非零元素，则称<br>σ=t/(m*n)</p>
<p> 为稀疏因子，通常认为 σ&lt;= 0.05 的矩阵为稀疏矩阵。</p>
<p>以常规方法，即以二维数组表示高阶的稀疏矩阵时产生的问题:</p>
<ol>
<li> 零值元素占了很大空间;</li>
<li> 计算中进行了很多和零值的运算，遇除法还需判别除数是否为零。</li>
</ol>
<h4 id="6-2-1-1-特殊矩阵"><a href="#6-2-1-1-特殊矩阵" class="headerlink" title="6.2.1.1 特殊矩阵"></a>6.2.1.1 特殊矩阵</h4><p>三角矩阵<br>对称矩阵<br>对角矩阵</p>
<h4 id="6-2-1-2-随机稀疏矩阵"><a href="#6-2-1-2-随机稀疏矩阵" class="headerlink" title="6.2.1.2 随机稀疏矩阵"></a>6.2.1.2 随机稀疏矩阵</h4><p>非零元在矩阵中随机出现。</p>
<h3 id="6-2-2-稀疏矩阵的转置"><a href="#6-2-2-稀疏矩阵的转置" class="headerlink" title="6.2.2 稀疏矩阵的转置"></a>6.2.2 稀疏矩阵的转置</h3><h4 id="6-2-2-1-常规算法"><a href="#6-2-2-1-常规算法" class="headerlink" title="6.2.2.1 常规算法"></a>6.2.2.1 常规算法</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//用常规的二维数组表示时的算法   for (col=1; col&lt;=nu; ++col)        for (row=1; row&lt;=mu; ++row)          T[col][row] = M[row][col];//其时间复杂度为: O(mu×nu)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="6-2-2-2-三元组顺序表"><a href="#6-2-2-2-三元组顺序表" class="headerlink" title="6.2.2.2 三元组顺序表"></a>6.2.2.2 三元组顺序表</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span>  <span class="token macro-name">MAXSIZE</span>  <span class="token expression"><span class="token number">12500</span> <span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>     <span class="token keyword">int</span>  i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>      </span><span class="token comment">//该非零元的行下标和列下标     ElemType  e;    // 该非零元的值 } Triple;  // 三元组类型typedef union {     Triple  data[MAXSIZE + 1];       int     mu, nu, tu; } TSMatrix;  // 稀疏矩阵类型//快速转置算法Status FastTransposeSMatrix(TSMatrix M, TSMatrix &amp;T){  T.mu = M.nu;  T.nu = M.mu;  T.tu = M.tu;  if (T.tu) {    for (col=1; col&lt;=M.nu; ++col)  num[col] = 0;    for (t=1; t&lt;=M.tu; ++t)  ++num[M.data[t].j];    cpot[1] = 1;    for (col=2; col&lt;=M.nu; ++col)       cpot[col] = cpot[col-1] + num[col-1];    for (p=1; p&lt;=M.tu; ++p) {转置矩阵元素}  } // if  return OK;} // FastTransposeSMatrix// O(M.nu+M.tu)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="6-3-广义表"><a href="#6-3-广义表" class="headerlink" title="6.3 广义表"></a>6.3 广义表</h2><p>广义表是递归定义的线性结构，<br>       LS = ( a1, a2,…, an )<br>其中：i  或为原子 或为广义表。<br>例如:   A = (  )<br>             F = (d, (e))<br>             D = ((a,(b,c)), F)<br>             C = (A, D, F)<br>             B = (a, B) = (a, (a, (a, … ,  ) ) )</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//广义表的抽象数据类型ADT Glist {  数据对象：D＝{ei | i=1,2,..,n;  n≥0;                     ei∈AtomSet 或 ei∈GList,                    AtomSet为某个数据对象  }  数据关系：            LR＝{&lt;ei-1, ei &gt;| ei-1 ,ei∈D, 2≤i≤n}  基本操作：   //结构的创建和销毁   InitGList(&amp;L);      DestroyGList(&amp;L);   CreateGList(&amp;L, S);   CopyGList(&amp;T, L);   //状态函数   GListLength(L);   GListDepth(L);   GListEmpty(L);   GetHead(L);    GetTail(L);   //插入和删除操作   InsertFirst_GL(&amp;L, e);   DeleteFirst_GL(&amp;L, &amp;e);   //遍历   Traverse_GL(L, Visit());} ADT Glist</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="6-3-1-例题"><a href="#6-3-1-例题" class="headerlink" title="6.3.1 例题"></a>6.3.1 例题</h3><ol>
<li>广义表（（a,b,c,d））的表头是（  C  ），表尾是（  B  ）。<pre><code>A. a             B.（）             C.（a,b,c,d）     D.（b,c,d）
</code></pre>
</li>
<li>下面说法不正确的是(  A  )。 <pre><code>A. 广义表的表头总是一个广义表        B. 广义表的表尾总是一个广义表
C. 广义表难以用顺序存储结构          D. 广义表可以是一个多层次的结构
</code></pre>
</li>
<li>当广义表中的每个元素都是原子时，广义表便成了_______。线性表</li>
<li>广义表的表尾是指除第一个元素之外，_______。其余元素组成的表</li>
<li>设广义表L=（（a,b,c）），则L的长度和深度分别为（  C  ）。<pre><code>A. 1和1         B. 1和3            C. 1和2         D. 2和3
</code></pre>
</li>
</ol>
<h3 id="6-3-2-广义表的实现"><a href="#6-3-2-广义表的实现" class="headerlink" title="6.3.2 广义表的实现"></a>6.3.2 广义表的实现</h3><p>介绍广义表的头尾链表存储表示以及子表分析法存储表示。</p>
<h4 id="6-3-2-1-头尾链表存储表示"><a href="#6-3-2-1-头尾链表存储表示" class="headerlink" title="6.3.2.1 头尾链表存储表示"></a>6.3.2.1 头尾链表存储表示</h4><p>表结点：</p>
<table>
<thead>
<tr>
<th>tag=1</th>
<th>hp</th>
<th>tp</th>
</tr>
</thead>
</table>
<p>原子结点：</p>
<table>
<thead>
<tr>
<th>tag=0</th>
<th>data</th>
</tr>
</thead>
</table>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210609141312905.png" alt="image-20210609141312905"></p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210609142225459.png" alt="image-20210609142225459"></p>
<h4 id="6-3-2-2-子表分析法"><a href="#6-3-2-2-子表分析法" class="headerlink" title="6.3.2.2 子表分析法"></a>6.3.2.2 子表分析法</h4><p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210609142338989.png" alt="image-20210609142338989"></p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210609142455799.png" alt="image-20210609142455799"></p>
<h4 id="6-3-2-3-例题"><a href="#6-3-2-3-例题" class="headerlink" title="6.3.2.3 例题"></a>6.3.2.3 例题</h4><ol>
<li>广义表A=((a) , ((b,c),d))，画出头尾链表存储结构，求其长度和深度。  </li>
</ol>
<p>长度2，深度3。</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210609142807613.png" alt="image-20210609142807613"></p>
<ol start="2">
<li>已知广义表 LS=((a,b), (c,d,e,f), g)， head 和 tail 分别是求表头和表尾，则tail( tail( head( tail(LS)))) 的运算结果是_____。(e , f）</li>
<li>广义表运算式HEAD(TAIL(((a,b,c),(x,y,z))))的结果是_______。(x,y,z)</li>
</ol>
<h3 id="6-3-3-广义表的递归操作"><a href="#6-3-3-广义表的递归操作" class="headerlink" title="6.3.3 广义表的递归操作"></a>6.3.3 广义表的递归操作</h3><p>内容：介绍广义表的递归操作</p>
<ol>
<li>递归函数</li>
</ol>
<p>一个含直接或间接调用本函数语句的函数被称之为递归函数，它必须满足以下两个条件：<br>1)在每一次调用自己时，必须是(在某种意义上)更接近于解;<br>2)必须有一个终止处理或计算的准则。</p>
<ol start="2">
<li>用分治法设计递归函数</li>
</ol>
<p>​        对于一个输入规模为 n 的函数或问题，用某种方法把输入分割成k (1&lt;k≤n)个子集，从而产生 l 个子问题，分别求解这 l 个问题，得出 l 个问题的子解，再用某种方法把它们组合成原来问题的解。若子问题还相当大，则可以反复使用分治法，直至最后所分得的子问题足够小，以至可以直接求解为止。<br>​        在利用分治法求解时，所得子问题的类型常常和原问题相同，因而很自然地导致递归求解。</p>
<ol start="3">
<li>对广义表进行分解</li>
</ol>
<p>广义表从结构上可以分解成<br>                    广义表 = 表头 + 表尾   </p>
<p>或者<br>                    广义表 = 子表1 + 子表2 +  ··· + 子表n<br>因此常利用分治法求解之。<br>算法设计中的关键问题是，如何将 l 个子问题的解组合成原问题的解。</p>
<ol start="4">
<li>求广义表的深度</li>
</ol>
<p> 将广义表分解成 n 个子表，分别(递归)求得每个子表的深度，<br>广义表的深度=Max {子表的深度} +1<br>可以直接求解的两种简单情况为：<br>    空表的深度 = 1<br>    原子的深度 = 0</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*广义表的深度=Max {子表的深度} +1空表的深度 = 1，    原子的深度 = 0例：D=( A,B,C )=( ( ),(e),(a,(b,c,d)))DEPTH(D)=1+MAX{ DEPTH(A),DEPTH(B),DEPTH(C)}DEPTH(C)=1+MAX{ DEPTH(a),DEPTH((b,c,d))}=2DEPTH(D)=1+MAX{ 1,1,2}=3*/</span><span class="token keyword">typedef</span> <span class="token keyword">enum</span> <span class="token punctuation">{</span>ATOM<span class="token punctuation">,</span> LIST<span class="token punctuation">}</span> ElemTag<span class="token punctuation">;</span>          <span class="token comment">// ATOM==0:原子, LIST==1:子表typedef struct GLNode {   ElemTag  tag;   // 标志域   union{     AtomType  atom;      // 原子结点的数据域     struct {struct GLNode *hp, *tp;} ptr;   };} *GListint GlistDepth(Glist L) {       // 返回指针L所指的广义表的深度     if (!L) return 1;      if (L-&gt;tag == ATOM) return 0;      for (max=0, pp=L; pp; pp=pp-&gt;ptr.tp){        dep = GlistDepth(pp-&gt;ptr.hp);        if (dep &gt; max) max = dep;     }     return max + 1;  } // GlistDepth    </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h1 id="7-树"><a href="#7-树" class="headerlink" title="7. 树"></a>7. 树</h1><h2 id="7-1-树的逻辑结构"><a href="#7-1-树的逻辑结构" class="headerlink" title="7.1 树的逻辑结构"></a>7.1 树的逻辑结构</h2><p>树的类型定义</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">数据对象D：    D是具有相同特性的数据元素的集合数据关系R：    若D 为空集，则称为空树，否则：    <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>在D中存在唯一的称为根的数据元素root。    <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>当n<span class="token operator">&gt;=</span><span class="token number">1</span>时，其余结点可分为<span class="token function">m</span><span class="token punctuation">(</span>m<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span>个互不相交的有限集T1<span class="token punctuation">,</span>T2<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Tm<span class="token punctuation">,</span>其中每一棵子集本身又是一棵符合本定义的树，称为根root的子树。    <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>查找类的操作：</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">Root</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token comment">//求树的根结点Value(T,cur_e)//求当前结点的元素值Parent(T,cur_e)//求当前结点的双亲结点LeftChild(T,cur_e)//求当前结点的最左孩子RightSibling(T,cur_e)//求当前结点的最右兄弟TreeEmpty(T)//判定树是否为空树TreeDepth(T)//求树的深度TraverseTree(T,visit())//变量</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>插入类的操作</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">InitTree</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>T<span class="token punctuation">)</span><span class="token comment">//初始化置空树CreateTree(&amp;T,definition)//按定义构造树Assign(T,cur_e,value)//给当前结点赋值InsertChild(&amp;T,&amp;p,i,c)//将以c为根的树插入为结点p的第i棵子树</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>删除类的操作</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ClearTree</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>T<span class="token punctuation">)</span><span class="token comment">//将树清空DestroyTree(&amp;T)//销毁树的结果DeleteChild(&amp;T,&amp;p,i)//删除结点p的第i棵子树</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>树型结构和线性结构的比较</li>
</ul>
<table>
<thead>
<tr>
<th>线性结构</th>
<th>树型结构</th>
</tr>
</thead>
<tbody><tr>
<td>第一个数据元素（无前驱）</td>
<td>根结点（无前驱）</td>
</tr>
<tr>
<td>最后一个数据元素（无后继）</td>
<td>多个叶子结点（无后继）</td>
</tr>
<tr>
<td>其它数据元素（一个前驱，一个后继）</td>
<td>其它数据元素（一个前驱，多个后继）</td>
</tr>
</tbody></table>
<h3 id="7-1-1-例题"><a href="#7-1-1-例题" class="headerlink" title="7.1.1 例题"></a>7.1.1 例题</h3><ol>
<li>树一定有唯一的根结点（X)</li>
<li>树的根结点有若干棵子树，则除树的根结点外的任一结点只能属于一棵子树（√）</li>
<li>树中结点最多只能有一个前驱，但可能有多个后继（√）</li>
</ol>
<h2 id="7-2-树的基本术语"><a href="#7-2-树的基本术语" class="headerlink" title="7.2 树的基本术语"></a>7.2 树的基本术语</h2><ul>
<li><p>结点：数据元素+若干指向子树的分支。</p>
</li>
<li><p>结点的度：分支的个数。</p>
</li>
<li><p>树的度：树中所有结点的度的最大值</p>
</li>
<li><p>叶子结点：度为零的结点</p>
</li>
<li><p>分支结点：度大于零的结点</p>
</li>
<li><p>有向树：</p>
</li>
</ul>
<p>（1）有确定的根</p>
<p>（2）树根和子树根为有向关系</p>
<ul>
<li>有序树：</li>
</ul>
<p>子树之间存在确定的次序关系</p>
<ul>
<li>无序树：</li>
</ul>
<p>子树之间不存在确定的次序关系</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610141428614.png" alt="image-20210610141428614"></p>
<ul>
<li>结点的层次：</li>
</ul>
<p>假设根结点的层次为1，第l层的结点的子树根结点的层次为l+1</p>
<ul>
<li>树的深度：</li>
</ul>
<p>树中叶子结点所在的最大层次</p>
<ul>
<li>森林：m棵互不相交的树的集合。</li>
</ul>
<p>任何一棵非空树是一个二元组：Tree=(root,F)</p>
<p>其中：root被称为根结点。</p>
<p>​           F被称为子树森林。</p>
<h3 id="7-2-1-例题"><a href="#7-2-1-例题" class="headerlink" title="7.2.1 例题"></a>7.2.1 例题</h3><p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610143430902.png" alt="image-20210610143430902"></p>
<ol>
<li><p>树的度：3</p>
</li>
<li></li>
</ol>
<p>$n_0$=6</p>
<p>$n_1$=2</p>
<p>$n_2$=1</p>
<p>$n_3$=2</p>
<p>$n$=11</p>
<ol start="3">
<li>结点F的祖先结点包括：E,C,J</li>
<li>结点G 的子孙结点包括：D,H,I,B</li>
<li>从结点J到结点H的路径包括：结点J,G,D,H；路径：JG,GD,DH</li>
<li>树的深度为：4</li>
<li>非叶子/非终端结点包括J,C,G,E,D，内部结点包括C,G,E,D</li>
<li>树中每个结点有唯一的双亲结点，根结点除外（x）</li>
</ol>
<h2 id="7-3-二叉树的性质"><a href="#7-3-二叉树的性质" class="headerlink" title="7.3 二叉树的性质"></a>7.3 二叉树的性质</h2><h3 id="7-3-1-二叉树的性质1"><a href="#7-3-1-二叉树的性质1" class="headerlink" title="7.3.1 二叉树的性质1"></a>7.3.1 二叉树的性质1</h3><p>在二叉树的第i层上至多有 $ 2^{i-1} $个结点</p>
<h3 id="7-3-2-二叉树的性质2"><a href="#7-3-2-二叉树的性质2" class="headerlink" title="7.3.2 二叉树的性质2"></a>7.3.2 二叉树的性质2</h3><p>深度为$ k $的二叉树至多含$2^{k-1}$个结点（k&gt;=1)</p>
<h3 id="7-3-3-二叉树的性质3"><a href="#7-3-3-二叉树的性质3" class="headerlink" title="7.3.3 二叉树的性质3"></a>7.3.3 二叉树的性质3</h3><p>对于任何一棵二叉树，若它含有$n_0$个叶子结点，$n_2$个度为2的结点，则必存在关系式：$n_0=n_2+1$。</p>
<h3 id="7-3-4-二叉树的性质4"><a href="#7-3-4-二叉树的性质4" class="headerlink" title="7.3.4 二叉树的性质4"></a>7.3.4 二叉树的性质4</h3><p><strong>满二叉树</strong>：指的是深度为$k$,且含有$2^k-1$个结点的二叉树。</p>
<p><strong>完全二叉树</strong>：树中所含的$n$个结点和满二叉树中编号为1至$n$的结点相对应。</p>
<p><strong>具有n个结点的完全二叉树的深度为</strong>：$[log_2n]+1$(向下取整)</p>
<h3 id="7-3-5-二叉树的性质5"><a href="#7-3-5-二叉树的性质5" class="headerlink" title="7.3.5 二叉树的性质5"></a>7.3.5 二叉树的性质5</h3><p>若对含n个结点的完全二叉树从上到下且从左至右进行1至n的编号，则对完全二叉树中任意一个编号为$i$的结点：</p>
<p>（1）若$i=1$,则该结点是二叉树的根，无双亲，否则，编号为[i/2]（向下取整）的结点为其双亲结点。</p>
<p>（2）若$2i&gt;n$，则该结点无左孩子，否则，编号为$2i$的结点为其左孩子结点。</p>
<p>（3）若$2i+1&gt;n$则该结点无右孩子，否则编号为$2i+1$的结点为其右孩子结点。</p>
<h3 id="7-3-6-例题"><a href="#7-3-6-例题" class="headerlink" title="7.3.6 例题"></a>7.3.6 例题</h3><ol>
<li>在结点个数为n(n&gt;1)的各种形态的树中，深度最小的树有 2 层。</li>
<li>在一棵深度为6的完全二叉树中，最少可以有多少结点，最多可以有多少个结点？ 最少：32 最多：63</li>
<li>在完全二叉树中，结点总数$n$为999，求叶子结点数$n_0$为多少？ 500</li>
<li>在完全二叉树中，结点总数为n，求叶子结点数为多少？</li>
</ol>
<p>  $n_0=n_2+1$</p>
<p>$n=2n_0+n1-1$</p>
<p>在完全二叉树中，$n_1$只能为1或0</p>
<p>当$n_1$为1时，$n$只能是偶数，$n_0=n/2$</p>
<p>当$n_1$为0时，$n$只能是奇数，$n_0=(n+1)/2$</p>
<p>所以$n_0=[(n+1)/2]$ （向下取整）</p>
<h2 id="7-4-二叉树的存储表示"><a href="#7-4-二叉树的存储表示" class="headerlink" title="7.4 二叉树的存储表示"></a>7.4 二叉树的存储表示</h2><h3 id="7-4-1-二叉树的二叉链表存储表示"><a href="#7-4-1-二叉树的二叉链表存储表示" class="headerlink" title="7.4.1 二叉树的二叉链表存储表示"></a>7.4.1 二叉树的二叉链表存储表示</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAX_TREE_SIE 100//二叉树的最大结点树typedef TElemType SqBiTree[MAX_TREE_SIZE];//0号单元存储根结点SqBiTree bt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610144237640.png" alt="image-20210610144237640"></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BiTNode</span><span class="token punctuation">{</span><span class="token comment">//结点结构	TElemType data;    struct BiTNode *lchild,*rchild;//左右孩子指针}BiTNode，*BiTree;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610144410074.png" alt="image-20210610144410074"></p>
<h3 id="7-4-2-二叉树的三叉链表存储表示"><a href="#7-4-2-二叉树的三叉链表存储表示" class="headerlink" title="7.4.2 二叉树的三叉链表存储表示"></a>7.4.2 二叉树的三叉链表存储表示</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">TriTNode</span><span class="token punctuation">{</span><span class="token comment">//结点结构    TElemType data;    struct TriTNode *lchild,*rchild;//左右孩子指针    struct TriTNode *parent;//双亲指针}TriTNode, *TriTree;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610144729698.png" alt="image-20210610144729698"></p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610144854144.png" alt="image-20210610144854144"></p>
<h3 id="7-4-3-二叉树的双亲链表存储表示"><a href="#7-4-3-二叉树的双亲链表存储表示" class="headerlink" title="7.4.3 二叉树的双亲链表存储表示"></a>7.4.3 二叉树的双亲链表存储表示</h3><table>
<thead>
<tr>
<th>data</th>
<th>parent</th>
<th>LRTag</th>
</tr>
</thead>
</table>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">typedeg strcut BPTNode<span class="token punctuation">{</span><span class="token comment">//结点结构	TElemType data;    int *parent;//指向双亲的指针    char LRTag;//左、右孩子标志域}BPTNode;typedef struct BPTree{//树结构    BPTNode nodes[MAX_TREE_SIZE];    int num_node;//结点数目    int root;//根结点的数模}BPTree;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="7-4-1-例题"><a href="#7-4-1-例题" class="headerlink" title="7.4.1 例题"></a>7.4.1 例题</h3><ol>
<li>如果二叉树用二叉链表表示，有多少个空链域？</li>
</ol>
<p>空链域：<br>$$<br>2 n0+n1=n0+n0+n1=n2+1+n0+n1=n+1<br>$$</p>
<ol start="2">
<li>如果二叉树用三叉链表表示，有多少个空链域？</li>
</ol>
<p>每个结点的双亲指针都不空，但根结点的双亲指针为空，所以有n+2个空链域。</p>
<ol start="3">
<li>二叉树不能用顺序结构来储存。</li>
</ol>
<h3 id="7-5-二叉树的遍历"><a href="#7-5-二叉树的遍历" class="headerlink" title="7.5 二叉树的遍历"></a>7.5 二叉树的遍历</h3><p>介绍二叉树的各种递归和非递归的遍历方法，以及如何建立二叉树的存储结构。</p>
<p><strong>二叉树遍历的搜索路径</strong></p>
<p>对“二叉树”而言，可以有三条搜索路径：<br>1．先上后下的按层次遍历；<br>2．先左（子树）后右（子树）的遍历；<br>3．先右（子树）后左（子树）的遍历。</p>
<p><strong>先左后右的遍历算法</strong></p>
<p>先（根）序的遍历算法<br>中（根）序的遍历算法<br>后（根）序的遍历算法</p>
<p><strong>先（根）序的遍历算法</strong><br>若二叉树为空树，则空操作；否则，<br>（1）访问根结点；<br>（2）先序遍历左子树；<br>（3）先序遍历右子树。<br>  $-+a*b-cd/ef$</p>
<p><strong>中（根）序的遍历算法</strong></p>
<p>若二叉树为空树，则空操作；否则，<br>（1）中序遍历左子树；<br>（2）访问根结点；<br>（3）中序遍历右子树。<br>$a+b*c-d-e/f$</p>
<p><strong>后（根）序的遍历算法</strong></p>
<p> 若二叉树为空树，则空操作；否则，<br>（1）后序遍历左子树；<br>（2）后序遍历右子树；<br>（3）访问根结点。<br>  $abcd-*+ef/-$</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//递归void Preorder (BiTree T, void( *visit)(TElemType &amp;e)){ // 先序遍历二叉树    if (T) {      visit(T-&gt;data);            // 访问结点      Preorder(T-&gt;lchild, visit);   // 遍历左子树      Preorder(T-&gt;rchild, visit);  // 遍历右子树   }}//先序非递归Status InOrderTraverse(BiTree T, Status (*Visit)(TElemType e))   {  InitStack(S); Push(S,T);   //根指针进栈     while (!StackEmpty (S)) {          while(GetTop(S, p) &amp;&amp; p) Push (S,p-&gt;lchild);          Pop(S, p);   //空指针退栈          if (!StackEmpty(S)){  //访问节点，退后一步               Pop (S, p); if (!Visit(p-&gt;data))   return ERROR;               Push(S,p-&gt;rchild);          }  //if     }  //while     return OK;  }</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610155215420.png" alt="image-20210610155215420"></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//层次遍历算法的非递归描述void translevel(BinNode  *bt) { struct BinNode  *b;   q.front=0;     q.rear=0;     if (!bt)   return;   q.elem[q.rear]=bt;     q.rear=q.rear+1;    while (q.front &lt; q.rear)     { b=q.elem[q.front];   q.front=q.front+1;       printf("%c  ",b-&gt;data);        if (b-&gt;lch!=0)              { q.elem[q.rear]=b-&gt;lch;              q.rear=q.rear+1;         }        if (b-&gt;rch!=0)                 { q.elem[q.rear]=b-&gt;rch;                                                       q.rear=q.rear+1;                                             }     }}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="7-5-1-例题"><a href="#7-5-1-例题" class="headerlink" title="7.5.1 例题"></a>7.5.1 例题</h3><ol>
<li><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610160210279.png" alt="image-20210610160210279"></li>
</ol>
<p>先序遍历：JCEMFNGDHIB</p>
<p>中序遍历：MFNECJHDIBG</p>
<p>后序遍历：NFMECHBIDGJ</p>
<ol start="2">
<li>若二叉树先序遍历的扩展序列为AB<em>D</em>EC<strong>F</strong><em>,其中</em>代表空链域，则二叉树的后序遍历序列为CFEDBA。</li>
<li>已知一棵二叉树的中序遍历序列为DBACFEGM，后序遍历序列为DAFGECBM，画出这棵二叉树，并给出先序遍历序列。</li>
</ol>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610160308052.png" alt="image-20210610160308052"></p>
<p>先序遍历序列：MBDCAEFG</p>
<h2 id="7-5-二叉树遍历算法的应用"><a href="#7-5-二叉树遍历算法的应用" class="headerlink" title="7.5 二叉树遍历算法的应用"></a>7.5 二叉树遍历算法的应用</h2><h3 id="7-5-1-建立二叉树的存储结构"><a href="#7-5-1-建立二叉树的存储结构" class="headerlink" title="7.5.1 建立二叉树的存储结构"></a>7.5.1 建立二叉树的存储结构</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">Status <span class="token function">CreateBiTree</span><span class="token punctuation">(</span>BiTree <span class="token operator">&amp;</span>T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">Scanf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ch<span class="token operator">==</span><span class="token string">'#'</span><span class="token punctuation">)</span>T<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>T<span class="token operator">=</span><span class="token punctuation">(</span>BiTNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">exit</span><span class="token punctuation">(</span>OVERFLOW<span class="token punctuation">)</span><span class="token punctuation">;</span>        T<span class="token operator">-&gt;</span>data<span class="token operator">=</span>ch<span class="token punctuation">;</span>        <span class="token function">CreateBiTree</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//构造左子树        CreateBiTree(T-&gt;rchild);//构造右子树    }    return OK；}//CreateBiTree</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610162736979.png" alt="image-20210610162736979"></p>
<h3 id="7-5-2-统计二叉树中叶子结点个数"><a href="#7-5-2-统计二叉树中叶子结点个数" class="headerlink" title="7.5.2 统计二叉树中叶子结点个数"></a>7.5.2 统计二叉树中叶子结点个数</h3><p>算法基本思想:<br>先序(或中序或后序)遍历二叉树，在遍历过程中查找叶子结点，并计数。<br>由此，需在遍历算法中增添一个“计数”的参数，并将算法中“访问结点”的操作改为：若是叶子，则计数器增1。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">CountLeaf</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&amp;</span> count<span class="token punctuation">)</span><span class="token punctuation">{</span>	<span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>T<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span><span class="token operator">!</span>T<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span>_           count<span class="token operator">++</span><span class="token punctuation">;</span>         <span class="token function">CountLeaf</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>lchild<span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">CountLeaf</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>rchild<span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="7-5-3-求二叉树的深度"><a href="#7-5-3-求二叉树的深度" class="headerlink" title="7.5.3 求二叉树的深度"></a>7.5.3 求二叉树的深度</h3><p>算法基本思想:<br>首先分析二叉树的深度和它的左、右子树深度之间的关系。<br>从二叉树深度的定义可知，二叉树的深度应为其左、右子树深度的最大值加1。由此，需先分别求得左、右子树的深度，算法中“访问结点”的操作改为：二叉树的深度为其左、右子树深度的最大值加1。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">Depth</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>T<span class="token punctuation">)</span>depthval<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        depthleft<span class="token operator">=</span><span class="token function">Depth</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        depthright<span class="token operator">=</span><span class="token function">Depth</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        depthval<span class="token operator">=</span><span class="token number">1</span><span class="token operator">+</span><span class="token punctuation">(</span>depthleft<span class="token operator">&gt;</span>depthright<span class="token operator">?</span>depthleft<span class="token operator">:</span>depthright<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> depthval<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="7-5-4-复制二叉树（后序遍历）"><a href="#7-5-4-复制二叉树（后序遍历）" class="headerlink" title="7.5.4 复制二叉树（后序遍历）"></a>7.5.4 复制二叉树（后序遍历）</h3><p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610163429478.png" alt="image-20210610163429478"></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//生成一个二叉树的结点//(其数据域为item,左指针域为lptr,右指针域为rptr)BiTNode *GetTreeNode(TElemType item, BiTNode *lptr, BiTNode *rptr ){    if (!(T = (BiTNode*)malloc(sizeof(BiTNode))))       exit(1);    T-&gt; data = item;    T-&gt; lchild = lptr;    T-&gt; rchild = rptr;    return T;}BiTNode *CopyTree(BiTNode *T) {      if (!T )    return NULL;    if (T-&gt;lchild )          newlptr = CopyTree(T-&gt;lchild);//复制左子树    else  newlptr = NULL;    if (T-&gt;rchild )         newrptr = CopyTree(T-&gt;rchild);//复制右子树    else  newrptr = NULL;    newT = GetTreeNode(T-&gt;data, newlptr, newrptr);    return newT;} // CopyTree</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="7-5-5-交换二叉树的左右子树"><a href="#7-5-5-交换二叉树的左右子树" class="headerlink" title="7.5.5 交换二叉树的左右子树"></a>7.5.5 交换二叉树的左右子树</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">Void <span class="token function">exchange</span> <span class="token punctuation">(</span>BinNode  <span class="token operator">*</span>T <span class="token punctuation">)</span> <span class="token punctuation">{</span> BinNode  <span class="token operator">*</span>q<span class="token punctuation">;</span>  <span class="token comment">//中间变量   if ( T )         { q = T-&gt;lchild ;           T-&gt;lchild= T-&gt;rchild;           T-&gt;rchild = q;              exchange(T-&gt;lchild);           exchange(T-&gt;rchild);         } }</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="7-6-线索二叉树"><a href="#7-6-线索二叉树" class="headerlink" title="7.6 线索二叉树"></a>7.6 线索二叉树</h2><p> 内容：介绍线索二叉树的特性、中序线索二叉树的遍历和构建。</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610163929701.png" alt="image-20210610163929701"></p>
<p><strong>先序序列:</strong><br>  A B C D E F G H K<br>指向该线性序列中的“前驱”和<br>“后继” 的指针，称作“线索”。<br>包含 “线索” 的存储结构，称作 “线索链表”。<br>与其相应的二叉树，称作 “线索二叉树” 。</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610163958102.png" alt="image-20210610163958102"></p>
<p><strong>对线索链表中结点的约定：</strong><br>在二叉链表的结点中增加两个标志域，</p>
<table>
<thead>
<tr>
<th>lchild</th>
<th>ltag</th>
<th>data</th>
<th>rtag</th>
<th>rchild</th>
</tr>
</thead>
</table>
<p>并作如下规定：<br>    <strong>若该结点的左子树不空，</strong><br>    则Lchild域的指针指向其左子树，<br>    且左标志域的值为“指针 Link”；<br>    <strong>否则，Lchild域的指针指向其“前驱”，</strong><br>    且左标志的值为“线索 Thread” 。</p>
<p>   <strong>若该结点的右子树不空，</strong><br>   则rchild域的指针指向其右子树，<br>   且右标志域的值为 “指针 Link”；<br>   <strong>否则，rchild域的指针指向其“后继”，</strong><br>   且右标志的值为“线索 Thread”。 </p>
<p>   如此定义的二叉树的存储结构称作“线索链表”。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">enum</span><span class="token punctuation">{</span>Link<span class="token punctuation">,</span>Thread<span class="token punctuation">}</span>PointerThr<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BiThrNode</span><span class="token punctuation">{</span>    TElemType data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">BiThrNode</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span><span class="token operator">*</span>child<span class="token punctuation">;</span><span class="token comment">//左右指针    PointerThr LTag，RTag;//左右标志}BiThrNode,*BiThrTree;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>中序遍历序列CBHFAEGD</li>
</ul>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610164614260.png" alt="image-20210610164614260"></p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610164619509.png" alt="image-20210610164619509"></p>
<h3 id="7-6-1-变量中序线索二叉树"><a href="#7-6-1-变量中序线索二叉树" class="headerlink" title="7.6.1 变量中序线索二叉树"></a>7.6.1 变量中序线索二叉树</h3><p>由于在线索链表中添加了遍历中得到的“前驱”和“后继”的信息，从而简化了遍历的算法。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span> p <span class="token operator">=</span> <span class="token function">firstNode</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span> p<span class="token punctuation">;</span> p <span class="token operator">=</span> <span class="token function">Succ</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">)</span>          <span class="token function">Visit</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>中序遍历的第一个结点 ？<br>   左子树上处于“最左下”（没有左子树）的结点。<br>在中序线索化链表中结点的后继 ？<br>   若无右子树，则为后继线索所指结点；<br>   否则为对其右子树进行中序遍历时访问的第一个结点。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">Status <span class="token function">InOrderTraverse_Thr</span><span class="token punctuation">(</span>BiThrTree T<span class="token punctuation">,</span> <span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>Visit<span class="token punctuation">)</span><span class="token punctuation">(</span>TElemType e<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> p <span class="token operator">=</span> T<span class="token operator">-&gt;</span>lchild<span class="token punctuation">;</span>       <span class="token comment">// p指向根结点  while (p != T) {     // 空树或遍历结束时，p==T     while (p-&gt;LTag==Link)  p = p-&gt;lchild;  // 第一个结点     if (!Visit (p-&gt;data)) return ERROR;     while (p-&gt;RTag==Thread &amp;&amp; p-&gt;rchild!=T) {         p = p-&gt;rchild;  Visit(p-&gt;data);      // 访问后继结点     }     p = p-&gt;rchild;          // p进至其右子树根  }  return OK;} // InOrderTraverse_Thr。</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="7-6-3-构造中序线索二叉树"><a href="#7-6-3-构造中序线索二叉树" class="headerlink" title="7.6.3 构造中序线索二叉树"></a>7.6.3 构造中序线索二叉树</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">InThreading</span><span class="token punctuation">(</span>BiThrTree p<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 对以p为根的非空二叉树进行线索化    InThreading(p-&gt;lchild);      // 左子树线索化    if (!p-&gt;lchild)      // 建前驱线索      { p-&gt;LTag = Thread;    p-&gt;lchild = pre; }    if (!pre-&gt;rchild)   // 建后继线索      { pre-&gt;RTag = Thread;   pre-&gt;rchild = p; }     pre = p;             // 保持 pre 指向 p 的前驱    InThreading(p-&gt;rchild);      // 右子树线索化  } // if} // InThreadingStatus InOrderThreading(BiThrTree &amp;Thrt, BiThrTree T) // 构建中序线索链表 {  if (!(Thrt = (BiThrTree)malloc(sizeof( BiThrNode)))) exit (OVERFLOW);   Thrt-&gt;LTag = Link;  Thrt-&gt;RTag =Thread; Thrt-&gt;rchild = Thrt;  // 添加头结点if (!T)  Thrt-&gt;lchild = Thrt; else {                Thrt-&gt;lchild = T;   pre = Thrt;   InThreading(T);                    pre-&gt;rchild = Thrt;   // 处理最后一个结点   pre-&gt;RTag = Thread;       Thrt-&gt;rchild = pre;          }   return OK;} // InOrderThreading</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="7-6-4-例题"><a href="#7-6-4-例题" class="headerlink" title="7.6.4 例题"></a>7.6.4 例题</h3><ol>
<li>已知二叉树，画出中序线索链表</li>
</ol>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610170622496.png" alt="image-20210610170622496"></p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610170755772.png" alt="image-20210610170755772"></p>
<ol start="2">
<li>引入二叉线索树的目的是(c)</li>
</ol>
<p>​        A. 为了能方便地找到双亲<br>​        B. 为了能在二叉树中方便地进行插入和删除<br>​        C. 加快查找结点的前驱或后继的速度<br>​        D. 使二叉树的遍历结果唯一</p>
<ol start="3">
<li><p>在遍历中序线索二叉树时，某结点既有左子树又有右子树，那么它的前驱是其(D)</p>
<p>A. 右子树中最左下的结点    </p>
<p>B. 右子树中最右下的结点       </p>
<p>C. 左子树中最左下的结点      </p>
<p>D. 左子树中最右下的结点</p>
</li>
</ol>
<h2 id="7-7-树和森林的存储结构"><a href="#7-7-树和森林的存储结构" class="headerlink" title="7.7 树和森林的存储结构"></a>7.7 树和森林的存储结构</h2><h3 id="7-7-1-双亲表示法（树）"><a href="#7-7-1-双亲表示法（树）" class="headerlink" title="7.7.1 双亲表示法（树）"></a>7.7.1 双亲表示法（树）</h3><p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610171039847.png" alt="image-20210610171039847"></p>
<table>
<thead>
<tr>
<th>ID</th>
<th>data</th>
<th>parent</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>A</td>
<td>-1</td>
</tr>
<tr>
<td>1</td>
<td>B</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>C</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>D</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>E</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>F</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>G</td>
<td>5</td>
</tr>
</tbody></table>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_TREE_SIZE</span> <span class="token expression"><span class="token number">100</span>typedef <span class="token keyword">struct</span> <span class="token class-name">PTNode</span><span class="token punctuation">{</span></span><span class="token comment">//结点结构    Elem data;    int parent;//双亲位置域}PTNode;typedef struct{//树结构    PTNode nodes[MAX_TREE_SIZE];    int r,n;//根结点的位置和结点个数}PTree;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<table>
<thead>
<tr>
<th>data</th>
<th>parent</th>
</tr>
</thead>
</table>
<h3 id="7-7-2-孩子链表表示法（树）"><a href="#7-7-2-孩子链表表示法（树）" class="headerlink" title="7.7.2 孩子链表表示法（树）"></a>7.7.2 孩子链表表示法（树）</h3><p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610171558162.png" alt="image-20210610171558162"></p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610171652343.png" alt="image-20210610171652343"></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CTNode</span> <span class="token punctuation">{</span>  <span class="token comment">// 孩子结点结构     int child;     struct CTNode *next;   } *ChildPtr;typedef struct {  // 双亲结点结构     Elem data;     int parent;   // 双亲位置域     ChildPtr firstchild; // 孩子链的头指针   } CTBox;typedef struct {  // 树结构     CTBox nodes[MAX_TREE_SIZE];     int n, r;        // 结点数和根结点的位置   } CTree;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<table>
<thead>
<tr>
<th>child</th>
<th>next</th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th>data</th>
<th>parent</th>
<th>firstchild</th>
</tr>
</thead>
</table>
<h3 id="7-7-3-孩子兄弟表示法"><a href="#7-7-3-孩子兄弟表示法" class="headerlink" title="7.7.3 孩子兄弟表示法"></a>7.7.3 孩子兄弟表示法</h3><p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610172017684.png" alt="image-20210610172017684"></p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610172043471.png" alt="image-20210610172043471"></p>
<p><strong>左链为孩子，右链为兄弟</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CSNode</span><span class="token punctuation">{</span>     Elem     data<span class="token punctuation">;</span>     <span class="token keyword">struct</span>   <span class="token class-name">CSNode</span>  <span class="token operator">*</span>firstchild<span class="token punctuation">,</span> <span class="token operator">*</span>nextsibling<span class="token punctuation">;</span><span class="token punctuation">}</span> CSNode<span class="token punctuation">,</span> <span class="token operator">*</span>CSTree<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<table>
<thead>
<tr>
<th>firstchild</th>
<th>data</th>
<th>nextsibling</th>
</tr>
</thead>
</table>
<p>树的各种操作均可由对应的二叉树的操作来完成。<br>和树对应的二叉树，其左、右子树的概念已改变为：<br><strong>左是孩子，右是兄弟。</strong></p>
<h3 id="7-7-4-森林和二叉树的对应关系"><a href="#7-7-4-森林和二叉树的对应关系" class="headerlink" title="7.7.4 森林和二叉树的对应关系"></a>7.7.4 森林和二叉树的对应关系</h3><p>设森林<br>$$<br>F=(T_1,T_2,…T_N); \<br>T1=(root,t_11,t_12,…,t_1m);<br>$$<br>二叉树<br>$$<br>B=(LBT,Node(root),RBT);<br>$$</p>
<h3 id="7-7-5-森林转换成二叉树的转换规则："><a href="#7-7-5-森林转换成二叉树的转换规则：" class="headerlink" title="7.7.5 森林转换成二叉树的转换规则："></a>7.7.5 森林转换成二叉树的转换规则：</h3><p>若 $F=\phi$，则$B=\phi$;</p>
<p>否则，</p>
<p>由$ROOT(T_1)$对应得到$Node(root)$;</p>
<p>由$ (t_11,t_12,..,t_1m)$对应得到$LBT$;</p>
<p>由$(T_2,T_3,…T_n)$对应得到$RBT$。</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610181159594.png" alt="image-20210610181159594"></p>
<h3 id="7-7-6-由二叉树转换为森林的转换规则"><a href="#7-7-6-由二叉树转换为森林的转换规则" class="headerlink" title="7.7.6 由二叉树转换为森林的转换规则"></a>7.7.6 由二叉树转换为森林的转换规则</h3><p>若$B=\phi$，则$F=\phi$;</p>
<p>否则，</p>
<p>由$Node(root)$对应得到$ROOT(T_1)$;</p>
<p>由$LBT$对应得到$(t_11,t_12,…,t_1m)$;</p>
<p>由$RBT$对应得到$(T_2,T_3,…,T_n)$</p>
<h3 id="7-7-7-例题"><a href="#7-7-7-例题" class="headerlink" title="7.7.7 例题"></a>7.7.7 例题</h3><ol>
<li>把森林转换成用孩子兄弟法表示的二叉树</li>
</ol>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610181557534.png" alt="image-20210610181557534"></p>
<p>转换后：</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610181615760.png" alt="image-20210610181615760"></p>
<ol start="2">
<li>把用孩子兄弟链表表示的二叉树转换成相应的森林</li>
</ol>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610181717805.png" alt="image-20210610181717805"></p>
<ol start="3">
<li>把森林转换成用孩子兄弟链表表示的二叉树</li>
</ol>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610181745957.png" alt="image-20210610181745957"></p>
<h2 id="7-8-树和森林的遍历"><a href="#7-8-树和森林的遍历" class="headerlink" title="7.8 树和森林的遍历"></a>7.8 树和森林的遍历</h2><ol>
<li><p>先根（次序）遍历：</p>
<p>若树不空，则先访问根结点，然后依次先根遍历各棵子树</p>
</li>
<li><p>后根（次序）遍历：</p>
<p>若树不空，则依次后根遍历各棵子树，然后访问根结点</p>
</li>
<li><p>按层次遍历</p>
<p>若树不空，则自上而下自左至右访问树中的每个结点</p>
</li>
</ol>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610193708788.png" alt="image-20210610193708788"></p>
<p>先根遍历时顶点的访问次序：</p>
<p>A B E F C D G H I J K</p>
<p>后根遍历时顶点的访问次序：</p>
<p>E F B C I J K H G D A</p>
<p>层次遍历时顶点的访问次序：</p>
<p>A B C D E F G H I J K </p>
<h3 id="7-8-1-森林的遍历"><a href="#7-8-1-森林的遍历" class="headerlink" title="7.8.1 森林的遍历"></a>7.8.1 森林的遍历</h3><p>森林有三部分构成：</p>
<ol>
<li>森林中第一棵树的根结点</li>
<li>森林中第一颗树的子树森林</li>
<li>森林中其它树构成的森林</li>
</ol>
<h4 id="7-8-1-1-森林的先序遍历"><a href="#7-8-1-1-森林的先序遍历" class="headerlink" title="7.8.1.1 森林的先序遍历"></a>7.8.1.1 森林的先序遍历</h4><p>若森林不为空，则</p>
<p>访问森林中第一棵树的根结点</p>
<p>先序遍历森林中第一棵树的子树森林</p>
<p>先序遍历森林中（除第一棵树之外）其余树构成的森林。</p>
<p><strong>依次从左至右对森林中的每一棵树进行先根遍历。</strong></p>
<h4 id="7-8-1-2-森林的中序遍历"><a href="#7-8-1-2-森林的中序遍历" class="headerlink" title="7.8.1.2 森林的中序遍历"></a>7.8.1.2 森林的中序遍历</h4><p>若森林不空，则</p>
<p>中序遍历森林中第一棵树的子树森林</p>
<p>访问森林中第一棵树的根结点</p>
<p>中序遍历森林中（除第一棵树之外）其余树构成的森林。</p>
<p><strong>依次从左至右对森林中的每一棵树进行后根遍历。</strong></p>
<h4 id="7-8-1-3-树的遍历、森林的遍历和二叉树遍历的对应关系"><a href="#7-8-1-3-树的遍历、森林的遍历和二叉树遍历的对应关系" class="headerlink" title="7.8.1.3 树的遍历、森林的遍历和二叉树遍历的对应关系"></a>7.8.1.3 树的遍历、森林的遍历和二叉树遍历的对应关系</h4><table>
<thead>
<tr>
<th>森林</th>
<th>树</th>
<th>二叉树</th>
</tr>
</thead>
<tbody><tr>
<td>先序遍历</td>
<td>先根遍历</td>
<td>先序遍历</td>
</tr>
<tr>
<td>中序遍历</td>
<td>后根遍历</td>
<td>中序遍历</td>
</tr>
</tbody></table>
<h3 id="7-8-2-例题"><a href="#7-8-2-例题" class="headerlink" title="7.8.2 例题"></a>7.8.2 例题</h3><ol>
<li>求森林的先序和中序遍历</li>
</ol>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610194559800.png" alt="image-20210610194559800"></p>
<p>先序：ACEMFNGDHIB</p>
<p>中序：MFNECAHDIBG</p>
<ol start="2">
<li>求树的先根和后根遍历序列</li>
</ol>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610194711938.png" alt="image-20210610194711938"></p>
<p>先根：GCEMDHFNIB</p>
<p>后根：MECFHNDIBG</p>
<h2 id="7-9-树和森林的算法"><a href="#7-9-树和森林的算法" class="headerlink" title="7.9 树和森林的算法"></a>7.9 树和森林的算法</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CSNode</span><span class="token punctuation">{</span>    Elem data<span class="token punctuation">;</span>    strcut CSNode <span class="token operator">*</span>firstchild<span class="token punctuation">,</span><span class="token operator">*</span>nextsibling<span class="token punctuation">;</span><span class="token punctuation">}</span>CSNode<span class="token punctuation">,</span><span class="token operator">*</span>CSTree<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="7-9-1-建立树的存储结构"><a href="#7-9-1-建立树的存储结构" class="headerlink" title="7.9.1 建立树的存储结构"></a>7.9.1 建立树的存储结构</h3><p>假设以二元组$(F，C) $的形式自上而下、自左而右<br>依次输入树的各边，建立树的孩子-兄弟链表。</p>
<table>
<thead>
<tr>
<th>“#”</th>
<th>“A”</th>
</tr>
</thead>
<tbody><tr>
<td>“A”</td>
<td>“B”</td>
</tr>
<tr>
<td>“A”</td>
<td>“C”</td>
</tr>
<tr>
<td>“A”</td>
<td>“D”</td>
</tr>
<tr>
<td>“C”</td>
<td>“E”</td>
</tr>
<tr>
<td>“C”</td>
<td>“F”</td>
</tr>
<tr>
<td>“F”</td>
<td>“G”</td>
</tr>
</tbody></table>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610194936114.png"></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">void CreatTree(CSTree &amp;T){    T=NULL;   for(scanf(&amp;fa,&amp;ch);ch!='';scanf(&amp;fa,&amp;ch)){        p=GetTreeNode(ch);//创建结点        EnQueue(Q,p);//指针入队列        if(fa=='#')T=p;        else{            GetHead(Q,s);//取队列头元素（指针值）            while(s-&gt;data!=fa){//查询双亲结点                DeQueue(Q,s);                GetHead(Q,s);            }            if(!(s-&gt;firstchils)){                s-&gt;firstchild=p;                r=p;            }            else{                r-&gt;nextsibling=p; //链接第一个孩子结点                r=p;//链接其他孩子结点            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="7-9-2-求树的深度"><a href="#7-9-2-求树的深度" class="headerlink" title="7.9.2 求树的深度"></a>7.9.2 求树的深度</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">TreeDepth</span><span class="token punctuation">(</span>CSTree T<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>T<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">else</span><span class="token punctuation">{</span>        h1<span class="token operator">=</span><span class="token function">TreeDepth</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>firstchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        h2<span class="token operator">=</span><span class="token function">TreeDepth</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>nextsibling<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span>h1<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>h2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//TreeDepth</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="7-9-3-求树中的叶子结点树"><a href="#7-9-3-求树中的叶子结点树" class="headerlink" title="7.9.3 求树中的叶子结点树"></a>7.9.3 求树中的叶子结点树</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">CountLeaf</span><span class="token punctuation">(</span>CSNode T<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>count<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>T<span class="token operator">-&gt;</span>fch<span class="token punctuation">)</span>count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">CountLeaf</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>fch<span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">CountLeaf</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>nsib<span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment">//if}//CountLeaf</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="7-9-4-输出树中所有从根到叶子的路径"><a href="#7-9-4-输出树中所有从根到叶子的路径" class="headerlink" title="7.9.4 输出树中所有从根到叶子的路径"></a>7.9.4 输出树中所有从根到叶子的路径</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">OutPath</span><span class="token punctuation">(</span>Bitree T<span class="token punctuation">,</span>Stack <span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//输出森林中所有从根到叶的路径    while(T){        Push(S,T-&gt;data);        else OutPath(T-&gt;firstchild,s);        Pop(S);        T=T-&gt;nextsibling;    }//while}OutPath</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="7-10-赫夫曼树"><a href="#7-10-赫夫曼树" class="headerlink" title="7.10 赫夫曼树"></a>7.10 赫夫曼树</h2><ul>
<li><p>路径长度：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径，路径上分支的数目称作路径长度。</p>
</li>
<li><p>结点的路径长度：从根结点到该结点的路径上分支的数目。</p>
</li>
<li><p>树的路径长度：树中每个结点的路径长度之和。</p>
</li>
<li><p>树的带权路径长度：树中所有叶子结点的带权路径长度之和<br>$$<br>WPL(T)=\Sigma w_kl_k(所有叶子结点)<br>$$</p>
</li>
<li><p><strong>最优二叉树（或赫夫曼树）</strong>:假设有n个权值${w_1,w_2,…w_n}$,试构造一棵有n个叶子结点的二叉树，每个叶子结点的权值为$w_i$，其中带权路径长度$WPL$最小的二叉树称作最优二叉树（或赫夫曼树）。</p>
</li>
</ul>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610201122175.png" alt="image-20210610201122175"><br>$$<br>WPL(T)= 7\times2+5\times2+2\times3+4\times3+9\times2=60<br>$$<br><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610201248413.png" alt="image-20210610201248413"><br>$$<br>WPL(T)=7\times4+9\times4+5\times3+4\times2+2\times1=89<br>$$</p>
<h3 id="7-10-1-赫夫曼树的特点"><a href="#7-10-1-赫夫曼树的特点" class="headerlink" title="7.10.1 赫夫曼树的特点"></a>7.10.1 赫夫曼树的特点</h3><ol>
<li>赫夫曼树没有度为1的结点</li>
<li>赫夫曼树中结点总数$n$为$2n_0-1$</li>
</ol>
<p>证明：<br>$$<br>n=n_0+n_1+n_2=2n_0-1<br>$$</p>
<h3 id="7-10-2-例题"><a href="#7-10-2-例题" class="headerlink" title="7.10.2 例题"></a>7.10.2 例题</h3><ol>
<li>试证明具有$n_0$个叶子结点的哈夫曼树的分支总数为$2(n_0-1)$。</li>
</ol>
<p>证明：<br>$$<br>由于哈夫曼树是一个二叉树，\而叶子结点树为n_0,</p>
<p>\由二叉树的性质3可知度为2的结点树为n_0-1。</p>
<p>\哈夫曼树的分支都输度=2的结点发出的，\所以哈夫曼树的分支总数为2(n_0-1)<br>$$</p>
<h3 id="7-10-3-哈夫曼树的构造"><a href="#7-10-3-哈夫曼树的构造" class="headerlink" title="7.10.3 哈夫曼树的构造"></a>7.10.3 哈夫曼树的构造</h3><p>以二叉树为例：<br>（1）根据给定的 n 个权值 {w1, w2, …, wn}，构造 n 棵二叉树的集合<br>       F = {T1,   T2,  … , Tn}，<br>     其中每棵二叉树中均只含一个带权值为 wi 的根结点，其左、右子树<br>     为空树；<br>（2）在 F 中选取其根结点的权值为最小的两棵二叉树，分别作为左、<br>     右子树构造一棵新的二叉树，并置这棵新的二叉树根结点的权值<br>     为其左、右子树根结点的权值之和；</p>
<p>（3）从F 中删去这两棵树，同时加入刚生成的新树；<br>（4）重复 (2) 和 (3) 两步，直至 F 中只含一棵树为止。</p>
<h3 id="7-10-4-例题"><a href="#7-10-4-例题" class="headerlink" title="7.10.4 例题"></a>7.10.4 例题</h3><ol>
<li>用于通信的电文由字符集{a, b, c, d, e, f, g, h}中的字符构成，这8个字母在电文中出现的概率分别为{0.07, 0.19, 0.02, 0.06, 0.32, 0.03, 0.21, 0.10}，为这8个字母设计哈夫曼编码。</li>
</ol>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610202209123.png" alt="image-20210610202209123"></p>
<h1 id="8-图"><a href="#8-图" class="headerlink" title="8.图"></a>8.图</h1><h2 id="8-1-图的逻辑结构"><a href="#8-1-图的逻辑结构" class="headerlink" title="8.1 图的逻辑结构"></a>8.1 图的逻辑结构</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//图的抽象数据类型 ADT Graph{//图是由一个顶点集V和一个弧集R构成的数据结构     数据对象V：V是具有相同特性的数据元素的集合，称为顶点集;     数据关系R：R={VR}     VR={&lt;v,w&gt;|v,w∈V且p(v,w),&lt;v,w&gt;表示从v到w的弧，谓词P(v,w)定义了&lt;v,w&gt;的意义或信息;         (在弧&lt;v,w&gt;中，称v为弧尾，w为弧头。) }   </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210611225355117.png" alt="image-20210611225355117"></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//基本操作CreateGraph(&amp;G,V,VR);//按定义(V,VR)构造图DestroyGraph(&amp;G);//销毁图LocateVex(G,u); //若G中存在顶点u,则返回该顶点在图中的位置，否则返回其他信息Getvex(G,v);//返回v的值PutVex(&amp;G,v,value);//对v赋值valueFirstAdiVex(G,v);//返回v的“第一个邻接点”，若该顶点在G中没有邻接点，则返回“空”NextAdjVex(G,v,w);//返回v的（相对于w的）“下一个邻接 点”InsertVex(&amp;G,v);//在图G中添加新顶点VDeleteVex(&amp;G,v);//删除G中顶点v及其相关的弧InsertArc(&amp;G,v,w);//在G中添加弧&lt;v,w&gt;，若G是无向的，则还增添对称弧&lt;w,v&gt;DeleteArc(&amp;G,v,w);//在G中删除弧&lt;v,w&gt;，若G是无向的，则还删除对称弧&lt;w,v&gt;DFSTraverse(G,v,Visit());//从顶点v起深度优先遍历图G，并对每个顶点调用函数Visit一次且仅一次BFSTraverse(G,v,Visit());//从顶点v起广度优先遍历图G，并对每个顶点调用函数Visit一次且仅一次</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="8-2-图的基本术语"><a href="#8-2-图的基本术语" class="headerlink" title="8.2. 图的基本术语"></a>8.2. 图的基本术语</h3><h3 id="8-2-1-有向图"><a href="#8-2-1-有向图" class="headerlink" title="8.2.1 有向图"></a>8.2.1 有向图</h3><p>由于“弧”是有方向的，因此称由顶点集和弧集构成的图为<strong>有向图</strong></p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210611231942411.png" alt="image-20210611231942411"></p>
<h3 id="8-2-2-无向图"><a href="#8-2-2-无向图" class="headerlink" title="8.2.2 无向图"></a>8.2.2 无向图</h3><p>若$$&lt;v, w&gt;\in VR$$ 必有$$&lt;w, v&gt;\in VR$$, 则称$$ (v,w)$$ 为顶点$$v$$ 和顶点$$ w $$之间存在一条边，由顶点集和边集构成的图称作无向图。</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210611232230580.png" alt="image-20210611232230580"></p>
<h3 id="8-2-3-网"><a href="#8-2-3-网" class="headerlink" title="8.2.3 网"></a>8.2.3 网</h3><p>弧或边带权的图分别称作有向网或无向网。</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210611232333784.png" alt="image-20210611232333784"></p>
<h3 id="8-2-4-子图"><a href="#8-2-4-子图" class="headerlink" title="8.2.4 子图"></a>8.2.4 子图</h3><p>设图$$G=(V,{VR})$$ 和图 $$G’=(V’,{VR’})$$，且 $$VV$$, $$VR’ \subseteq VR’$$，<br>则称 $$G’$$ 为$$ G$$ 的子图。</p>
<h3 id="8-2-5-完全图、稀疏图和稠密图"><a href="#8-2-5-完全图、稀疏图和稠密图" class="headerlink" title="8.2.5 完全图、稀疏图和稠密图"></a>8.2.5 完全图、稀疏图和稠密图</h3><p>假设图中有$$ n $$个顶点，$$e$$ 条边，则<br>含有 $$e=n(n-1)/2 $$条边的无向图称作无向完全图；<br>含有 $$e=n(n-1)$$ 条弧的有向图称作 有向完全图；<br>若边或弧的个数 $$e&lt;nlogn$$，则称作稀疏图，否则称作稠密图。</p>
<h3 id="8-2-6-无向图的邻接点、关联和度"><a href="#8-2-6-无向图的邻接点、关联和度" class="headerlink" title="8.2.6 无向图的邻接点、关联和度"></a>8.2.6 无向图的邻接点、关联和度</h3><p>假若顶点v 和顶点w 之间存在一条边，则称顶点v 和w 互为邻接点，<br>边(v,w) 和顶点v 和w 相关联。<br>和顶点v 关联的边的数目定义为边的度。</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210611232828068.png" alt="image-20210611232828068"></p>
<p>例如：</p>
<p>ID(B)=3</p>
<p>ID(A)=2</p>
<h3 id="8-2-7-有向图的邻接点、关联和度"><a href="#8-2-7-有向图的邻接点、关联和度" class="headerlink" title="8.2.7 有向图的邻接点、关联和度"></a>8.2.7 有向图的邻接点、关联和度</h3><p>假若顶点$$v$$ 和顶点$$w $$之间存在一条弧，则称顶点$$v$$ 和$$w$$ 互为邻接点，<br>弧$$&lt;v,w&gt;$$和顶点$$v$$ 和$$w$$ 相关联。<br>顶点的出度: 以顶点$$v$$为弧尾的弧的数目。<br>顶点的入度: 以顶点$$v$$为弧头的弧的数目。<br>$$顶点的度(TD)=出度(OD)+入度(ID)$$</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210611233050608.png" alt="image-20210611233050608"></p>
<p>例如：</p>
<p>OD(B)=1</p>
<p>ID(B)=2</p>
<p>TD(B)=3</p>
<h3 id="8-2-8-路径、路径长度、简单路径、简单回路"><a href="#8-2-8-路径、路径长度、简单路径、简单回路" class="headerlink" title="8.2.8 路径、路径长度、简单路径、简单回路"></a>8.2.8 路径、路径长度、简单路径、简单回路</h3><p>设图$$G=(V,{VR})$$中的一个顶点序列$${ u=vi,0,vi,1, …, vi,m=w}$$中，<br>$$(vi,j-1,vi,j)\in VR ，1≤j≤m$$，则称从顶点$$u$$ 到顶点$$w$$ 之间存在一条路径。<br>路径上<strong>边的数目</strong>称作<strong>路径长度</strong>。<br>如:长度为3的路径$${A,B,C,F}$$<br><strong>简单路径:</strong><br>序列中顶点不重复出现的路径。<br><strong>简单回路:</strong><br>序列中第一个顶点和最后一个顶点相同的简单路径。</p>
<h3 id="8-2-9-连通图、连通分量-无向图"><a href="#8-2-9-连通图、连通分量-无向图" class="headerlink" title="8.2.9 连通图、连通分量(无向图)"></a>8.2.9 连通图、连通分量(无向图)</h3><p>若无向图G中任意两个顶点之间都有路径想通，则称此图为<strong>连通图；</strong></p>
<p>若无向图为非连通图，则图中<strong>各个极大联通子图</strong>称作此图的<strong>联通分量。</strong></p>
<h3 id="8-2-10-强联通图、强联通分量（有向图）"><a href="#8-2-10-强联通图、强联通分量（有向图）" class="headerlink" title="8.2.10 强联通图、强联通分量（有向图）"></a>8.2.10 强联通图、强联通分量（有向图）</h3><p>对于有向图，若任意两个顶点之间都存在一条有向路径，则称此有向图为强连通图。否则，其各个强连通子图称作它的强连通分量。</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210611233850895.png" alt="image-20210611233850895"></p>
<h3 id="8-2-11-生成树和生成森林"><a href="#8-2-11-生成树和生成森林" class="headerlink" title="8.2.11 生成树和生成森林"></a>8.2.11 生成树和生成森林</h3><ul>
<li>假设一个连通图有 $$n$$ 个顶点和 $$e$$ 条边，其中 $$n-1$$ 条边和 $$n $$个顶点构成一个<strong>极小连通子图</strong>，称该极小连通子图为此连通图的<strong>生成树</strong>。</li>
<li>对非连通图，则称由各个连通分量的生成树的集合为此非连通图的<strong>生成森林</strong>。</li>
</ul>
<h2 id="8-3-图的存储表示"><a href="#8-3-图的存储表示" class="headerlink" title="8.3 图的存储表示"></a>8.3 图的存储表示</h2><p>内容：介绍图的邻接矩阵和邻接表的存储表示。</p>
<h3 id="8-3-1-图的数组（邻接矩阵）存储表示"><a href="#8-3-1-图的数组（邻接矩阵）存储表示" class="headerlink" title="8.3.1 图的数组（邻接矩阵）存储表示"></a>8.3.1 图的数组（邻接矩阵）存储表示</h3><p>$$<br>A_{ij}=\begin{cases}<br>0,(i,j)\notin VR\<br>1,(i,j)\in VR<br>\end{cases}<br>$$</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210611235744769.png" alt="image-20210611235744769"></p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>B</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>C</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>D</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>E</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>F</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<ul>
<li>有向图的邻接矩阵不一定为对称矩阵</li>
</ul>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210612000618321.png" alt="image-20210612000618321"></p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>E</th>
<th>F</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>B</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>C</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>E</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>F</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<h3 id="8-3-2-图的邻接表存储表示"><a href="#8-3-2-图的邻接表存储表示" class="headerlink" title="8.3.2 图的邻接表存储表示"></a>8.3.2 图的邻接表存储表示</h3><h4 id="8-3-2-1无向图的邻接表存储表示"><a href="#8-3-2-1无向图的邻接表存储表示" class="headerlink" title="8.3.2.1无向图的邻接表存储表示"></a>8.3.2.1无向图的邻接表存储表示</h4><p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210612000958409.png" alt="image-20210612000958409"></p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210612001023443.png" alt="image-20210612001023443"></p>
<h4 id="8-3-2-2有向图的邻接表存储表示"><a href="#8-3-2-2有向图的邻接表存储表示" class="headerlink" title="8.3.2.2有向图的邻接表存储表示"></a>8.3.2.2有向图的邻接表存储表示</h4><p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210612001219189.png" alt="image-20210612001219189"></p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210612001233345.png" alt="image-20210612001233345"></p>
<h4 id="8-3-2-3-有向图的逆邻接表存储表示"><a href="#8-3-2-3-有向图的逆邻接表存储表示" class="headerlink" title="8.3.2.3 有向图的逆邻接表存储表示"></a>8.3.2.3 有向图的逆邻接表存储表示</h4><p>在有向图的逆邻接表中，对每个顶点，链接的<strong>是指向该顶点</strong>的弧。</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210612001557896.png" alt="image-20210612001557896"></p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210612001633406.png" alt="image-20210612001633406"></p>
<h4 id="8-3-2-4-图的邻接表存储结构定义"><a href="#8-3-2-4-图的邻接表存储结构定义" class="headerlink" title="8.3.2.4 图的邻接表存储结构定义"></a>8.3.2.4 图的邻接表存储结构定义</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ArcNode</span><span class="token punctuation">{</span>  <span class="token comment">//弧结点（或边结点）的结构    int adjvex; //该弧所指向的顶点的位置    struct ArcNode *nextarc; //指向下一条弧的指针    infoType *info;//该弧相关信息的指针}ArcNode;typedef struct VNode{//顶点结点的结构    VertexType data;//顶点信息    ArcNode *firstarc;//指向第一条依附该顶点的弧}VNode,AdjList[MAX_VERTEX_NUM];typedef struct{//图整体结构的定义    AdjList vertices;    int vexnum,arcnum;  //顶点数，边数    int kind;//图的种类标志}ALGraph;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210612002637147.png" alt="image-20210612002637147"></p>
<h3 id="8-3-3-例题"><a href="#8-3-3-例题" class="headerlink" title="8.3.3 例题"></a>8.3.3 例题</h3><ol>
<li>如果无向图中有n个顶点和e条边，那么它的邻接表中有 <strong>2e</strong> 个边结点。</li>
<li>在一个有向图的邻接表中，如果某个顶点结点指向第一条弧的指针为空，则该顶点的度一定为零(<strong>x</strong>) (没有出度但是有可能有入度)</li>
<li>无向图的邻接矩阵一定是对称矩阵，有向图的邻接矩阵一定是非对称矩阵（<strong>x</strong>)   （强连通图的邻接矩阵是对称矩阵）</li>
<li>有向完全图中有n个顶点，那么它的逆邻接表中有n(n-1)个弧结点。</li>
<li>具有n个顶点和e条弧的有向图用邻接表存储表示时，需要n个头结点和e个弧结点（<strong>√</strong>）</li>
<li>画出有向图的逆邻接表，并写出入度最大的顶点和出度最大的顶点。</li>
</ol>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210612004425954.png" alt="image-20210612004425954"></p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210612004431677.png" alt="image-20210612004431677"></p>
<p>入度最大的顶点是A,出度最大的顶点是C 。</p>
<h2 id="8-4图的遍历"><a href="#8-4图的遍历" class="headerlink" title="8.4图的遍历"></a>8.4图的遍历</h2><p>内容：介绍图的<strong>深度优先搜索遍历</strong>和<strong>广度优先搜索遍历</strong>。</p>
<p>从图中某个顶点出发游历图，访遍图中其余顶点，并且使图中的每个顶点仅被访问一次的过程。</p>
<h3 id="8-4-1-图的深度优先搜索遍历"><a href="#8-4-1-图的深度优先搜索遍历" class="headerlink" title="8.4.1 图的深度优先搜索遍历"></a>8.4.1 图的深度优先搜索遍历</h3><p>从图中某个顶点$V_0$ 出发，访问此顶点，然后依次从$V_0$的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和$V_0$有路径相通的顶点都被访问到。</p>
<ol>
<li>深度优先搜索遍历连通图的过程类似于树的<strong>先根遍历</strong></li>
<li>如果判别V的邻接点是否被访问？</li>
</ol>
<p>解决办法是：为每个顶点设立一个“访问标志 $visited[w]$”</p>
<ol start="3">
<li>非连通图如何进行深度优先搜索遍历？</li>
</ol>
<p>非连通图的所有顶点全部放在一个结构里，依次对所有未被访问的顶点进行遍历</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">,</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//从顶点v出发，深度优先搜索遍历连通图G	visited[v]=TRUE;    VisitFunc(v);//访问第v个顶点    for(w=FirsrAdjVex(G,v));w!=0;w=NextAdjVex(G,v,w))    if(!visited[w])DFS(G,w);//对v的尚未访问的邻接顶点w递归调用DFS}void DFSTraverse(Graph G,Status(*Visit)(int v)){    VisitFunc=Visit;    for(v=0;v&lt;G.vexnum;++v)visited[v]=FALSE;//访问标志数组初始化    for(v=0;v&lt;G.vexnum;++v)if(!visited[v])DFS(G,v);}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="8-4-2-图的广度优先搜索遍历"><a href="#8-4-2-图的广度优先搜索遍历" class="headerlink" title="8.4.2 图的广度优先搜索遍历"></a>8.4.2 图的广度优先搜索遍历</h3><p>从图中的某个顶点$$V_0$$出发，并在访问此顶点之后依次访问$$V_0$$的所有未被访问过的邻接点，之后按这些顶点被访问的先后次序依次访问它们的邻接点，直至图中所有和$V_0$有路径相通的顶点都被访问到。<br>若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">VFSTravserse</span><span class="token punctuation">(</span>Graph G<span class="token punctuation">,</span><span class="token function">Status</span> <span class="token punctuation">(</span><span class="token operator">*</span>Visit<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>v<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>v<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span><span class="token operator">++</span>v<span class="token punctuation">)</span>        visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">=</span>FALSE<span class="token punctuation">;</span><span class="token comment">//初始化访问标志    InitQueue(Q);    for(v=0;v&lt;G.vexnum;++v)        if(!visited[v]){//v尚未访问            visited[v]=TRUE;            Visit(v);//访问v            EnQueue(Q,v);            while(!QueueEmpty(Q)){                DeQueue(Q,u);//队头元素出队并置为u                for(w=FirstAdjVex(G,u);w!=0;w=NextAdjVex(G,u,w))                    if(!visited[w]){                        visited[w]=TRUE;                        Visit(w);                        EnQueue(Q,w);//访问顶点w入队列                    }            }        }}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="8-4-3-例题"><a href="#8-4-3-例题" class="headerlink" title="8.4.3 例题"></a>8.4.3 例题</h3><ol>
<li>广度优先搜索遍历(从顶点V出发）广度优先搜索遍历序列</li>
</ol>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210612132506903.png" alt="image-20210612132506903"></p>
<p>$w_1 w_2 w_8 w_7 w_3 w_5 w_6 w_4$</p>
<ol start="2">
<li><p>图的广度优先搜索类似于二叉树的（D）遍历</p>
<p>​    A. 先根     B. 中根   C. 后根    D. 层次</p>
</li>
<li><p>从顶点A出发，写出它的深度优先搜索遍历序列(搜索邻接点时ASCII码值小的顶点优先)</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210612132942524.png" alt="image-20210612132942524"></p>
<p>$ACDFEBG$</p>
</li>
<li><p>深度优先遍历图和广度优先遍历图分别采用<strong>栈和队列</strong>来暂存结点。</p>
</li>
<li><p>已知有向图$G=(V，E)$，其中$V={v_1，v_2，v_3，v_4，v_5，v_6，v_7}，E={&lt;v_1，v_2&gt;，&lt;v_1，v_3&gt;，&lt;v_1，v_4&gt;，&lt;v_2，v_5&gt;，&lt;v_3，v_5&gt;，&lt;v_3，v_6&gt;，&lt;v_3，v_7&gt;，&lt;v_4，v_6&gt;，&lt;v_5，v_7&gt;，&lt;v_6，v_7&gt;}$，对$G$从$v_1$进行$DFS$，若下标小的邻接点优先遍历，则得到的序列是</p>
<p>​            1 2 5 7 3 6 4</p>
</li>
</ol>
<h3 id="8-4-4-图的遍历算法的应用"><a href="#8-4-4-图的遍历算法的应用" class="headerlink" title="8.4.4. 图的遍历算法的应用"></a>8.4.4. 图的遍历算法的应用</h3><h4 id="8-4-4-1-求两个顶点之间的简单路径"><a href="#8-4-4-1-求两个顶点之间的简单路径" class="headerlink" title="8.4.4.1 求两个顶点之间的简单路径"></a>8.4.4.1 求两个顶点之间的简单路径</h4><p>求从顶点 b 到顶点 k 的一条简单路径，从顶点 b 出发进行深度优先搜索遍历。</p>
<p>假设找到的第一个邻接点是c，则得到的结点访问序列为:     $b c h d a e k f g$</p>
<p>假设找到的第一个邻接点是a，则得到的结点访问序列为：</p>
<p>$b a d h c e k f g $</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210612134048699.png" alt="image-20210612134048699"></p>
<p>结论</p>
<ol>
<li><p>从顶点 i 到顶点 s ,若存在路径，则从顶点 i 出发进行深度优先搜索，必能搜索到顶点 s 。</p>
</li>
<li><p>遍历过程中搜索到的顶点不一定是路径上的顶点。</p>
</li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">DFSearch</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">,</span><span class="token keyword">int</span> s<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span>PATH<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//从第v个顶点出发递归地深度优先遍历图G    //求得一条从v到s的简单路径，并记录在PATH中    visited[v]=TRUE;//访问第v个顶点    Append(PATH,getVertex(v));//第v个顶点加入路径    for(w=FirstAdjVex(v);w!=0&amp;&amp;!found;w=NextAdjVex(v))        if(w=s){            found=TRUE;            Append(PATH,w);        }        else if(!visited[w])DFSearch(w,s,PATH); if(!found)Delete(PATH);//从路径上删除顶点v}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="8-4-4-2-求两个顶点之间的路径长度最短的路径"><a href="#8-4-4-2-求两个顶点之间的路径长度最短的路径" class="headerlink" title="8.4.4.2 求两个顶点之间的路径长度最短的路径"></a>8.4.4.2 求两个顶点之间的路径长度最短的路径</h4><p>若两个顶点之间存在多条路径，则其中必有一条路径长度最短的路径。路径长度最短：指的是分支的数目最少，而非距离的绝对数值最小。<br>可以理解为乘坐公交车去某地，换乘次数最少。<br>深度优先搜索访问顶点的次序取决于图的存储结构，而广度优先搜索访问顶点的次序是按“路径长度”渐增的次序。<br>求路径长度最短的路径可以<strong>基于广度优先搜索遍历进行</strong>，但需要修改链队列的结点结构及其入队列和出队列的算法。</p>
<ol>
<li>将链队列的结点改为“双链”结点。即结点中包含next 和prior两个指针；</li>
<li>修改入队列的操作。插入新的队尾结点时，令其prior域的指针指向刚刚出队列的结点，即当前的队头指针所指结点；</li>
<li>修改出队列的操作。出队列时，仅移动队头指针，而不将队头结点从链表中删除。</li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> DuLinKListQueuePtr<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">InitQueue</span><span class="token punctuation">(</span>LinkQueue<span class="token operator">&amp;</span> Q<span class="token punctuation">)</span><span class="token punctuation">{</span>    Q<span class="token punctuation">.</span>front<span class="token operator">=</span>Q<span class="token punctuation">.</span>rear<span class="token operator">=</span><span class="token punctuation">(</span>QueuePtr<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>QNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Q<span class="token punctuation">.</span>front<span class="token operator">-&gt;</span>next<span class="token operator">=</span>Q<span class="token punctuation">.</span>rear<span class="token operator">-&gt;</span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">EnQueue</span><span class="token punctuation">(</span>LinkQueue<span class="token operator">&amp;</span> Q<span class="token punctuation">,</span>QelemType e<span class="token punctuation">)</span><span class="token punctuation">{</span>    p<span class="token operator">=</span><span class="token punctuation">(</span>QueuePtr<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>QNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    p<span class="token operator">-&gt;</span>data<span class="token operator">=</span>e<span class="token punctuation">;</span>    p<span class="token operator">-&gt;</span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    p<span class="token operator">-&gt;</span>prior<span class="token operator">=</span>Q<span class="token punctuation">.</span>front<span class="token punctuation">;</span>    Q<span class="token operator">-&gt;</span>rear<span class="token operator">-&gt;</span>next<span class="token operator">=</span>p<span class="token punctuation">;</span>    Q<span class="token punctuation">.</span>rear<span class="token operator">=</span>p<span class="token punctuation">;</span><span class="token punctuation">}</span>voif <span class="token function">DeQueue</span><span class="token punctuation">(</span>LinkQueue <span class="token operator">&amp;</span>Q<span class="token punctuation">,</span>QelemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>    Q<span class="token punctuation">.</span>front<span class="token operator">=</span>Q<span class="token punctuation">.</span>front<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    e<span class="token operator">=</span>Q<span class="token punctuation">.</span>front<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="8-4-4-3-例题"><a href="#8-4-4-3-例题" class="headerlink" title="8.4.4.3 例题"></a>8.4.4.3 例题</h4><ol>
<li><p>坐公交车从A站到B站，中间可能有换乘，如果希望换乘次数最少，可以根据什么算法来设计解决方案。( C )</p>
<p>A．关键路径           B．深度优先搜索<br>C. 广度优先搜索      D．迪杰斯特拉</p>
</li>
<li><p>对有n个顶点、e条边且采用邻接矩阵作为存储结构的无向图进行深度优先搜索遍历的时间复杂度为( B )。</p>
<p>A.O(n)        B.O($n^2$)      C.O(n+e)         D.O(e)</p>
</li>
</ol>
<h2 id="8-5-最小生成树"><a href="#8-5-最小生成树" class="headerlink" title="8.5 最小生成树"></a>8.5 最小生成树</h2><p>问题的提出：<br>假设要在 n 个城市之间建立通讯联络网，则连通 n 个城市只需要修建 n-1条线路，如何在最节省经费的前提下建立这个通讯网？<br>该问题等价于构造(连通网的)最小生成树：<br>构造网的一棵最小生成树，即：在 e 条带权的边中选取 n-1 条边（不构成回路），使“权值之和”为最小。</p>
<h3 id="8-5-1-普利姆算法"><a href="#8-5-1-普利姆算法" class="headerlink" title="8.5.1 普利姆算法"></a>8.5.1 普利姆算法</h3><p>基本思想:<br>取图中任意一个顶点 v 作为生成树的根，之后往生成树上添加新的顶点 w。在添加的顶点 w 和已经在生成树上的顶点v 之间必定存在一条边，并且该边的权值在所有连通顶点 v 和 w 之间的边中取值最小。之后继续往生成树上添加顶点，直至生成树上含有 n-1 条边为止。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span><span class="token punctuation">{</span>    VertexType adgvex<span class="token punctuation">;</span><span class="token comment">//U集中的顶点序号    VRType lowcost;//边的权值}closeedge[MAX_VERTEX_NUM];</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><img src="D:\A大二下\java\课件最新\image-20210612144020057.png" alt="image-20210612144020057"></p>
<table>
<thead>
<tr>
<th></th>
<th>0a</th>
<th>1b</th>
<th>2c</th>
<th>3d</th>
<th>4e</th>
<th>5f</th>
<th>6g</th>
</tr>
</thead>
<tbody><tr>
<td>Adjvex</td>
<td></td>
<td>c</td>
<td>d</td>
<td>e</td>
<td>a</td>
<td>d</td>
<td>e</td>
</tr>
<tr>
<td>Lowcost</td>
<td></td>
<td>5</td>
<td>3</td>
<td>8</td>
<td>14</td>
<td>21</td>
<td>16</td>
</tr>
</tbody></table>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">MiniSpanTree_P</span><span class="token punctuation">(</span>MGraph G<span class="token punctuation">,</span> VertexType u<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">//用普里姆算法从顶点u出发构造网G的最小生成树  k = LocateVex ( G, u );   for ( j=0; j&lt;G.vexnum; ++j )  // 辅助数组初始化      if (j!=k)  closedge[j] = { u, G.arcs[k][j].adj };    closedge[k].lowcost = 0;      // 初始，U＝{u}  for (i=0; i&lt;G.vexnum; ++i) {    k = minimum(closedge);  // 求出加入生成树的下一个顶点(k)    printf(closedge[k].adjvex, G.vexs[k]);   // 输出生成树上一条边    closedge[k].lowcost = 0;    // 第k顶点并入U集    for (j=0; j&lt;G.vexnum; ++j)   //修改其它顶点的最小边      if (G.arcs[k][j].adj &lt; closedge[j].lowcost)        closedge[j] = { G.vexs[k], G.arcs[k][j].adj };   }}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="8-5-3-克鲁斯卡尔算法"><a href="#8-5-3-克鲁斯卡尔算法" class="headerlink" title="8.5.3 克鲁斯卡尔算法"></a>8.5.3 克鲁斯卡尔算法</h3><p>基本思想:<br>考虑问题的出发点: 为使生成树上边的权值之和达到最小，则应使生成树中每一条边的权值尽可能地小。<br>具体做法: 先构造一个只含 $n$ 个顶点的子图$ SG$，然后从权值最小的边开始，若它的添加不使$SG$ 中产生回路，则在 $SG $上加上这条边，如此重复，直至加上 $n-1$ 条边为止。</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210612150941243.png" alt="image-20210612150941243"></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">算法描述：    构造非连通图ST<span class="token operator">=</span>（V<span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>k<span class="token operator">=</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//k计选中的边数while(k&lt;n-1){    ++i;    检查边集E中第i条权值最小的边(u,v);    若(u,v)加入ST后不使ST中产生回路，则输出边(u,v);且k++;}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="8-5-4-两种算法的比较"><a href="#8-5-4-两种算法的比较" class="headerlink" title="8.5.4 两种算法的比较"></a>8.5.4 两种算法的比较</h3><p>n为顶点数，e为边数。</p>
<table>
<thead>
<tr>
<th>算法名</th>
<th>普利姆算法</th>
<th>克鲁斯卡尔算法</th>
</tr>
</thead>
<tbody><tr>
<td>时间复杂度</td>
<td>O($n^2$)</td>
<td>O(eloge)</td>
</tr>
<tr>
<td>适应范围</td>
<td>稠密图</td>
<td>稀疏图</td>
</tr>
</tbody></table>
<h3 id="8-5-5-例题"><a href="#8-5-5-例题" class="headerlink" title="8.5.5 例题"></a>8.5.5 例题</h3><ol>
<li>无向图一定有唯一形态的最小代价生成树（x）</li>
<li>根据普利姆（prim）算法，求它的最小生成树及最小代价（起始点为A）</li>
</ol>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210612151625004.png" alt="image-20210612151625004"></p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210612151707052.png" alt="image-20210612151707052"></p>
<p>最小代价：42。</p>
<ol start="3">
<li>设n为网中顶点数，e为网中边数，构造最小生成树的prim算法和kruskal算法的区别在于（  A）。<br> A．prim算法的时间复杂度为O($n^2$) , 适用于求边稠密的网的最小生成树;<pre><code>   kruskal算法的时间复杂度为O(eloge)，适用于求边稀疏的网的最小生成树。
</code></pre>
 B．prim算法的时间复杂度为O(eloge)，适用于求边稀疏的网的最小生成树;<pre><code>   kruskal算法的时间复杂度为O($n^2$) , 适用于求边稠密的网的最小生成树。
</code></pre>
 C．prim算法的时间复杂度为O($n^2$) , 适用于求边稀疏的网的最小生成树;<pre><code>   kruskal算法的时间复杂度为O(eloge)，适用于求边稠密的网的最小生成树。
</code></pre>
 D．以上都不对</li>
</ol>
<h2 id="8-6-拓扑排序"><a href="#8-6-拓扑排序" class="headerlink" title="8.6 拓扑排序"></a>8.6 拓扑排序</h2><p>1、问题的提出      </p>
<p>​      假设以有向图表示一个工程的施工图或程序的数据流图，则图中不允许出现回路。<br>​       检查<strong>有向图</strong>中是否存在回路的方法之一，是对有向图进行拓扑排序。</p>
<p>2、什么是拓扑排序        </p>
<p>​     按照有向图给出的次序关系，将图中顶点排成一个线性序列，对应有向图中没有限定次序关系的顶点，则可以人为加上任意的次序关系，由此所得顶点的线性序列称之为拓扑有序序列。</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210612152448286.png" alt="image-20210612152448286"></p>
<p>可求得拓扑有序序列：</p>
<p>A B C D 或 A C B D</p>
<p>反之，对于下列有向图不能求得它的拓扑有序序列。<br>因为图中存在一个回路 {B, C, D}</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210612152534631.png" alt="image-20210612152534631"></p>
<p>3、如何进行拓扑排序？</p>
<p>（1）从有向图中选取一个没有前驱的顶点，并输出之；<br>（2）从有向图中删去此顶点以及所有以它为尾的弧；<br>（3）重复上述两步，直至图空；或者图不空但找不到无前驱的顶点为止。</p>
<p>4、 算法描述</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//取入度为零的顶点v;while (v&lt;&gt;0){   printf(v);  ++m;     w:=FirstAdj(v);     while (w&lt;&gt;0) {        inDegree[w]--;        w:=nextAdj(v,w);     }     取下一个入度为零的顶点v;}if m&lt;n  printf(“图中有回路”);//在算法中需要用定量的描述替代定性的概念，没有前驱的顶点 == 入度为零的顶点，删除顶点及以它为尾的弧 ==弧头顶点的入度减1。</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>为避免每次都要搜索入度为零的顶点，在算法中设置一个“栈”，以保存“入度为零”的顶点。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">CountInDegree</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>indegree<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//对各顶点求入度InitStack(S);for ( i=0; i&lt;G.vexnum; ++i)   if (!indegree[i])  Push(S, i); //入度为零的顶点入栈count=0;           //对输出顶点计数while (!EmptyStack(S)) {  Pop(S, v);  ++count;  printf(v);  for (w=FirstAdj(v); w;  w=NextAdj(G,v,w)){     --indegree(w);  // 弧头顶点的入度减一     if (!indegree[w])  Push(S, w);  //新产生的入度为零的顶点入栈  }}if (count&lt;G.vexnum) printf(“图中有回路”)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="8-6-1-例题"><a href="#8-6-1-例题" class="headerlink" title="8.6.1 例题"></a>8.6.1 例题</h3><ol>
<li>已知有向图G=(V，E)，其中V={v1，v2，v3，v4，v5，v6，v7}，E={&lt;v1，v2&gt;，&lt;v1，v3&gt;，&lt;v1，v4&gt;，&lt;v2，v5&gt;，&lt;v3，v5&gt;，&lt;v3，v6&gt;，&lt;v4，v6&gt;，&lt;v5，v7&gt;，&lt;v6，v7&gt;}，G的一个拓扑有序序列是(  A  )。<br>A.v1，v3，v4，v6，v2，v5，v7       B.v1，v3，v2，v6，v4，v5，v7<br>C.v1，v3，v4，v5，v2，v6，v7       D.v1，v2，v5，v3，v4，v6，v7</li>
<li>具有拓扑有序序列的图一定是（A ）。<pre><code>A. 有向无环图     B. 有向完全图     C. 强连通图      D. 有环
</code></pre>
</li>
<li>对AOV网进行拓扑排序得到的拓扑有序序列不一定是唯一的。（ √ ）</li>
<li>对AOV网进行拓扑排序，若当前图中虽有顶点，但不存在无前驱的顶点，则说明此有向图中存在环。（ √ ）</li>
</ol>
<h2 id="8-7-关键路径"><a href="#8-7-关键路径" class="headerlink" title="8.7 关键路径"></a>8.7 关键路径</h2><p>假设以有向网表示一个施工流图，弧上的权值表示完成该项子工程所需时间（AOE网）。问：哪些子工程项是“关键工程”？<br>（即：哪些子工程项将影响整个工程的完成期限?）</p>
<p>1、“整个工程完成的时间”为：从有向图的源点到汇点的最长路径。<br>     （起始时间从0开始)<br>2、“关键活动”指的是：该弧上的权值增加将使有向图上的最长路径的长度增加。<br>3、“事件(顶点)” 的 最早发生时间 $ve(j)$<br>$ve(j) = 从源点到顶点j的最长路径长度；$<br>4、“事件(顶点)” 的 最迟发生时间$ vl(k)$<br>$vl(k) = 从顶点k到汇点的最短路径长度= 汇点发生时间-顶点k到汇点的最长路径路径长度。$</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210612155639736.png" alt="image-20210612155639736"></p>
<h3 id="8-7-1-例题"><a href="#8-7-1-例题" class="headerlink" title="8.7.1 例题"></a>8.7.1 例题</h3><ol>
<li>求关键路径</li>
</ol>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210612155740227.png" alt="image-20210612155740227"></p>
<p>behk</p>
<ol start="2">
<li>关键路径是AOE网络中（B）。<pre><code>A. 从源点到汇点的最短路径        B. 从源点到汇点的最长路径
C. 最长的回路                           D. 最短的回路
</code></pre>
</li>
<li>关于AOE网，下面不正确的说法是 (  A  )。<pre><code>A. 缩短某个关键活动的完成时间，整个工程必然提前完成
B. 关键路径是从源点到汇点的最长路径
C. 可能有多条关键路径
D. 如果缩短关键活动的完成时间，则可能需要重新规划关键路径
</code></pre>
</li>
</ol>
<h2 id="8-6-最短路径"><a href="#8-6-最短路径" class="headerlink" title="8.6 最短路径"></a>8.6 最短路径</h2><h3 id="8-6-1从某个源点到其余各的最短路径"><a href="#8-6-1从某个源点到其余各的最短路径" class="headerlink" title="8.6.1从某个源点到其余各的最短路径"></a>8.6.1从某个源点到其余各的最短路径</h3><ul>
<li><p>求从源点到其余各点的最短路径的算法的基本思想:<br>依最短路径的长度递增的次序求得各条路径。<br>其中，从源点到顶点v的最短路径是所有最短路径中长度最短者。</p>
</li>
<li><p>路径长度最短的最短路径的特点：<br>在这条路径上，必定只含一条弧，弧尾是$v_1$，并且这条弧的权值最小。<br>下一条路径长度次短的最短路径的特点：<br>它只可能有两种情况：或者是直接从源点到该点(只含一条弧)； 或者是从源点经过顶点$v_1$，再到达该顶点(由两条弧组成)。<br>再下一条路径长度次短的最短路径的特点:<br>它可能有三种情况：或者是直接从源点到该点(只含一条弧)； 或者是从源点经过顶点$v_1$，再到达该顶点(由两条弧组成)；或者是从源点经过顶点$v_2$，再到达该顶点。</p>
</li>
<li><p>其余最短路径的特点：<br>它或者是直接从源点到该点(只含一条弧)； 或者是从源点经过已求得最短路径的顶点，再到达该顶点。</p>
</li>
</ul>
<h3 id="8-6-2-迪杰斯特拉算法"><a href="#8-6-2-迪杰斯特拉算法" class="headerlink" title="8.6.2 迪杰斯特拉算法"></a>8.6.2 迪杰斯特拉算法</h3><blockquote>
<p>设置辅助数组Dist，其中每个分量Dist[k] 表示当前所求得的从源点到其余各顶点 k 的最短路径。<br>一般情况下，<br>Dist[k] = &lt;源点到顶点 k 的弧上的权值&gt;<br>或者 = &lt;源点到其它顶点的路径长度&gt;</p>
<ul>
<li>&lt;其它顶点到顶点 k 的弧上的权值&gt;。</li>
</ul>
<p>   1）在所有从源点出发的弧中选取一条权值最小的弧，即为第一条最短路径。$$A_{ij}=\begin{cases}G.arcs[v_0][k],v_0和k之间存在弧\INFINITY,v_0和k之间不存在弧\end{cases}$$其中的最小值即为最短路径的长度。2）修改其它各顶点k的Dist[k]值。假设求得最短路径的顶点为u，若 $Dist[u]+G.arcs[u][k]&lt;Dist[k]$则将 $Dist[k] 改为 Dist[u]+G.arcs[u][k]$。</p>
</blockquote>
<h3 id="8-6-3-例题"><a href="#8-6-3-例题" class="headerlink" title="8.6.3 例题"></a>8.6.3 例题</h3><ol>
<li>求从顶点$v_0到其余各个顶点的最短路径，给出过程。</li>
</ol>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210612160948485.png" alt="image-20210612160948485"></p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210612160954774.png" alt="image-20210612160954774"></p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210612160958886.png" alt="image-20210612160958886"></p>
<h1 id="9-查找"><a href="#9-查找" class="headerlink" title="9.查找"></a>9.查找</h1><h2 id="9-1-查找表"><a href="#9-1-查找表" class="headerlink" title="9.1.查找表"></a>9.1.查找表</h2><p>查找表是由同一类型的数据元素(或记录)构成的集合。<br>由于“集合”中的数据元素之间存在着松散的关系，因此查找表是一种应用灵便的结构。</p>
<ul>
<li>查找表的操作</li>
</ul>
<ol>
<li>查询某个“特定的”数据元素是否在查找表中</li>
<li>检索某个“特定的”数据元素的各种属性</li>
<li>在查找表中插入一个数据元素</li>
<li>从查找表中删去某个数据元素</li>
</ol>
<ul>
<li>查找表的分类</li>
</ul>
<p><strong>静态查找表</strong></p>
<p>仅作查询和检索操作的查找表</p>
<p><strong>动态查找表</strong></p>
<p>有时在查询之后，还需要将“查询”结果为“不在查找表中”的数据元素插入到查找表中；或者，从查找表中删除其“查询”结果为“在查找表”中的数据元素。</p>
<ul>
<li>关键字</li>
</ul>
<p>是数据元素（或记录）中某个数据项的值，用以标识（识别）一个数据元素（或记录）。</p>
<p>若此关键字可以识别唯一的一个记录，则称之谓“主关键字”。</p>
<p>若此关键字能识别若干记录，则称之谓“次关键字”。</p>
<ul>
<li>查找</li>
</ul>
<p>根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素或（记录）</p>
<p>若查找表中存在这样一个记录，则称“查找成功”，查找结果给出整个记录的信息，或指示该记录在查找表中的位置；</p>
<p>否则称“查找不成功”，查找结果给出“空记录”或“空指针”。</p>
<ul>
<li>查找的方法</li>
</ul>
<p>查找的方法取决于查找表的结构。<br>如果查找表中的数据元素之间不存在明显的组织规律，就不便于查找。<br>为了提高查找的效率， 需要在查找表中的元素之间人为地附加某种确定的关系，换句话说， 用某种特定的结构来表示查找表。</p>
<h2 id="9-1-1-例题"><a href="#9-1-1-例题" class="headerlink" title="9.1.1 例题"></a>9.1.1 例题</h2><ol>
<li>静态查找表的操作包括 <strong>查询、检索</strong>。</li>
<li>动态查找表的操作包括 <strong>查询、检索、插入、删除</strong>。</li>
<li>主关键字有可能识别若干记录（X）。</li>
<li>根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素或记录，若查找表中存在这样一个记录，则称“查找成功”（√）。</li>
</ol>
<h2 id="9-2-静态查找表"><a href="#9-2-静态查找表" class="headerlink" title="9.2 静态查找表"></a>9.2 静态查找表</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">ADT StaticSearchTable<span class="token punctuation">{</span>	数据对象D ：D是具有相同特性的数据元素的集合。每个数据元素含有类型相同的关键字，可唯一标识数据元素。    数据关系R：数据元素同属一个集合<span class="token punctuation">;</span>    基本操作P：<span class="token function">Create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ST<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    		 <span class="token function">Destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ST<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token function">Search</span><span class="token punctuation">(</span>ST<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    		 <span class="token function">Traverse</span><span class="token punctuation">(</span>ST<span class="token punctuation">,</span><span class="token function">Visit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>ADT StaticSearchTable<span class="token punctuation">;</span><span class="token comment">//静态查找表的基本操作/*Create(&amp;ST,n);操作结果：构造一个含n个数据元素的静态查找表ST;Destroy(&amp;ST);初始条件：静态查找表ST存在;操作结果：销毁表ST。Search(ST,key);初始条件：静态表ST存在，key为和查找表中元素的关键字类型相同的给定值。操作结果：若ST中存在其关键字等于key的数据元素，则函数值为该元素的值或在表中的位置，否则为“空”Traverse(ST,visit())初始条件：静态查找表ST存在，Visit是对元素操作的应用函数操作结果：按某种次序对ST的每个元素调用函数Visit()一次且仅一次，一旦Visit()失败，则操作失败。   */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="9-2-1-例题"><a href="#9-2-1-例题" class="headerlink" title="9.2.1 例题"></a>9.2.1 例题</h3><ol>
<li>在静态查找表已经存在的情况下，对其的操作一般不改变查找表的结构（√）</li>
<li>静态查找表查找成功是指查找表中存在其关键字等于key的数据，key为和查找表中元素的关键字类型相同的给定值。（√）</li>
</ol>
<h2 id="9-3-顺序表的查找"><a href="#9-3-顺序表的查找" class="headerlink" title="9.3 顺序表的查找"></a>9.3 顺序表的查找</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    ElemType <span class="token operator">*</span>elem<span class="token punctuation">;</span><span class="token comment">//数据元素存储空间基址，建表时按实际长度分配，0号单元留空    int length;//表的长度}SSTable; //顺序表int Search_Seq(SSTable ST,KeyType key){    //在顺序表ST中顺序查找其关键字等于key的数据元素。若找到，则函数值为该元素在表中的位置，否则为0.    ST.elem[0].key=key;//“哨兵”    for(i=ST.length;ST.elem[i].key!=key;--i);//从后往前找    return i;  //找不到时，i为0}//Search_Seq</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h3 id="9-3-1-顺序查找表的时间性能"><a href="#9-3-1-顺序查找表的时间性能" class="headerlink" title="9.3.1 顺序查找表的时间性能"></a>9.3.1 顺序查找表的时间性能</h3><p>定义：查找算法的平均查找长度（<strong>A</strong>verage <strong>S</strong>earch <strong>L</strong>ength)为确定记录在查找表中的位置，需和给定值<strong>进行比较的关键字个数的期望值</strong><br>$$<br>ASL=\Sigma P_iC_i<br>$$<br>对于顺序表而言，$C_i=n-i+1$<br>$$<br>ASL=nP_1+(n-1)P_2+···+2P_{n-1}+P_n<br>$$<br>在等概率查找的情况下，$p_i=\frac{1}{n}$</p>
<p>顺序表查找的平均查找长度为：<br>$$<br>ASL_{ss}=\frac{1}{n}\Sigma (n-i+1)=\frac{n+1}{2}<br>$$<br>在不等概率查找的情况下，$ASL_{ss}$在$P_n \geq P_n-1 \geq ···\geq P_2 \geq P_1 $ 时取极小值</p>
<p>若查找概率无法事先测定，则查找过程中采取的改进办法是，在每个查找之后，将刚刚查找到的记录直接移至表尾的位置上。</p>
<h3 id="9-3-2-例题"><a href="#9-3-2-例题" class="headerlink" title="9.3.2 例题"></a>9.3.2 例题</h3><ol>
<li>在顺序表（23，41，75，18，92，49，7，55）中顺序查找其关键字等于给定值49的数据元素，若找到，则给定值49与关键字比较的次数为 3 次。   </li>
<li>在顺序表（23，41，75，18，92，49，7，55）中顺序查找其关键字等于给定值25的数据元素，若确定找不到，则给定值25与关键字比较的次数为 9 次。</li>
<li>对顺序表（23，41，75，18，92，49，7，55）进行等概率顺序查找的平均查找长度ASL为4.5。</li>
</ol>
<h2 id="9-4-有序表的查找"><a href="#9-4-有序表的查找" class="headerlink" title="9.4 有序表的查找"></a>9.4 有序表的查找</h2><p>顺序查找表的查找算法简单， 但平均查找长度较大，特别不适用于表长较大的查找表。<br>若以有序表表示静态查找表，则查找过程可以基于“折半”进行。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">Search_Bin</span> <span class="token punctuation">(</span> SSTable ST<span class="token punctuation">,</span> KeyType key <span class="token punctuation">)</span> <span class="token punctuation">{</span>   low <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  high <span class="token operator">=</span> ST<span class="token punctuation">.</span>length<span class="token punctuation">;</span>     <span class="token comment">// 置区间初值   while(low&lt;=high) {      mid = (low+high)/2;      if (EQ(key,ST.elem[mid].key))        return mid;        // 找到待查元素      else if(LT(key,ST.elem[mid].key))        high= mid-1;       // 继续在前半区间进行查找      else low= mid+1; // 继续在后半区间进行查找   }   return 0;     // 顺序表中不存在待查元素} // Search_Bin</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="9-4-1-折半查找平均查找情况"><a href="#9-4-1-折半查找平均查找情况" class="headerlink" title="9.4.1 折半查找平均查找情况"></a>9.4.1 折半查找平均查找情况</h3><p>一般情况下，表长为n的折半查找的判定树的深度和含有n个结点的完全二叉树的深度相同。</p>
<p>假设 $ n=2^h-1$(满二叉树)，并且查找概率相等，则<br>$$<br>A S L_{b s}=\frac{1}{n} \sum_{i=1}^{n} C_{i}=\frac{1}{n}\left[\sum_{j=1}^{h} j \times 2^{j-1}\right]=\frac{n+1}{n} \log <em>{2}(n+1)-1<br>$$<br>$n&gt;50$时，可得近似结果<br>$$<br>ASL</em>{bs}\approx log_2(n+1)-1<br>$$</p>
<h3 id="9-4-2-索引顺序表的查找"><a href="#9-4-2-索引顺序表的查找" class="headerlink" title="9.4.2 索引顺序表的查找"></a>9.4.2 索引顺序表的查找</h3><p>索引顺序表的查找过程：</p>
<ol>
<li>由索引确定记录所在区间；</li>
<li>在顺序表的某个区间内进行查找</li>
</ol>
<p><strong>索引顺序查找</strong>的过程也是一个“<strong>缩小区间</strong>”的查找过程。<br>$$<br>索引顺序查找的平均查找长度=查找“索引”的平均查找长度+查找“顺序表”的平均查找长度<br>$$</p>
<h3 id="9-4-3-例题"><a href="#9-4-3-例题" class="headerlink" title="9.4.3 例题"></a>9.4.3 例题</h3><ol>
<li>画出在有序表A[1..15]中进行折半查找的判定树，并求出等概率情况下查找成功的平均查找长度。</li>
</ol>
<p>​                                         $\frac{49}{15} $</p>
<ol start="2">
<li><p>在等概率的情况下对31个关键字的有序列表进行折半查找，查找成功时的平均查找长度为：<br>$$<br>\frac{31+1}{31}log_232-1=\frac{32*5}{31}-1=\frac{160-31}{31}=\frac{129}{31}<br>$$</p>
</li>
<li><p>对线性表进行折半查找时，要求线性表必须（ B ）。</p>
<pre><code>A. 以顺序方式存储      B. 以顺序方式存储，且数据元素有序       
</code></pre>
<p>  C. 以链接方式存储     D. 以链接方式存储，且数据元素有序</p>
</li>
</ol>
<h2 id="9-5-动态查找表"><a href="#9-5-动态查找表" class="headerlink" title="9.5 动态查找表"></a>9.5 动态查找表</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">ADT DynamicSearchTable<span class="token punctuation">{</span>数据对象D：D是具有相同特性的数据元素的集合。每个数据元素含有类型相同的关键字，可唯一标识数据元素。数据关系R：数据元素同属一个集合。基本操作P：<span class="token function">InitDSTable</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>DT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">DestroyDSTable</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>DT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">SearchDST</span><span class="token punctuation">(</span>DT<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">DeleteDSTable</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>T<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">DestroyDSTable</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>DT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">InsertDSTable</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>DT<span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">DeleteDSTable</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>T<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">TraverseDSTable</span><span class="token punctuation">(</span>DT<span class="token punctuation">,</span><span class="token function">Visit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>ADT DynamicSearchTable<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<blockquote>
<p>InitDSTable(&amp;DT);</p>
<p>操作结果：构造一个空的动态查找表DT。</p>
<p>DestroyDSTable(&amp;DT);</p>
<p>初始条件：动态查找表DT存在；</p>
<p>操作结果：销毁动态查找表DT。</p>
<p>SearchDSTable(DT, key);<br>初始条件：动态查找表DT存在，key为和关键字类型相同的给定值；<br>操作结果：若DT中存在其关键字等于 key的数据元素，则函数值为该元素的值或在表中的位置，否则为“空”。<br>InsertDSTable(&amp;DT, e);<br>初始条件：动态查找表DT存在，e 为待插入的数据元素；<br>操作结果：若DT中不存在其关键字等于 e.key 的 数据元素，则插入e 到DT。</p>
<p>DeleteDSTable(&amp;T, key);<br>初始条件：动态查找表DT存在，key为和关键字类型相同的给定值；<br>操作结果：若DT中存在其关键字等于key的数据元素，则删除之。<br>TraverseDSTable(DT, Visit());<br>初始条件：动态查找表DT存在，Visit是对结点操作的应用函数；<br>操作结果：按某种次序对DT的每个结点调用函数 Visit() 一次且至多一次。一旦 Visit() 失败，则操作失败。</p>
</blockquote>
<h3 id="9-5-1-例题"><a href="#9-5-1-例题" class="headerlink" title="9.5.1 例题"></a>9.5.1 例题</h3><ol>
<li>在动态查找表的插入操作中，和给定值比较的对象是<strong>数据元素的关键字</strong>，插入的对象是<strong>数据元素（或记录）</strong></li>
<li>在动态查找表的删除操作中，删除的对象是<strong>数据元素</strong></li>
</ol>
<h2 id="9-6-二叉排序树"><a href="#9-6-二叉排序树" class="headerlink" title="9.6 二叉排序树"></a>9.6 二叉排序树</h2><p>内容：介绍二叉排序树的特点及其查找、插入和删除算法。</p>
<p>二叉排序树或者是一棵空树；或者是具有如下特性的二叉树：<br>（1）若它的左子树不空，则左子树上所有结点的值均小于根结点的值；<br>（2）若它的右子树不空，则右子树上所有结点的值均大于根结点的值；<br>（3）它的左、右子树也都分别是二叉排序树。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BiTNode</span><span class="token punctuation">{</span><span class="token comment">//结点结构    TElemType data;    struct BiTnode *lchild,*rchild;//左右孩子指针}BiTNode,*BiTree;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>3、二叉排序树的查找算法</p>
<p>若二叉排序树为空，则查找不成功；<br>否则，<br>1）若给定值等于根结点的关键字，则查找成功；<br>2）若给定值小于根结点的关键字，则继续在左子树上进行查找；<br>3）若给定值大于根结点的关键字，则继续在右子树上进行查找。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">Status <span class="token function">SearchBST</span> <span class="token punctuation">(</span>BiTree T<span class="token punctuation">,</span> KeyType key<span class="token punctuation">,</span> BiTree f<span class="token punctuation">,</span> BiTree <span class="token operator">&amp;</span>p <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 在根指针 T 所指二叉排序树中递归地查找其关键字等于 key 的数据元素，若查找//成功，则返回指针 p 指向该数据元素的结点，并返回函数值为 TRUE;否则表明//查找不成功，返回指针 p 指向查找路径上访问的最后一个结点，并返回函数值为// FALSE, 指针 f 指向当前访问的结点的双亲，其初始调用值为NULL。if (!T)  { p = f;  return FALSE; }  // 查找不成功else  if ( EQ(key, T-&gt;data.key) )  { p = T;  return TRUE; }  // 查找成功        else  if ( LT(key, T-&gt;data.key) )                           SearchBST (T-&gt;lchild, key, T, p );     // 在左子树中继续查找                else  SearchBST (T-&gt;rchild, key, T, p );    // 在右子树中继续查找} // SearchBST</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>4、二叉排序树的插入算法</p>
<p>根据动态查找表的定义，“插入”操作在查找不成功时才进行；<br>若二叉排序树为空树，则新插入的结点为新的根结点；否则，新插入的结点必为一个新的叶子结点，其插入位置由查找过程得到。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">Status Insert <span class="token function">BST</span><span class="token punctuation">(</span>BiTree <span class="token operator">&amp;</span>T<span class="token punctuation">,</span> ElemType e <span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 当二叉排序树中不存在关键字等于 e.key 的数据元素时，插入元素值为 e 的结点，并返回 TRUE; 否则，不进行插入并返回FALSE。   if (!SearchBST ( T, e.key, NULL, p ))     {  s = (BiTree) malloc (sizeof (BiTNode));  // 为新结点分配空间        s-&gt;data = e;  s-&gt;lchild = s-&gt;rchild = NULL;          if  ( !p )  T = s;     // 插入 s 为新的根结点        else   if ( LT(e.key, p-&gt;data.key) )   p-&gt;lchild = s;   // 插入 *s 为 *p 的左孩子               else  p-&gt;rchild = s;     // 插入 *s 为 *p 的右孩子        return TRUE;     // 插入成功   }                         else return FALSE;} // Insert BST</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<p>5、二叉排序树的删除算法和插入相反，删除是在查找成功之后进行，并且要求在删除二叉排序树上某个结点之后，仍然保持二叉排序树的特性。<br>可分三种情况讨论：<br>（1）被删除的结点是叶子结点；<br>（2）被删除的结点只有左子树或者只有右子树；<br>（3）被删除的结点既有左子树，也有右子树。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">Status <span class="token function">DeleteBST</span> <span class="token punctuation">(</span>BiTree <span class="token operator">&amp;</span>T<span class="token punctuation">,</span>  KeyType key <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 若二叉排序树 T 中存在其关键字等于 key 的数据元素，则删除该数据元素// 结点，并返回函数值 TRUE，否则返回函数值 FALSE。  if (!T)  return FALSE;      	// 不存在关键字等于key的数据元素  else {  if ( EQ (key, T-&gt;data.key) )   Delete (T);                                                                           // 找到关键字等于key的元素             else if ( LT (key, T-&gt;data.key) )                            DeleteBST ( T-&gt;lchild, key );   // 继续在左子树中进行查找                    else  DeleteBST ( T-&gt;rchild, key );  // 继续在右子树中进行查找             return TRUE;  } } // DeleteBST</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>6、二叉排序树的查找性能分析</p>
<p>对于每一棵特定的二叉排序树，均可按照平均查找长度的定义来求它的 ASL 值，显然，由值相同的 n 个关键字，构造所得的不同形态的各棵二叉排序树的平均查找长度的值不同，甚至可能差别很大。</p>
<p>例如：由关键字序列 1，2，3，4，5构造而得的<br>二叉排序树，ASL =（1+2+3+4+5）/ 5  = 3</p>
<p>由关键字序列 3，1，2，5，4构造而得的二叉排序树，<br>ASL =（1+2+3+2+3）/ 5<br>       =  2.2<br>在等概率的情况下，二叉排序树的平均查找长度为<br>$$<br>P(n)=2 \frac{n+1}{n} \log n+C<br>$$</p>
<h3 id="9-6-1-例题"><a href="#9-6-1-例题" class="headerlink" title="9.6.1 例题"></a>9.6.1 例题</h3><ol>
<li>已知关键字序列（20，13，1，5，3， 8，30），<br>试构造二叉排序树并且进行中序遍历。<br>中序遍历结果1，3，5，8，13，20，30</li>
<li>二叉排序树上结点的关键字的值有可能相同。（ X ）</li>
<li>对二叉排序树进行先右后左的中序遍历可以得到<br>关键字的降序排列。（√）</li>
</ol>
<h2 id="9-7-平衡二叉树"><a href="#9-7-平衡二叉树" class="headerlink" title="9.7 平衡二叉树"></a>9.7 平衡二叉树</h2><p>内容：介绍平衡二叉树的定义和构造。</p>
<h3 id="9-7-1-平衡因子"><a href="#9-7-1-平衡因子" class="headerlink" title="9.7.1 平衡因子"></a>9.7.1 平衡因子</h3><p>二叉树上结点的平衡因子定义为：该结点的左子树的深度减去右子树的深度。</p>
<p>平衡二叉树首先是二叉排序树，它是二叉查找树的另一种形式，其特点为：树中每个结点的左、右子树深度之差的绝对值不大于1 。或者说平衡二叉树上每个结点的平衡因子的绝对值都小于等于1。</p>
<h3 id="9-7-2-构造平衡二叉树的步骤："><a href="#9-7-2-构造平衡二叉树的步骤：" class="headerlink" title="9.7.2 构造平衡二叉树的步骤："></a>9.7.2 构造平衡二叉树的步骤：</h3><p>1、按照构造二叉排序树的方式逐个添加结点。<br>2、每当添加一个结点，就要判断当前二叉树是否平衡。<br>3、如果当前二叉树平衡，则继续添加结点。<br>4、如果当前二叉树不平衡，先要找出最小不平衡子树，再判断最小不平衡子树中结点的数目；如果结点的数目为3，直接重构；如果结点的数目大于3，则按照<strong>L</strong>L、<strong>R</strong>R、L<strong>R</strong>、R<strong>L</strong>型重构，重构时最小不平衡子树以<strong>加粗部分为根</strong>。</p>
<h3 id="9-7-3-平衡二叉树的查找性能分析"><a href="#9-7-3-平衡二叉树的查找性能分析" class="headerlink" title="9.7.3 平衡二叉树的查找性能分析"></a>9.7.3 平衡二叉树的查找性能分析</h3><p>由此推得，深度为 $h $的平衡二叉树中所含结点的最小值$N_{h}=\varphi^{h+2} / \sqrt{5}-1$。<br>反之，含有$ n$ 个结点的平衡二叉树能达到的最大深度$h_{n}=\log _{\varphi}(\sqrt{5}(\mathrm{n}+1))-2$。<br>因此，在平衡二叉树上进行查找时，<br>查找过程中和给定值进行比较的关键字的个数和$ log(n) $相当。</p>
<h3 id="9-7-4-例题"><a href="#9-7-4-例题" class="headerlink" title="9.7.4 例题"></a>9.7.4 例题</h3><ol>
<li>深度为5的平衡二叉树的结点数至少有 <strong>12</strong> 个。</li>
<li>平衡二叉树中，若某个结点的左右孩子的平衡因子为零，则该结点的平衡因子一定是零。（x)</li>
<li>一棵深度为K的平衡二叉树，所有结点的平衡因子都为0，则该树共有______ 个结点。 ( 2k-1 )</li>
<li>平衡二叉树一定是二叉排序树（√）</li>
<li>按顺序输入一组关键字序列(50，60，70，30，20，10)，画出其构成的平衡二叉树，给出过程。</li>
</ol>
<h2 id="9-8-B-树"><a href="#9-8-B-树" class="headerlink" title="9.8 B_树"></a>9.8 B_树</h2><p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210612212748518.png" alt="image-20210612212748518"></p>
<p>B_树是一种平衡的多路查找树</p>
<p>（1）多叉树的特性：<br>    在 m 阶的B-树上，每个非终端结点可能含有：<br>    n 个关键字 Ki（1≤ i≤n） n&lt;m<br>    n+1 个指向子树的指针 Ai（0≤i≤n）</p>
<p>（2）查找树的特性：<br>  非叶结点中的多个关键字均自小至大有序排列，即：K1&lt; K2 &lt; … &lt; Kn  ；<br>    Ai-1 所指子树上所有关键字均小于Ki  ；<br>    Ai 所指子树上所有关键字均大于Ki  。</p>
<p>（3）平衡树的特性：<br>  树中所有叶子结点均不带信息，且在树中的同一层次上；<br>  根结点或为叶子结点，或至少含有两棵子树；<br>  其余所有非叶结点均至少含有m/2棵子树，至多含有 m 棵子树。</p>
<h3 id="9-8-1-B-树中关键字的查找过程"><a href="#9-8-1-B-树中关键字的查找过程" class="headerlink" title="9.8.1 B_树中关键字的查找过程"></a>9.8.1 B_树中关键字的查找过程</h3><p>从根结点出发，沿指针搜索结点和在结点内进行顺序（或折半）查找 两个过程交叉进行。<br>若查找成功，则返回指向被查关键字所在结点的指针和关键字在结点中的位置；若查找不成功，则返回插入位置。</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210612212932417.png" alt="image-20210612212932417"></p>
<p>在查找不成功之后，需进行插入。<br>显然，关键字插入的位置必定在最下层的非叶结点，有下列几种情况：<br>1）插入后，该结点的关键字个数n&lt;m，不修改指针;<br>2）插入后，该结点的关键字个数 n=m，则需进行“结点分裂”，<br>3）若双亲为空，则建新的根结点。</p>
<p><strong>4、B_树中删除关键字的过程</strong></p>
<p>和插入的考虑相反，首先必须找到待删关键字所在结点，并且要求删除之后，结点中关键字的个数不能小于$\lceil m/2 \rceil-1$，否则，要从其左(或右)兄弟结点“借调”关键字，若其左和右兄弟结点均无关键字可借(结点中只有最少量的关键字)，则必须进行结点的“合并”。</p>
<h3 id="9-8-2-B-树查找性能分析"><a href="#9-8-2-B-树查找性能分析" class="headerlink" title="9.8.2 B_树查找性能分析"></a>9.8.2 B_树查找性能分析</h3><p>在含 N 个关键字的 B-树上进行一次查找，需访问的结点个数不超过：$\log _{m / 2}((N+1) / 2)+1$</p>
<h3 id="9-8-3-例题"><a href="#9-8-3-例题" class="headerlink" title="9.8.3  例题"></a>9.8.3  例题</h3><ol>
<li>一棵m阶B_树的非终端结点至少有______个关键字。( $\lceil m/2 \rceil-1$ )</li>
<li>已知3阶B_树结构如下图所示，当插入元素“80” 时，调整后新的根元素是_______。 60</li>
</ol>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210612214641751.png" alt="image-20210612214641751"></p>
<ol start="3">
<li>一棵3阶B_树中含有2047个关键字，包含叶子结点层，该树的最大深度为（ B ）。<pre><code>A. 11        B. 12        C. 13        D. 14
</code></pre>
第 H+1 层为叶子结点，而当前树中含有 N 个关键字，则叶子结点必为 N+1 个，$H \leq \log _{\lceil m / 2 \rceil}((N+1) / 2)+1$</li>
<li>一棵8阶的B-树，除根之外的所有非终端结点中最多有7个关键字，最少有4个关键字。（ X ）</li>
</ol>
<h2 id="9-9-哈希表"><a href="#9-9-哈希表" class="headerlink" title="9.9 哈希表"></a>9.9 哈希表</h2><p>表示查找表的静态和动态结构的共同特点：记录在表中的位置和它的关键字之间不存在一个确定的关系。<br>查找的过程为给定值依次和关键字集合中各个关键字进行比较，<br>查找的效率取决于和给定值进行比较的关键字个数。<br>用这类方法表示的查找表，其平均查找长度ASL都不为零。<br>不同表示方法的差别仅在于：关键字和给定值进行比较的顺序不同。<br>对于频繁使用的查找表，希望  ASL = 0。<br>只有一个办法：预先知道所查关键字在表中的位置，即要求记录在表中位置和其关键字之间存在一种确定的关系。</p>
<p>但是，对于动态查找表而言，</p>
<ol>
<li>表长不确定；</li>
<li>在设计查找表时，只知道关键字所属范围，而不知道确切的关键字。<br>因此在一般情况下，需在关键字与记录在表中的存储位置之间建立一个函数关系，以 f(key) 作为关键字为 key 的记录在表中的位置，通常称这个函数 f(key) 为哈希函数。</li>
</ol>
<h3 id="9-9-1-例题"><a href="#9-9-1-例题" class="headerlink" title="9.9.1 例题"></a>9.9.1 例题</h3><ol>
<li>哈希表的平均查找长度一定大于零。（ X ）</li>
<li>哈希表建立了关键字和存储地址之间的映射。（ √ ）</li>
<li>哈希表一定是一个压缩映像。（ X ）</li>
<li>哈希表的冲突指的是关键字不同而相应的哈希地址却相同。（ √ ）</li>
<li>构造哈希表，除了需要选择一个尽可能少产生冲突的哈希函数之外，还需要找到一种处理冲突的方法。（ √ ）</li>
</ol>
<h3 id="9-9-2-哈希表处理冲突的方法"><a href="#9-9-2-哈希表处理冲突的方法" class="headerlink" title="9.9.2 哈希表处理冲突的方法"></a>9.9.2 哈希表处理冲突的方法</h3><p>内容：介绍哈希表处理冲突的方法，包括开放定址法和链地址法。</p>
<h4 id="9-9-2-1-开放定址法"><a href="#9-9-2-1-开放定址法" class="headerlink" title="9.9.2.1 开放定址法"></a>9.9.2.1 开放定址法</h4><ol>
<li>线性探测再散列</li>
<li>平方探测再散列</li>
<li>随机探测再散列</li>
</ol>
<h4 id="9-9-2-2-链地址法"><a href="#9-9-2-2-链地址法" class="headerlink" title="9.9.2.2 链地址法"></a>9.9.2.2 链地址法</h4><h1 id="10-排序（未完）"><a href="#10-排序（未完）" class="headerlink" title="10. 排序（未完）"></a>10. 排序（未完）</h1><h2 id="10-1直接插入排序"><a href="#10-1直接插入排序" class="headerlink" title="10.1直接插入排序"></a>10.1直接插入排序</h2><h3 id="10-1-1原理"><a href="#10-1-1原理" class="headerlink" title="10.1.1原理"></a>10.1.1原理</h3><p>把无序序列的第一个插入有序序列中，使无序序列的个数减1，有序序列的个数增1。</p>
<h3 id="10-1-2-插入排序的步骤"><a href="#10-1-2-插入排序的步骤" class="headerlink" title="10.1.2 插入排序的步骤"></a>10.1.2 插入排序的步骤</h3><ol>
<li>在R[1…i-1]中查找R[i]的插入位置（利用“顺序查找”实现，从后往前找），R[1…j].key&lt;=R[i].key&lt;R[j+1…i-1].key</li>
<li>将R[j+1…i-1]中的所有记录均后移一个位置</li>
<li>将R[i]插入到R[j+1]的位置上</li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//对顺序表L作直接插入排序	for(int i=2;i&lt;=L.length;i++)        if(L.r[i].key&lt;L.r[i-1].key){            L.r[0]=L.r[i];            L.r[i]=L.r[i-1]; //复制为监视哨            for(j=i-2;L.r[0].key&lt;L.r[j].key;--j)                L.r[j+1]=L.r[j];   //记录后移            	L.r[j+1]=L.r[0];  //插入到正确位置        }}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="10-1-3时间性能"><a href="#10-1-3时间性能" class="headerlink" title="10.1.3时间性能"></a>10.1.3时间性能</h3><ul>
<li><p>内部排序的时间分析</p>
<p>实现内部排序的基本操作有两个：</p>
<p>1.”比较“两个关键字的大小</p>
<p>2.“移动”记录</p>
</li>
</ul>
<p>算法复杂度：O（n²）</p>
<h2 id="10-2快速排序"><a href="#10-2快速排序" class="headerlink" title="10.2快速排序"></a>10.2快速排序</h2><h3 id="10-2-1原理"><a href="#10-2-1原理" class="headerlink" title="10.2.1原理"></a>10.2.1原理</h3><p>目标：找一个记录，以它的关键字作为“枢轴”，凡其关键字小于枢轴的记录均移动至该记录之前，反之，凡关键字大于枢轴的记录均移动至该记录之后。</p>
<h3 id="10-2-2-代码"><a href="#10-2-2-代码" class="headerlink" title="10.2.2 代码"></a>10.2.2 代码</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">Partition</span><span class="token punctuation">(</span>RedType R<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{</span>    R<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>R<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>    pivotkey<span class="token operator">=</span>R<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token operator">&amp;&amp;</span>R<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">&gt;=</span>pivotkey<span class="token punctuation">)</span>            <span class="token operator">--</span>high<span class="token punctuation">;</span>        R<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token operator">=</span>R<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token operator">&amp;&amp;</span>R<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">&lt;=</span>pivotkey<span class="token punctuation">)</span>            <span class="token operator">++</span>low<span class="token punctuation">;</span>        R<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token operator">=</span>R<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    R<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token operator">=</span>R<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> low<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//当低子序列或高子序列的长度为1时，就不再进行递归排列了void QSort(RedType &amp;R[],int s,int t){    //对记录序列R[s..t]进行快速排序    if(s&lt;t){//长度大于1        pivotloc=Partition(R,s,t);//对R[s..t]进行一次划分        QSort(R,s,pivotloc-1);//对低子序列递归排序，pivotloc是枢轴位置        Qsort(R,pivotloc+1,t);//对高子序列递归排序    }}void QuickSort(SqList &amp;L){    QSort(L.r,1,L.length);}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="10-2-3时间性能"><a href="#10-2-3时间性能" class="headerlink" title="10.2.3时间性能"></a>10.2.3时间性能</h3><ul>
<li>时间复杂度: Tavg(n)&lt;(b/a+2c)(n+1)ln(n+1)</li>
<li>结论：快速排序的时间复杂度为O（nln(n)）</li>
<li>若待排记录的初始状态按关键字有序时，快速排序将蜕化为起泡排序，其时间复杂度为O（n²），为避免出现这种情况，需要在一次划分之前进行预处理，需要在首尾中三个位置的值进行相互比较，然后取关键字为“三者之中”的记录为枢轴记录。</li>
</ul>
<h2 id="10-3-希尔排序"><a href="#10-3-希尔排序" class="headerlink" title="10.3 希尔排序"></a>10.3 希尔排序</h2><h3 id="10-3-1原理"><a href="#10-3-1原理" class="headerlink" title="10.3.1原理"></a>10.3.1原理</h3><p>对待排序列先作“宏观”调整，再作“微观”调整。所谓”宏观“调整指的是跳跃式的进行插入排序。</p>
<p>R[1],R[1+d],R[1+2d],R[1+3d],R[1+4d],R[1+5d]…..R[1+kd]</p>
<p>R[2],R[2+d],R[2+2d],R[2+3d],R[2+4d],R[2+5d]…..R[2+kd]</p>
<p>…</p>
<p>R[d],R[2d],R[3d],R[4d],R[5d],R[6d]…..R[(k+1)d]</p>
<p>其中，d称为增量，一般是一个素数序列，它的值在排序过程中从大到小逐渐减小，直至最后一趟排序减为1。</p>
<p>如（…5,3,1)</p>
<h3 id="10-3-2-代码"><a href="#10-3-2-代码" class="headerlink" title="10.3.2 代码"></a>10.3.2 代码</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">ShellInsert</span><span class="token punctuation">(</span>Sqlist <span class="token operator">&amp;</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> dk<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>dk<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token operator">-</span>dk<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">{</span>            L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//第i个记录暂存在R[0]            for(int j=i-dk;j&lt;0&amp;&amp;(L.r[0].key&lt;L.r[j].key);j-=dk)                L.r[j+dk]=L.r[j]; //记录后移，查找插入位置            L.r[j+dk]=L.r[0];//插入        }//if}void ShellSort(SqList &amp;L,int dlta[],int t){  //增量为dlta[]的希尔排序    for(int k=0;k&lt;t;++t)      ShellInsert(L,dlta[k]);    //一趟增量为dlta[k]的插入排序}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h2 id="10-5归并排序"><a href="#10-5归并排序" class="headerlink" title="10.5归并排序"></a>10.5归并排序</h2><h3 id="10-5-1原理"><a href="#10-5-1原理" class="headerlink" title="10.5.1原理"></a>10.5.1原理</h3><p>归并排序的过程：</p>
<p>将两个或两个以上的<strong>有序子序列</strong>归并为1个有序序列。</p>
<h3 id="10-5-2代码"><a href="#10-5-2代码" class="headerlink" title="10.5.2代码"></a>10.5.2代码</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Merge</span><span class="token punctuation">(</span>RcdType SR<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>RcdType <span class="token operator">&amp;</span>TR<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//将有序的记录序列SR[i...m]和SR[m+1...n]归并为有序的记录序列TR[i..n]for(int j=m+1,k=i;i&lt;=m&amp;&amp;j&lt;=n;++k){//将SR中记录由小到大地并入TR    if(SR[i].key&lt;=SR[j].key)TR[k]=SR[i++];    else TR[k]=SR[j++];}    if(i&lt;=m)TR[k..n]=SR[i..m];//将剩余的SR[i..m]复制到TR    if(j&lt;=n)TR[k..n]=SR[j..n];//将剩余的SR[j..n]复制到TR}//mergevoid Msort(RcdType SR[],RcdType &amp;TR1[],int s,int t){    //将SR[s..t]归并排序为TR1[s..t]    if(s==t)TR1[s]=SR[s];    else{        m=(s+t)/2;//将ST[s..t]平分成SR[s..m]和SR[m+1..t]        Msort(SR,TR2,s,m);//递归地将SR[s..m]归并为有序的TR2[s..m]        Msort(SR,TR2,m+1,t);//递归地将SR[m+1..t]归并为有序的TR2[m+1..t]        Merge(TR2,TR1,s,m,t);//将TR2[s..m]和TR2[m+1]归并到TR1[s..t]    }}void MergeSort(SqList&amp;L){    Msort(L.r,L.r,1,L.length);}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="1-5-3步骤"><a href="#1-5-3步骤" class="headerlink" title="1.5.3步骤"></a>1.5.3步骤</h3><p>1.平分直到有序</p>
<p>2.相邻的两个序列排序</p>
<h3 id="1-5-4时间性能"><a href="#1-5-4时间性能" class="headerlink" title="1.5.4时间性能"></a>1.5.4时间性能</h3><p>O（nlogn）</p>
<p>每一趟归并时间的复杂度为O（n），要进行log2n趟</p>
<h2 id="9-6链式基数排序"><a href="#9-6链式基数排序" class="headerlink" title="9.6链式基数排序"></a>9.6链式基数排序</h2><h3 id="9-6-1原理"><a href="#9-6-1原理" class="headerlink" title="9.6.1原理"></a>9.6.1原理</h3><p>基数排序是一种借助“多关键字排序”的思想来实现“单关键字排序”的内部排序算法。</p>
<h3 id="9-6-2数字型基数排序"><a href="#9-6-2数字型基数排序" class="headerlink" title="9.6.2数字型基数排序"></a>9.6.2数字型基数排序</h3><p>209,386,768,185,247,606,230,834,539</p>
<ul>
<li><p>首先按“个位数”取值分别为0,1,….,9，“分配”成10组，之后按从0至9的顺序将他们“收集”在一起。</p>
</li>
<li><p>然后按其“十位数”取值分别为0,1,….,9，“分配”成10组，之后按从0至9的顺序将他们“收集”在一起。</p>
</li>
<li><p>最后按其“百位数”重复一遍上述操作</p>
</li>
</ul>
<h3 id="9-6-2代码"><a href="#9-6-2代码" class="headerlink" title="9.6.2代码"></a>9.6.2代码</h3>
                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Raina Jung</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://rainajung.github.io/2021/07/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/">https://rainajung.github.io/2021/07/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Raina Jung</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Data-Structure/">
                                    <span class="chip bg-color">Data Structure</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/07/21/bin-CMakeList/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="">
                        
                        <span class="card-title"></span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-07-21
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Raina Jung
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/07/02/Java%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/6.jpg" class="responsive-img" alt="Java知识点总结">
                        
                        <span class="card-title">Java知识点总结</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-07-02
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Notes/" class="post-category">
                                    Notes
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Java/">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="6861814434"
                   fixed='true'
                   autoplay='true'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.6'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2021</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">Raina Jung</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">57k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/rainaJung" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="2911226810@qq。com>" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2911226810" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
