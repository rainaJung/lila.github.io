<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Jva知识点总结 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1.语法class_2.pptx 1.1变量1.2常量 不可改变  用关键字 final 定义 1final double PI&#x3D;3.14159265; 只能赋值一次   1.3表达式 操作符+操作数  会被计算成一个确定类型的数   1.4赋值1.5基本数据类型和引用类型 基本数据类型： int、double …  引用数据类型：对象、数组    1.5.1默认值   Data Type Def">
<meta property="og:type" content="article">
<meta property="og:title" content="Jva知识点总结">
<meta property="og:url" content="http://example.com/2021/07/02/Jva%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1.语法class_2.pptx 1.1变量1.2常量 不可改变  用关键字 final 定义 1final double PI&#x3D;3.14159265; 只能赋值一次   1.3表达式 操作符+操作数  会被计算成一个确定类型的数   1.4赋值1.5基本数据类型和引用类型 基本数据类型： int、double …  引用数据类型：对象、数组    1.5.1默认值   Data Type Def">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210604232429013.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210604235242125.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210605000020622.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210605000309901.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210606135250614.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210607130443432.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210608154248413.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210608154613133.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210608173134409.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210608174703378.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210610000544871.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210610004832979.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210610004949662.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210610005608963.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210610220036743.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210611095326678.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210611111651970.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210611113314639.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210611123238321.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210611125929988.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210611144612382.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210611144751454.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210612174508584.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210612175835906.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210612180124830.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210612180349045.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613152506667.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613152518088.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613153215634.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613153308502.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613153655554.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613154403581.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613154310899.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613155043717.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613155110614.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613155115572.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613155524735.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613160401542.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613160509726.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613163515755.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613163959545.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613164003512.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613164319279.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613191003189.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613191157958.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613191336936.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613191710562.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613192221650.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613193154030.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613195107741.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613195444394.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613195603287.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613201806739.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613202450550.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613211741244.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613212533977.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613212538070.png">
<meta property="og:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210613215556091.png">
<meta property="article:published_time" content="2021-07-01T16:43:31.000Z">
<meta property="article:modified_time" content="2021-07-01T16:46:02.378Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/86153/AppData/Roaming/Typora/typora-user-images/image-20210604232429013.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Jva知识点总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/02/Jva%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2021-07-01T16:43:31.000Z" itemprop="datePublished">2021-07-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Jva知识点总结
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-语法"><a href="#1-语法" class="headerlink" title="1.语法"></a>1.语法</h1><p>class_2.pptx</p>
<h2 id="1-1变量"><a href="#1-1变量" class="headerlink" title="1.1变量"></a>1.1变量</h2><h2 id="1-2常量"><a href="#1-2常量" class="headerlink" title="1.2常量"></a>1.2常量</h2><ul>
<li><p>不可改变</p>
</li>
<li><p>用关键字 final 定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> PI=<span class="number">3.14159265</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>只能赋值一次</p>
</li>
</ul>
<h2 id="1-3表达式"><a href="#1-3表达式" class="headerlink" title="1.3表达式"></a>1.3表达式</h2><ul>
<li><p>操作符+操作数</p>
</li>
<li><p>会被计算成一个确定类型的数</p>
</li>
</ul>
<h2 id="1-4赋值"><a href="#1-4赋值" class="headerlink" title="1.4赋值"></a>1.4赋值</h2><h2 id="1-5基本数据类型和引用类型"><a href="#1-5基本数据类型和引用类型" class="headerlink" title="1.5基本数据类型和引用类型"></a>1.5基本数据类型和引用类型</h2><ul>
<li><p>基本数据类型： int、double …</p>
</li>
<li><p>引用数据类型：对象、数组</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210604232429013.png" alt="image-20210604232429013"></p>
</li>
</ul>
<h3 id="1-5-1默认值"><a href="#1-5-1默认值" class="headerlink" title="1.5.1默认值"></a>1.5.1默认值</h3><table>
<thead>
<tr>
<th>Data Type</th>
<th>Default Value</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td><strong>false</strong></td>
</tr>
<tr>
<td>byte</td>
<td>0</td>
</tr>
<tr>
<td>char</td>
<td>‘\u000’</td>
</tr>
<tr>
<td>short</td>
<td>0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0d</td>
</tr>
<tr>
<td>Any class type</td>
<td>null</td>
</tr>
</tbody></table>
<h3 id="1-5-2-boolean"><a href="#1-5-2-boolean" class="headerlink" title="1.5.2 boolean"></a>1.5.2 boolean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> truth=<span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>

<p>boolean有两种： true和false</p>
<h3 id="1-5-3-char"><a href="#1-5-3-char" class="headerlink" title="1.5.3 char"></a>1.5.3 char</h3><h3 id="1-5-4-String"><a href="#1-5-4-String" class="headerlink" title="1.5.4 String"></a>1.5.4 String</h3><p>它不是一个基本数据类型，而是一个类。</p>
<h3 id="1-5-5-byte，short，int，long"><a href="#1-5-5-byte，short，int，long" class="headerlink" title="1.5.5  byte，short，int，long"></a>1.5.5  byte，short，int，long</h3><ul>
<li><p>Decimal 10，octal 8，hexadecimal  16</p>
</li>
<li><p>0开头的是8进制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1=<span class="number">077</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>0x开头的是16进制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b2=<span class="number">0xBAAC</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>L/l 结尾的是long</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b3=<span class="number">0x03L</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-5-5-1范围"><a href="#1-5-5-1范围" class="headerlink" title="1.5.5.1范围"></a>1.5.5.1范围</h4><table>
<thead>
<tr>
<th>Integer Length</th>
<th>Name or Type</th>
<th>Range</th>
</tr>
</thead>
<tbody><tr>
<td>8 bits</td>
<td>byte</td>
<td>-2^7 - 2^7-1</td>
</tr>
<tr>
<td>16 bits</td>
<td>short</td>
<td>-2^15 - 2^31-1</td>
</tr>
<tr>
<td>32 bits</td>
<td>int</td>
<td>-2^31 - 2^31-1</td>
</tr>
<tr>
<td>64 bits</td>
<td>long</td>
<td>-2^63 - 2^63-1</td>
</tr>
</tbody></table>
<h3 id="1-5-6-float和double"><a href="#1-5-6-float和double" class="headerlink" title="1.5.6 float和double"></a>1.5.6 float和double</h3><ul>
<li>E/e    指数</li>
<li>F/f    float</li>
<li>D/d    double</li>
</ul>
<p>32 bits</p>
<p>64 bits</p>
<h3 id="1-5-6-操作符"><a href="#1-5-6-操作符" class="headerlink" title="1.5.6 操作符"></a>1.5.6 操作符</h3><p>算术操作符只适用于基本数据类型（ byte, short, int, long, float, double, char），不适用与boolean</p>
<ul>
<li><p>int/int=&gt;int</p>
</li>
<li><p>如果操作数是byte，short或者char，那么结果会转换为int</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210604235242125.png" alt="image-20210604235242125"></p>
</li>
</ul>
<h3 id="1-5-7-隐式类型转换"><a href="#1-5-7-隐式类型转换" class="headerlink" title="1.5.7 隐式类型转换"></a>1.5.7 隐式类型转换</h3><p>当两个操作数的类型不同时，小类型会自动转换为大类型</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210605000020622.png" alt="image-20210605000020622"></p>
<p>总结：</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210605000309901.png" alt="image-20210605000309901"></p>
<h2 id="1-6-控制语句"><a href="#1-6-控制语句" class="headerlink" title="1.6  控制语句"></a>1.6  控制语句</h2><h3 id="1-6-1顺序"><a href="#1-6-1顺序" class="headerlink" title="1.6.1顺序"></a>1.6.1顺序</h3><h3 id="1-6-2分支"><a href="#1-6-2分支" class="headerlink" title="1.6.2分支"></a>1.6.2分支</h3><ul>
<li><p>if,else</p>
</li>
<li><p>switch</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> 常量<span class="number">1</span>:...    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 常量<span class="number">2</span>:...    <span class="keyword">break</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-6-3循环"><a href="#1-6-3循环" class="headerlink" title="1.6.3循环"></a>1.6.3循环</h3><ul>
<li>for</li>
<li>enhanced for loop(for each)</li>
<li>while</li>
</ul>
<h1 id="2-数组和字符串"><a href="#2-数组和字符串" class="headerlink" title="2.数组和字符串"></a>2.数组和字符串</h1><p>class_3_array_string.pptx</p>
<h2 id="2-1-print-I-0"><a href="#2-1-print-I-0" class="headerlink" title="2.1 print I/0"></a>2.1 print I/0</h2><ul>
<li><p>标准输入设备</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.in</span><br></pre></td></tr></table></figure></li>
<li><p>标准输出设备</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out</span><br></pre></td></tr></table></figure></li>
<li><p>标准错误设备</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.err</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-1-1-Scanner"><a href="#2-1-1-Scanner" class="headerlink" title="2.1.1 Scanner"></a>2.1.1 Scanner</h3><ul>
<li>所在包：java.util</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        <span class="keyword">int</span> num1;        <span class="keyword">double</span> num2;        String str;        Scanner in=<span class="keyword">new</span> Scanner(System.in);        System.out.println(<span class="string">&quot;Enter an integer:&quot;</span>);        num1=in.nextInt();        System.out.println(<span class="string">&quot;Enter a floating point:&quot;</span>);        num2=in.nextDouble();        System.out.printf(<span class="string">&quot;%s, Sum of %d &amp; %.2f is %.2f \n&quot;</span>,str,num1,num2,num1+num2);        in.close();    &#125;&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-1-1-1-nextLine"><a href="#2-1-1-1-nextLine" class="headerlink" title="2.1.1.1 nextLine"></a>2.1.1.1 nextLine</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        <span class="keyword">int</span> num1;        <span class="keyword">double</span> num2;        String str;        Scanner in=<span class="keyword">new</span> Scanner(System.in);        System.out.println(<span class="string">&quot;Enter a string(with space):&quot;</span>);        str=in.nextLine();        System.out.printf(<span class="string">&quot;%s%n&quot;</span>,str);        in.close();    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-1-2-input-source"><a href="#2-1-1-2-input-source" class="headerlink" title="2.1.1.2 input source"></a>2.1.1.2 input source</h4><h2 id="2-2-char"><a href="#2-2-char" class="headerlink" title="2.2  char"></a>2.2  char</h2><ul>
<li><p>在算术操作中，char会被首先转换成int类型。</p>
</li>
<li><p>在java中，运算符只能运用于 <strong>int，long，float或者double</strong>类型，不能应用与byte，short，char类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1=<span class="string">&#x27;0&#x27;</span>;<span class="keyword">char</span> c2=<span class="string">&#x27;A&#x27;</span>;<span class="keyword">char</span> c3;<span class="comment">//c3=c1+c2   err:RHS evaluated to &quot;int&quot;,cannot assign to LHS of &quot;char&quot;c3=(char)(c1+c2);System.out.println(c3); //print &#x27;q&#x27; System.out.println(c1+c2); //print int 113System.out.println((char)(c1+c2));  //print cahr &#x27;q&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>复合运算符（像 +=，-=，*=，/=,%=）它们作用于int类型，但是结果会自动转换成等式的左值类型</p>
</li>
<li><p>对于char（和byte，和short）的increment（++）和decrement（–），不转换为int。</p>
</li>
</ul>
<h3 id="2-2-1-char转换为int"><a href="#2-2-1-char转换为int" class="headerlink" title="2.2.1 char转换为int"></a>2.2.1 char转换为int</h3><ul>
<li><p>可以通过 -‘0’ 的方式将char类型转换为int类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> hexChar=<span class="string">&#x27;a&#x27;</span>;<span class="keyword">int</span> dec;<span class="keyword">if</span>(hexChar&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;hexChar&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;dec=hexChar-<span class="string">&#x27;0&#x27;</span>;  <span class="comment">//int 0-9&#125;else if(hexChar&gt;=&#x27;A&#x27;&amp;&amp;hexChar&lt;=&#x27;F&#x27;)&#123;dec=hexChar-&#x27;A&#x27;+10;//int 10-15&#125;else if(hexChar&gt;=&#x27;a&#x27;&amp;&amp;hexChar&lt;=&#x27;f&#x27;)&#123;dex=hexChar-&#x27;a&#x27;+10;  nt 10-15&#125;else&#123;dex=-1;System.out.println(&quot;invalid hex char&quot;);&#125;System.out.println(hexChar+&quot;:&quot;+dec);</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-3-String"><a href="#2-3-String" class="headerlink" title="2.3 String"></a>2.3 String</h2><p>不是基本数据类型，而是一个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String greeting=<span class="string">&quot;Good Morning!\n&quot;</span>;String errorMessage=<span class="string">&quot;Record Not Found!&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>str.length()：返回字符串的长度</li>
<li>str.charAt(int index)：返回字符串index位置的字符</li>
<li>str1.equals(str2)：比较两个字符串是否相等，<strong>注意：不能用“str1==str2”来比较</strong></li>
</ul>
<h3 id="2-3-1将字符串转为基本数据类型"><a href="#2-3-1将字符串转为基本数据类型" class="headerlink" title="2.3.1将字符串转为基本数据类型"></a>2.3.1将字符串转为基本数据类型</h3><ul>
<li>将字符串转为整型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer.parseInt(anlntStr)</span><br></pre></td></tr></table></figure>

<ul>
<li>将字符串转为浮点型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Double.parseDouble(aDoublestr)</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Float.parseFloar(aFloatStr)</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2将基本数据类型转为字符串"><a href="#2-3-2将基本数据类型转为字符串" class="headerlink" title="2.3.2将基本数据类型转为字符串"></a>2.3.2将基本数据类型转为字符串</h3><p>方法：</p>
<ul>
<li><p>用“+”连接基本数据类型和空的字符串“”</p>
</li>
<li><p>使用 String.valueof(aPrimitive)</p>
</li>
<li><p>使用toString()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer.toString(anInt)Double.toString(aDouble)Character.toString(aChae)Boolean.toString(aBoolean)</span><br></pre></td></tr></table></figure></li>
<li><p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str1=<span class="number">123</span>+<span class="string">&quot;&quot;</span>;  <span class="comment">//int 123-&gt;String&quot;123&quot;String str2=12.34+&quot;&quot;;//double 12.34-&gt;String&quot;12.34&quot;String str3=&#x27;c&#x27;+&quot;&quot;;//char&#x27;c&#x27;-&gt;String &quot;c&quot;String str4=true+&quot;&quot;;//boolean true-&gt;String&quot;true&quot;//Using String.valueOf(aPrimitive)(applicable to ALL primitive types)String str5=String.valueOf(12345);//int 12345-&gt;String&quot;12345&quot;String str6=String.valueOf(true);//boolean true-&gt;String&quot;true&quot;String str7=String.valueOf(55.66)//double 55.66-&gt;String&quot;55.66&quot;//Using toString() for each primitive typeString str8=Integer.toString(1234);//int 1234-&gt;String &quot;1234&quot;String str9=Double.toString(1.23);//double 1.23-&gt;String &quot;1.23&quot;String str10=Character.toString(&quot;z&quot;);//char&#x27;z&#x27;-&gt;String &quot;z&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-3-3-Formatting-Strings"><a href="#2-3-3-Formatting-Strings" class="headerlink" title="2.3.3 Formatting Strings"></a>2.3.3 Formatting Strings</h3><ul>
<li>String.format() 返回字符串的格式</li>
<li>String.format() print()时有相同的格式</li>
<li>字符串逆序输出：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        String inStr;        <span class="keyword">int</span> inStrlen;        Scanner in=<span class="keyword">new</span> Scanner(System.in);        System.out.print(<span class="string">&quot;Enter a String&quot;</span>);        inStr=in.next();        inStrlen=inStr.length();        System.out.println(<span class="string">&quot;The reverse is:&quot;</span>);        <span class="keyword">for</span>(<span class="keyword">int</span> inCharIdx=inStrlen-<span class="number">1</span>;inCharIdx&gt;=<span class="number">0</span>;--inCharIdx)        &#123;            System.out.print(inStr.charAt(inCharIdx));        &#125;        in.close();    &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>二进制转十进制：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;<span class="keyword">import</span> javafx.scene.chart.LineChart;<span class="keyword">import</span> java.util.Scanner;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        String binStr;        <span class="keyword">int</span> binStrlen;        <span class="keyword">int</span> dec=<span class="number">0</span>;        <span class="keyword">char</span> binChar;        Scanner in=<span class="keyword">new</span> Scanner(System.in);        System.out.print(<span class="string">&quot;Enter a binary string :&quot;</span>);        binStr=in.next();        binStrlen=binStr.length();        <span class="keyword">for</span>(<span class="keyword">int</span> exp=<span class="number">0</span>;exp&lt;binStrlen;++exp)&#123;            binChar=binStr.charAt(binStrlen-<span class="number">1</span>-exp);            <span class="keyword">if</span> (binChar==<span class="string">&#x27;1&#x27;</span>)&#123;                dec+=(<span class="keyword">int</span>)Math.pow(<span class="number">2</span>,exp);            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(binChar==<span class="string">&#x27;0&#x27;</span>)&#123;                            &#125;            <span class="keyword">else</span> &#123;                System.out.println((<span class="string">&quot;error:invalid bonary string\&quot;&quot;</span>+binStr+<span class="string">&quot;\&quot;&quot;</span>));                <span class="keyword">return</span>;            &#125;        &#125;        System.out.println(<span class="string">&quot;The equivalent decimal for\&quot;&quot;</span>+binStr+<span class="string">&quot;\&quot;is &quot;</span>+dec);        in.close();    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-数组"><a href="#2-4-数组" class="headerlink" title="2.4 数组"></a>2.4 数组</h2><p>建数组前要知道它的长度并根据它的长度分配空间。</p>
<p>一旦数组被建立了，在运行时就不能在改变它的长度了。</p>
<ul>
<li><p>Enhanced for-loop</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] numbers=&#123;<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;<span class="keyword">int</span> sum=<span class="number">0</span>;sumSq=<span class="number">0</span>;<span class="keyword">for</span>(<span class="keyword">int</span> number:numbers)&#123;    sum+=number;    sumSq+=number*number;&#125;System.out.println(<span class="string">&quot;The sum is:&quot;</span>+sum);System.out.println(<span class="string">&quot;The square sum is:&quot;</span>+sumSq);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-4-1-创建数组"><a href="#2-4-1-创建数组" class="headerlink" title="2.4.1 创建数组"></a>2.4.1 创建数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] s;s=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">26</span>];<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;s[i]=(<span class="keyword">char</span>)(<span class="string">&#x27;A&#x27;</span>+i);&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-2-创建类的数组"><a href="#2-4-2-创建类的数组" class="headerlink" title="2.4.2 创建类的数组"></a>2.4.2 创建类的数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point[] p;p=<span class="keyword">new</span> Point[<span class="number">10</span>];<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;p[i]=<span class="keyword">new</span> Point(i,i+<span class="number">1</span>);&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-3-初始化数组"><a href="#2-4-3-初始化数组" class="headerlink" title="2.4.3 初始化数组"></a>2.4.3 初始化数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] names;names=<span class="keyword">new</span> String[<span class="number">3</span>];names[<span class="number">0</span>]=<span class="string">&quot;Georgianna&quot;</span>;names[<span class="number">1</span>]=<span class="string">&quot;Jen&quot;</span>;names[<span class="number">2</span>]=<span class="string">&quot;Simon&quot;</span>;String[] names=&#123;<span class="string">&quot;Georfianna&quot;</span>,<span class="string">&quot;Jen&quot;</span>,<span class="string">&quot;Simon&quot;</span>&#125;;MyDate[]dates;dates=<span class="keyword">new</span> MyDate[<span class="number">3</span>];dates[<span class="number">0</span>]=<span class="keyword">new</span> MyDate(<span class="number">22</span>,<span class="number">7</span>,<span class="number">1964</span>);dates[<span class="number">1</span>]=<span class="keyword">new</span> MyDate(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2000</span>);dates[<span class="number">3</span>]=<span class="keyword">new</span> MyDate(<span class="number">22</span>,<span class="number">12</span>,<span class="number">1964</span>);MyDate[] dates=&#123;<span class="keyword">new</span> MyDate(<span class="number">22</span>,,<span class="number">1964</span>),<span class="keyword">new</span> MyDate(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2000</span>),<span class="keyword">new</span> MyDate(<span class="number">22</span>,<span class="number">12</span>,<span class="number">1964</span>)&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-4-读数组"><a href="#2-4-4-读数组" class="headerlink" title="2.4.4 读数组"></a>2.4.4 读数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.print(<span class="string">&quot;The values are:[&quot;</span>);<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;item.length;i++)&#123;	<span class="keyword">if</span>(i==<span class="number">0</span>)&#123;	System.out.print(items[<span class="number">0</span>]);	&#125;<span class="keyword">else</span>&#123;	System.out.print(<span class="string">&quot;, &quot;</span>+items[i]);	&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-5-数组转字符串"><a href="#2-4-5-数组转字符串" class="headerlink" title="2.4.5 数组转字符串"></a>2.4.5 数组转字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a1=&#123;<span class="number">6</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="keyword">int</span>[] a2=&#123;&#125;;<span class="keyword">double</span>[] a3=<span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">1</span>];System.out.println(Arrays.toString(a1));System.out.println(Arrays.toString(a2));System.out.println(Arrays.toSting(a3));</span><br></pre></td></tr></table></figure>

<h3 id="2-4-6-多维数组"><a href="#2-4-6-多维数组" class="headerlink" title="2.4.6 多维数组"></a>2.4.6 多维数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1int[][]=twoDim=new int[4][];twoDim[0]=new int[5];twoDim[1]=new int[5];//errint[][] twoDim=new int[][4]; //illegal//2int[][] twoDim=new int[4][5];</span></span><br></pre></td></tr></table></figure>



<ul>
<li>exercise:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;<span class="keyword">import</span> javafx.scene.chart.LineChart;<span class="keyword">import</span> java.util.Scanner;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;       <span class="keyword">int</span>[][] grid=&#123;               &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,               &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,               &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;       &#125;;       <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;grid.length;++y)&#123;           <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;grid[y].length;++x)&#123;               System.out.printf(<span class="string">&quot;%2d&quot;</span>,grid[y][x]);           &#125;           System.out.println();       &#125;       <span class="keyword">int</span> [][] grid1=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][];       grid1[<span class="number">0</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];       grid1[<span class="number">1</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];       grid1[<span class="number">2</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];       <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt; grid1.length;++y)&#123;           <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;grid[y].length;++x)&#123;               System.out.printf(<span class="string">&quot;2d&quot;</span>,grid[y][x]);           &#125;            System.out.println();       &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>运行结果：</li>
</ul>
<p> 1 2<br> 3 4 5<br> 6 7 8 9<br>2d2d<br>2d2d2d<br>2d2d2d2d</p>
<h1 id="3-方法"><a href="#3-方法" class="headerlink" title="3.方法"></a>3.方法</h1><p>class_4_method.pptx</p>
<h2 id="3-1过程"><a href="#3-1过程" class="headerlink" title="3.1过程"></a>3.1过程</h2><ol>
<li><p>caller 寻找方法，然后把参数传递给方法</p>
</li>
<li><p>方法：</p>
<p>a)接受从caller传递的参数</p>
<p>b)执行方法并将结果传回caller</p>
</li>
<li><p>caller接受结果，并且继续它的操作</p>
</li>
</ol>
<h2 id="3-2例"><a href="#3-2例" class="headerlink" title="3.2例"></a>3.2例</h2><ol>
<li></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">double</span> r = <span class="number">1.1</span>, area, area2;        area = getArea(r);        System.out.println(<span class="string">&quot;area 1 is: &quot;</span> + area);        area2 = getArea(<span class="number">2.2</span>);        System.out.println(<span class="string">&quot;area 2 is: &quot;</span>+area2);        System.out.println(<span class="string">&quot;area 3 is: &quot;</span>+getArea(<span class="number">3.3</span>));    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">(<span class="keyword">double</span> radius)</span></span>&#123;        <span class="keyword">return</span> radius*radius*Math.PI;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>output</p>
<p>area 1 is: 3.8013271108436504<br>area 2 is: 15.205308443374602<br>area 3 is: 34.21194399759284</p>
</li>
</ul>
<ol start="2">
<li>Magic Number</li>
</ol>
<h2 id="3-3方法的语法"><a href="#3-3方法的语法" class="headerlink" title="3.3方法的语法"></a>3.3方法的语法</h2><h3 id="3-3-1-形参与实参"><a href="#3-3-1-形参与实参" class="headerlink" title="3.3.1 形参与实参"></a>3.3.1 形参与实参</h3><ol>
<li>原语类型参数的传递值 </li>
<li>通过数组或者对象传递引用类型</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="keyword">int</span>[] testArray = &#123;<span class="number">9</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;        System.out.println(<span class="string">&quot;In caller, before calling the method, aray is:&quot;</span> + Arrays.toString(testArray));        increment(testArray);        System.out.println(<span class="string">&quot;Inside method, after calling the method, array is &quot;</span>+Arrays.toString(testArray));        &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;        System.out.println(<span class="string">&quot;Inside method, before operation, array is &quot;</span> + Arrays.toString(array));        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)++array[i];        System.out.println(<span class="string">&quot;Inside method, after operation, array is &quot;</span>+Arrays.toString(array));    &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>output</li>
</ul>
<p>In caller, before calling the method, aray is:[9, 5, 6, 1, 4]<br>Inside method, before operation, array is [9, 5, 6, 1, 4]<br>Inside method, after operation, array is [10, 6, 7, 2, 5]<br>Inside method, after calling the method, array is [10, 6, 7, 2, 5]</p>
<h4 id="3-3-1-1"><a href="#3-3-1-1" class="headerlink" title="3.3.1.1"></a>3.3.1.1</h4><ul>
<li>JDK5引入了变量参数（或varargs）和新语法“Type…”。 </li>
<li>Varargs只能用于最后一个参数。 </li>
<li>三个点（…）表示最后一个参数可以作为数组或逗号分隔的参数序列传递。</li>
<li>编译器会自动将vararg打包到一个数组中。然后，可以在方法体中检索和处理这些参数中的每一个作为数组。</li>
</ul>
<h5 id="3-3-1-1-1例"><a href="#3-3-1-1-1例" class="headerlink" title="3.3.1.1.1例"></a>3.3.1.1.1例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String...strs)</span></span>&#123;    System.out.print(<span class="string">&quot;Arguments are: &quot;</span>);     <span class="keyword">for</span> (String s:strs) &#123;         System.out.print(s+<span class="string">&quot;, &quot;</span>);     &#125;     System.out.println();    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String s1,String s2)</span></span>&#123;    System.out.println(<span class="string">&quot;Overloaded version with 2 args: &quot;</span>+s1+<span class="string">&quot;, &quot;</span>+s2);    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String...args)</span></span>&#123;        doSomething(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;again&quot;</span>,<span class="string">&quot;and&quot;</span>,<span class="string">&quot;again&quot;</span>);        doSomething(<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;world&quot;</span>);        String[] strs=&#123;<span class="string">&quot;apple&quot;</span>,<span class="string">&quot;orange&quot;</span>&#125;;        doSomething(strs);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>Arguments are: Hello, world, again, and, again,<br>Overloaded version with 2 args: Hello, world<br>Arguments are: apple, orange, </p>
<h2 id="3-4-方法的重载"><a href="#3-4-方法的重载" class="headerlink" title="3.4 方法的重载"></a>3.4 方法的重载</h2><p> 在Java中，一个方法（一个特定的方法名）可以有多个版本，每个版本对不同的参数集进行操作—称为方法重载。 </p>
<p> 版本应根据参数的编号、类型或顺序进行区分。 </p>
<h2 id="3-5方法的类型转换"><a href="#3-5方法的类型转换" class="headerlink" title="3.5方法的类型转换"></a>3.5方法的类型转换</h2><p>参数列表里含double的方法可以接受任何数值基元类型，如int或float。这是因为执行了隐式类型转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;       System.out.println(average(<span class="number">8</span>,<span class="number">6</span>));  <span class="comment">//1       System.out.println(average(8,6,9));//2       System.out.println(average(8.1,6.1));//3       System.out.println(average(8,6.1));//3    &#125;    public static int average(int n1,int n2)&#123;        System.out.println(&quot;------v1------&quot;);        return (n1+n2/2);    &#125;    public static int average(int n1,int n2,int n3)&#123;        System.out.println(&quot;------v2------&quot;);        return (n1+n2+n3)/3;    &#125;    public static double average(double n1,double n2)&#123;        System.out.println(&quot;------v3------&quot;);        return (n1+n2)/2.0;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>——v1——<br>11<br>——v2——<br>7<br>——v3——<br>7.1<br>——v3——<br>7.05</p>
<h2 id="3-6main"><a href="#3-6main" class="headerlink" title="3.6main"></a>3.6main</h2><h3 id="3-6-1命令行参数"><a href="#3-6-1命令行参数" class="headerlink" title="3.6.1命令行参数"></a>3.6.1命令行参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;       <span class="keyword">int</span> operand1,operand2;       <span class="keyword">char</span> theOperator;       operand1=Integer.parseInt(args[<span class="number">0</span>]);       operand2=Integer.parseInt(args[<span class="number">1</span>]);       theOperator=args[<span class="number">2</span>].charAt(<span class="number">0</span>);       System.out.print(args[<span class="number">0</span>]+args[<span class="number">2</span>]+args[<span class="number">1</span>]+<span class="string">&quot;=&quot;</span>);       <span class="keyword">switch</span> (theOperator)&#123;           <span class="keyword">case</span>(<span class="string">&#x27;+&#x27;</span>):System.out.println(operand1+operand2);<span class="keyword">break</span>;           <span class="keyword">case</span>(<span class="string">&#x27;-&#x27;</span>):System.out.println((operand1-operand2));<span class="keyword">break</span>;           <span class="keyword">case</span>(<span class="string">&#x27;*&#x27;</span>):System.out.println(operand1*operand2);<span class="keyword">break</span>;           <span class="keyword">case</span>(<span class="string">&#x27;/&#x27;</span>):System.out.println(operand1/operand2);<span class="keyword">break</span>;           <span class="keyword">default</span>:System.out.print(<span class="string">&quot;inError:invalid operator!&quot;</span>);       &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-7-内存"><a href="#3-7-内存" class="headerlink" title="3.7 内存"></a>3.7 内存</h2><h3 id="3-7-1-堆"><a href="#3-7-1-堆" class="headerlink" title="3.7.1 堆"></a>3.7.1 堆</h3><ul>
<li><p>堆空间被java运行时用来为<strong>对象和JRE类</strong>分配内存。 </p>
</li>
<li><p>每当我们创建一个对象时，它总是在堆空间中创建的。 </p>
</li>
<li><p>垃圾回收在堆内存上运行，以释放没有任何引用的对象所使用的内存。 </p>
</li>
</ul>
<h3 id="3-7-2-栈"><a href="#3-7-2-栈" class="headerlink" title="3.7.2 栈"></a>3.7.2 栈</h3><ul>
<li><p>堆栈内存用于执行线程。 </p>
</li>
<li><p>它们包含特定于<strong>方法</strong>的短期值，以及对堆中从该方法引用的其他对象的引用。 </p>
</li>
<li><p>堆栈内存总是按后进先出的顺序引用。 </p>
</li>
<li><p>每当调用一个方法时，都会在堆栈内存中为该方法创建一个新块，以保存本地原语值和对该方法中其他对象的引用。 </p>
</li>
<li><p>一旦该方法结束，该块就变得不可用，并可用于下一个方法。 </p>
</li>
</ul>
<h3 id="3-7-3-Overview"><a href="#3-7-3-Overview" class="headerlink" title="3.7.3 Overview"></a>3.7.3 Overview</h3><p> 1.堆内存由应用程序的所有部分使用，而堆栈内存仅由一个执行线程使用。 </p>
<p> 2.每当创建对象时，它总是存储在堆空间中，堆栈内存包含对它的引用。堆栈内存只包含本地原语变量和堆空间中对象的引用变量。 </p>
<p> 3.堆中存储的对象是全局可访问的，而堆栈内存不能被其他线程访问。 </p>
<p> 4.当堆栈内存满时，Java运行时抛出Java.lang.StackOverflowerError，而如果堆内存满，则抛出Java.lang.OutOfMemoryError:Java堆空间错误。 </p>
<h3 id="3-7-4-堆栈跟踪"><a href="#3-7-4-堆栈跟踪" class="headerlink" title="3.7.4 堆栈跟踪"></a>3.7.4 堆栈跟踪</h3><p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210606135250614.png" alt="image-20210606135250614"></p>
<ul>
<li><p>堆栈跟踪是一个异常列表（或“原因”），从最表面的异常（如服务层异常）到最深层的异常（如数据库异常）。 </p>
</li>
<li><p>就像我们称之为“stack”的原因是因为stack是先进先出（FILO），最深的异常在一开始就发生了，然后一系列的异常产生了一系列的后果，表面异常是最后一个及时发生的异常，但是我们在第一时间看到了它。 </p>
</li>
</ul>
<p>关键1：这里需要理解的一件棘手而重要的事情是：最深层的原因可能不是“根本原因”，因为如果你写了一些“坏代码”，它可能会导致一些比它的层更深的异常。</p>
<p>关键2：另一个棘手但重要的事情是在每个“原因”块内，第一行是最深的一层，发生在这个块的第一位。</p>
<h2 id="3-8-debug"><a href="#3-8-debug" class="headerlink" title="3.8 debug"></a>3.8 debug</h2><ul>
<li>Compilation Error (or Syntax Error):</li>
<li>Runtime Error: </li>
<li>Logical Error:</li>
</ul>
<h1 id="4-面向对象"><a href="#4-面向对象" class="headerlink" title="4.面向对象"></a>4.面向对象</h1><p>class_5_oop_1.pptx</p>
<p>class_6_oop_2.pptx</p>
<p>class_7_oop_3.pptx</p>
<h2 id="4-1OOP"><a href="#4-1OOP" class="headerlink" title="4.1OOP"></a>4.1OOP</h2><h3 id="4-1-1-class"><a href="#4-1-1-class" class="headerlink" title="4.1.1 class"></a>4.1.1 class</h3><ul>
<li>组成：</li>
</ul>
<p>​    名称</p>
<p>​    变量</p>
<p>​    方法</p>
<h3 id="4-1-2-语法"><a href="#4-1-2-语法" class="headerlink" title="4.1.2  语法"></a>4.1.2  语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[AccessControlModifier] <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>&#123;    <span class="comment">//class body contains members(variables and methods)    ......&#125;</span></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210607130443432.png" alt="image-20210607130443432"></p>
<h3 id="4-1-2-1-成员变量与方法"><a href="#4-1-2-1-成员变量与方法" class="headerlink" title="4.1.2.1 成员变量与方法"></a>4.1.2.1 成员变量与方法</h3><h4 id="4-1-2-1-1-静态成员"><a href="#4-1-2-1-1-静态成员" class="headerlink" title="4.1.2.1.1 静态成员"></a>4.1.2.1.1 静态成员</h4><p>keyword:static</p>
<h3 id="4-1-2-2-构造函数"><a href="#4-1-2-2-构造函数" class="headerlink" title="4.1.2.2 构造函数"></a>4.1.2.2 构造函数</h3><ul>
<li><p> 构造函数是一种特殊的方法，它的方法名与类名相同 </p>
</li>
<li><p> 构造函数方法不同于普通方法： </p>
</li>
<li><p> 这个 名称 构造函数方法的名称必须与类名相同。 </p>
</li>
<li><p> 构造函数的方法标题中没有返回类型。它隐式返回void。 </p>
</li>
<li><p> 构造函数只能通过“new”操作符调用。 </p>
</li>
<li><p> 它只能用于初始化构造的实例一次。一旦构造了实例，就不能再调用构造函数了。 </p>
</li>
<li><p> 构造函数是不继承的。每个类都应该定义自己的构造函数。 </p>
</li>
<li><p> 默认构造函数： 没有参数的构造函数称为 默认构造函数。它将成员变量初始化为其默认值。 </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;    <span class="keyword">private</span> <span class="keyword">double</span> radius;    <span class="keyword">private</span> String color;    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span> </span>&#123;        radius = <span class="number">1.0</span>;        color = <span class="string">&quot;red&quot;</span>;    &#125;    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> r)</span></span>&#123;        radius =r;        color=<span class="string">&quot;red&quot;</span>;    &#125;    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> r, String c)</span></span>&#123;        radius=r;        color=c;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span></span>&#123;        <span class="keyword">return</span> radius;    &#125;    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span></span>&#123;        <span class="keyword">return</span> color;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span></span>&#123;        <span class="keyword">return</span> radius*radius*Math.PI;    &#125;&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;       Circle c1=<span class="keyword">new</span> Circle(<span class="number">2.0</span>,<span class="string">&quot;blue&quot;</span>);       System.out.println(c1.getRadius());       System.out.println(c1.getColor());       System.out.println(c1.getArea());       Circle c2=<span class="keyword">new</span> Circle(<span class="number">2.0</span>);       System.out.println(c2.getRadius());       System.out.println(c2.getColor());       System.out.println(c2.getArea());       Circle c3=<span class="keyword">new</span> Circle();       System.out.println(c3.getRadius());       System.out.println(c3.getColor());       System.out.println(c3.getArea());    &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>2.0<br>blue<br>12.566370614359172<br>2.0<br>red<br>12.566370614359172<br>1.0<br>red<br>3.141592653589793</p>
<p>Process finished with exit code 0</p>
<h4 id="4-1-2-3-方法重载"><a href="#4-1-2-3-方法重载" class="headerlink" title="4.1.2.3 方法重载"></a>4.1.2.3 方法重载</h4><ul>
<li><p>方法重载意味着同一方法名可以有不同的实现（版本）。 </p>
</li>
<li><p>不同的实现必须通过其参数列表（参数的数量、类型或顺序）来区分。 </p>
</li>
<li><p>重载类的构造函数 :构造函数和普通方法一样，也可以重载。 </p>
</li>
<li><p>根据调用方法时使用的实际参数列表，将调用匹配的构造函数。 </p>
</li>
<li><p>如果参数列表与其中任何一个方法都不匹配，则会出现编译错误。 </p>
</li>
</ul>
<h3 id="4-1-3-access"><a href="#4-1-3-access" class="headerlink" title="4.1.3 access"></a>4.1.3 access</h3><p> 访问控制修饰符可用于控制类、成员变量或类内成员方法的可见性。 </p>
<p> public：系统中的所有其他对象都可以访问和使用类/变量/方法。 </p>
<p> private：类/变量/方法只能在此类中访问和使用。 </p>
<h3 id="4-1-5-“this”"><a href="#4-1-5-“this”" class="headerlink" title="4.1.5 “this”"></a>4.1.5 “this”</h3><h3 id="4-1-6-toString"><a href="#4-1-6-toString" class="headerlink" title="4.1.6 toString"></a>4.1.6 toString</h3><p>可以通过调用instanceName.toString（）显式调用toString（）方法，也可以通过println（）或字符串连接运算符“+”隐式调用。也就是说，运行println（实例）会隐式调用该实例的toString（）方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;    <span class="keyword">return</span> <span class="string">&quot;Circle[raius=&quot;</span>+radius+<span class="string">&quot;,color=&quot;</span>+color+<span class="string">&quot;]&quot;</span>;&#125;Circle c4= <span class="keyword">new</span> Circle();System.out.println(c4.toString())<span class="comment">//显示调用  c4.toString()    System.out.println(c4);//隐式调用c4.toString()System.out.println(&quot;c4 is:&quot;+c4);</span></span><br></pre></td></tr></table></figure>

<h3 id="4-1-7-常量"><a href="#4-1-7-常量" class="headerlink" title="4.1.7 常量"></a>4.1.7 常量</h3><p> final修饰常量</p>
<p> 常量是用final修饰符定义的变量。最后一个变量只能赋值一次，赋值后不能修改其值。 </p>
<p> 期末考试的高级笔记： </p>
<p> 1.常量基本变量不能重新赋值。 </p>
<p> 2.常量实例不能重新分配新对象。 </p>
<p> 3.常量类不能被继承（或被扩展）。 </p>
<p> 4.不能重写final方法。 </p>
<h2 id="4-2-Composition"><a href="#4-2-Composition" class="headerlink" title="4.2 Composition"></a>4.2 Composition</h2><h2 id="4-3-继承"><a href="#4-3-继承" class="headerlink" title="4.3 继承"></a>4.3 继承</h2><p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210608154248413.png" alt="image-20210608154248413"></p>
<p>继承结构是树状的。</p>
<h3 id="4-3-1-“extends”关键字"><a href="#4-3-1-“extends”关键字" class="headerlink" title="4.3.1 “extends”关键字"></a>4.3.1 “extends”关键字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoalKeeper</span> <span class="keyword">extends</span> <span class="title">SccoerPlayer</span></span>&#123;......&#125;<span class="class"><span class="keyword">class</span> <span class="title">MyApplet</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">applet</span>.<span class="title">Applet</span></span>&#123;......&#125;<span class="class"><span class="keyword">class</span> <span class="title">Cylinder</span> <span class="keyword">extends</span> <span class="title">Circle</span></span>&#123;......&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210608154613133.png" alt="image-20210608154613133"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;<span class="keyword">import</span> com.sun.org.apache.bcel.internal.generic.NEW;<span class="keyword">import</span> com.sun.org.apache.xpath.internal.objects.XString;<span class="keyword">import</span> javafx.scene.chart.LineChart;<span class="keyword">import</span> kotlin.jvm.internal.FunctionReferenceImpl;<span class="keyword">import</span> kotlin.text.UStringsKt;<span class="keyword">import</span> javax.print.attribute.standard.RequestingUserName;<span class="keyword">import</span> java.util.*;<span class="keyword">import</span> java.lang.reflect.Array;<span class="keyword">import</span> java.util.Arrays;<span class="keyword">import</span> java.util.Arrays;<span class="keyword">import</span> java.util.List;<span class="keyword">import</span> java.util.ArrayList;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;        <span class="keyword">private</span> <span class="keyword">double</span> radius;        <span class="keyword">private</span> String color;        <span class="function"><span class="keyword">public</span> <span class="title">test1</span><span class="params">()</span></span>&#123;            <span class="keyword">this</span>.radius=<span class="number">1.0</span>;            <span class="keyword">this</span>.color=<span class="string">&quot;red&quot;</span>;            System.out.println(<span class="string">&quot;Constructed a test1 with test1()&quot;</span>);        &#125;        <span class="function"><span class="keyword">public</span> <span class="title">test1</span><span class="params">(<span class="keyword">double</span> raiuds)</span></span>&#123;            <span class="keyword">this</span>.radius=radius;            <span class="keyword">this</span>.color=<span class="string">&quot;red&quot;</span>;            System.out.println(<span class="string">&quot;Constructed a test1 with test1(radius)&quot;</span>);        &#125;        <span class="function"><span class="keyword">public</span> <span class="title">test1</span><span class="params">(<span class="keyword">double</span> radius,String color)</span></span>&#123;            <span class="keyword">this</span>.radius=radius;            <span class="keyword">this</span>.color=color;            System.out.println(<span class="string">&quot;Constructed a test1 with test1(radius,color)&quot;</span>);        &#125;        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRadius</span><span class="params">()</span></span>&#123;            <span class="keyword">return</span> <span class="keyword">this</span>.radius;        &#125;        <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span></span>&#123;            <span class="keyword">return</span> <span class="keyword">this</span>.color;        &#125;        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">double</span> radius)</span></span>&#123;            <span class="keyword">this</span>.radius=radius;        &#125;        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span></span>&#123;            <span class="keyword">this</span>.color=color;        &#125;        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;            <span class="keyword">return</span> radius+<span class="string">&quot; &quot;</span>+color;        &#125;        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123;            <span class="keyword">return</span> radius * radius * Math.PI;        &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Cylinder cy1 = <span class="keyword">new</span> Cylinder();        System.out.println(<span class="string">&quot;Radius is&quot;</span>+cy1.getRadius()+<span class="string">&quot;,Height is &quot;</span>+cy1.getHeight()+<span class="string">&quot;,Color is &quot;</span>+cy1.getColor()+<span class="string">&quot;,Base area is &quot;</span>+cy1.getArea()+<span class="string">&quot;,Volume is &quot;</span>+cy1.getVolume());        Cylinder cy2=<span class="keyword">new</span> Cylinder(<span class="number">5.0</span>,<span class="number">2.0</span>);        System.out.println(<span class="string">&quot;Radius is &quot;</span>+cy2.getRadius()+<span class="string">&quot;,Height is &quot;</span>+cy2.getHeight()+<span class="string">&quot;,Color is &quot;</span>+cy2.getArea()+<span class="string">&quot;, Volume is &quot;</span>+cy2.getVolume());    &#125;&#125;<span class="keyword">package</span> test;<span class="keyword">import</span> javax.sound.midi.SysexMessage;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cylinder</span> <span class="keyword">extends</span> <span class="title">test1</span></span>&#123;    <span class="keyword">private</span> <span class="keyword">double</span> height;    <span class="function"><span class="keyword">public</span> <span class="title">Cylinder</span><span class="params">()</span> </span>&#123;        <span class="keyword">super</span>();        <span class="keyword">this</span>.height=<span class="number">1.0</span>;        System.out.println(<span class="string">&quot;Constructed a Cylinder with Cylinder()&quot;</span>);    &#125;    <span class="function"><span class="keyword">public</span> <span class="title">Cylinder</span><span class="params">(<span class="keyword">double</span> height)</span></span>&#123;        <span class="keyword">super</span>();        <span class="keyword">this</span>.height=height;        System.out.println(<span class="string">&quot;Constructed a Cylinder(height)&quot;</span>);    &#125;    <span class="function"><span class="keyword">public</span> <span class="title">Cylinder</span><span class="params">(<span class="keyword">double</span> height,<span class="keyword">double</span> radius)</span></span>&#123;        <span class="keyword">super</span>(radius);        <span class="keyword">this</span>.height=height;        System.out.println(<span class="string">&quot;Constructed a Cylinder with Cylinder(height,radius)&quot;</span>);    &#125;    <span class="function"><span class="keyword">public</span> <span class="title">Cylinder</span><span class="params">(<span class="keyword">double</span> height,<span class="keyword">double</span> radius,String color)</span></span>&#123;        <span class="keyword">super</span>(radius,color);        <span class="keyword">this</span>.height=height;        System.out.println(<span class="string">&quot;Constructed a Cylinder with Cylinder(height,radius,color)&quot;</span>);    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getHeight</span><span class="params">()</span></span>&#123;        <span class="keyword">return</span> <span class="keyword">this</span>.height;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">double</span> height)</span></span>&#123;        <span class="keyword">this</span>.height=height;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getVolume</span><span class="params">()</span></span>&#123;        <span class="keyword">return</span> getArea()*height;    &#125;    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;        <span class="keyword">return</span> <span class="string">&quot;this is a Cylinder&quot;</span>;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>Constructed a test1 with test1()<br>Constructed a Cylinder with Cylinder()<br>Radius is1.0,Height is 1.0,Color is red,Base area is 3.141592653589793,Volume is 3.141592653589793<br>Constructed a test1 with test1(radius)<br>Constructed a Cylinder with Cylinder(height,radius)<br>Radius is 0.0,Height is 5.0,Color is 0.0, Volume is 0.0</p>
<h2 id="4-4-方法重写-变量隐藏"><a href="#4-4-方法重写-变量隐藏" class="headerlink" title="4.4 方法重写+变量隐藏"></a>4.4 方法重写+变量隐藏</h2><p>子类从其超类（直接父类及其所有祖先）继承所有成员变量和方法。</p>
<p>它可以使用继承的方法和变量。</p>
<p>它还可以通过提供自己的版本来覆盖继承的方法，或者通过定义相同名称的变量来隐藏继承的变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cylinder</span> <span class="keyword">extends</span> <span class="title">Circle</span></span>&#123;	<span class="meta">@Override</span>	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span></span>&#123;        <span class="keyword">return</span> <span class="number">2</span>*Math.PI*get.Radius()*height+<span class="number">2</span>*<span class="keyword">super</span>.getArea();    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getVolume</span><span class="params">()</span></span>&#123;        <span class="keyword">return</span> <span class="keyword">super</span>.getArea()*height;    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;        <span class="keyword">return</span> <span class="string">&quot;Cylinder[&quot;</span>+<span class="keyword">super</span>.toString+<span class="string">&quot;,height&quot;</span>+height+<span class="string">&#x27;]&#x27;</span>;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>方法重载意味着相同的方法名称可以有不同的实现（版本）。</p>
<p>不同的实现必须通过其参数列表（参数的数量、参数类型或顺序）来区分。</p>
<p>超载 类“构造函数”</p>
<p>构造函数，就像一个普通方法一样，也可以重载。</p>
<p>根据调用方法时使用的实际参数列表，将调用匹配构造函数。</p>
<p>如果参数列表与任何方法不匹配，则会出现编译错误。</p>
<h3 id="4-4-1-重写变量"><a href="#4-4-1-重写变量" class="headerlink" title="4.4.1 重写变量"></a>4.4.1 重写变量</h3><p> “@Override”被称为annotation（在jdk1.5中引入），它要求编译器检查超类中是否存在要重写的方法。 </p>
<p> 如果将要重写的方法的名称拼写错误，这将非常有帮助。 </p>
<p> @重写注释是可选的，但是拥有它确实很好。 </p>
<h3 id="4-4-2-“super”关键字"><a href="#4-4-2-“super”关键字" class="headerlink" title="4.4.2 “super”关键字"></a>4.4.2 “super”关键字</h3><p>关键字this引用此实例。</p>
<p>关键字super指的是超类，它可以是直接父类或其祖先。</p>
<p>关键字super允许子类访问子类定义中的超类方法和变量。</p>
<p>超级变量名</p>
<p>超级方法（）</p>
<p>super（）和super（argumentList）可以用来调用超类的构造函数。</p>
<p>在构造函数的主体中，可以使用super（args）调用其直接超类的构造函数。</p>
<p>请注意，如果使用super（args），则它必须是子类构造函数中的第一个语句。</p>
<p>如果构造函数中没有使用它，Java编译器会自动插入一个super（）语句来调用其直接超类的no arg构造函数。</p>
<h3 id="4-4-3-单继承"><a href="#4-4-3-单继承" class="headerlink" title="4.4.3 单继承"></a>4.4.3 单继承</h3><ul>
<li><p>java不支持多重继承（C++）。</p>
</li>
<li><p>多重继承允许子类具有多个直接超类。</p>
</li>
</ul>
<p>​      如果超类对于同一方法有冲突的实现，那么这有一个严重的缺点。</p>
<ul>
<li>在Java中，每个子类只能有一个直接超类，即单继承。另一方面，一个超类可以有许多子类。</li>
</ul>
<h3 id="4-4-4-共同根类"><a href="#4-4-4-共同根类" class="headerlink" title="4.4.4 共同根类"></a>4.4.4 共同根类</h3><p> Java采用了所谓的公共根方法。 </p>
<p> 所有Java类都派生自一个名为Java.lang.Object的公共根类。 </p>
<p> 这个对象类定义并实现在JRE下运行的所有Java对象所需的公共行为。这些常见行为支持多线程和垃圾收集器等功能的实现。 </p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210608173134409.png" alt="image-20210608173134409"></p>
<p> 回想一下，重用现有类有两种方法：组合和继承。 </p>
<p> 组合呈现出一种“has-a”关系。 </p>
<p> 子类超类表现出所谓的“is-a”关系。 </p>
<p> 经验法则：在考虑继承之前，尽可能使用组合。仅当类之间存在明确的层次关系时才使用继承。 </p>
<h2 id="4-3-多态"><a href="#4-3-多态" class="headerlink" title="4.3 多态"></a>4.3 多态</h2><p>“多态性”一词的意思是“多种形式”。</p>
<p>它来自希腊语“poly”（意思是多）和“morphos”（意思是形式）。</p>
<p>可替代性</p>
<p>子类拥有其超类的所有属性和操作。</p>
<p>这意味着子类对象可以做它的超类可以做的任何事情。</p>
<p>因此，当需要一个超类实例时，我们可以替换一个子类实例，一切都会正常工作。</p>
<h3 id="4-3-1-Upcasting-amp-Downcasting"><a href="#4-3-1-Upcasting-amp-Downcasting" class="headerlink" title="4.3.1 Upcasting&amp;Downcasting"></a>4.3.1 Upcasting&amp;Downcasting</h3><p> Java中有两种类型转换： </p>
<p> 1.如上所述，通过<strong>类型转换运算符</strong>进行<strong>显式类型转换</strong></p>
<p> 2.如果没有<strong>精度损失，编译器自动执行隐式类型转换</strong>。 </p>
<p> 在Java中，如果尝试将的double、float或long值赋给int变量，则会得到编译“error:incompatible types:possible lossy conversion from double | float | long to int”。这是因为小数部分将被截断并丢失。 </p>
<h4 id="4-3-1-1-隐式类型转换与类型转换运算符"><a href="#4-3-1-1-隐式类型转换与类型转换运算符" class="headerlink" title="4.3.1.1 隐式类型转换与类型转换运算符"></a>4.3.1.1 隐式类型转换与类型转换运算符</h4><p>要将双精度值赋给int变量，需要调用所谓的类型转换运算符（以（int）doubleOperand的形式）对双精度操作数进行操作，并返回int中的截断值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显式类型转换double d =3.5;int i;i=(int)d;//隐式类型转换int i=3;double d;d=i;d=(double)i;double aDouble =55;double nought=0;</span></span><br></pre></td></tr></table></figure>



<p>下图显示了编译器执行隐式类型转换的顺序。</p>
<p>规则是将较小的类型提升为较大的类型，以防止精度损失，称为加宽转换。</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210608174703378.png" alt="image-20210608174703378"></p>
<h5 id="4-4-1-1-1-upcasting"><a href="#4-4-1-1-1-upcasting" class="headerlink" title="4.4.1.1.1 upcasting"></a>4.4.1.1.1 upcasting</h5><p> 将子类实例向上转换为超类引用 </p>
<p> 用子类实例替换其超类称为“向上投射”。 </p>
<p> 向上转换总是安全的，因为子类实例拥有 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Circle c1 = <span class="keyword">new</span> Cylinder(<span class="number">1.1</span>,<span class="number">2.2</span>);Circle c2 = <span class="keyword">new</span> String();</span><br></pre></td></tr></table></figure>

<h5 id="4-4-1-1-2-downcasting"><a href="#4-4-1-1-2-downcasting" class="headerlink" title="4.4.1.1.2 downcasting"></a>4.4.1.1.2 downcasting</h5><p> 向下转换对其原始类的替换引用 </p>
<p> 可以将替换的实例还原回子类引用。这被称为“向下投射”。 </p>
<p> 向下转换需要前缀运算符（new-type）形式的显式类型转换运算符。向下转换并不总是安全的，如果要向下转换的实例不属于正确的子类，则会引发运行时ClassCastException。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Circle c1= <span class="keyword">new</span> Cylinder(<span class="number">1.1</span>,<span class="number">2.3</span>);  <span class="comment">//upcast is safeCylinder cy1=(Cylinder)c1;  //downcast needs casting operator</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-2-“instanceof”运算符"><a href="#4-3-2-“instanceof”运算符" class="headerlink" title="4.3.2 “instanceof”运算符"></a>4.3.2 “instanceof”运算符</h3><p>Java提供了一个名为instanceof的二进制操作符，如果对象是特定类的实例，则返回true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Circle c1=<span class="keyword">new</span> Circle(); System.out.println(c1 <span class="keyword">instanceof</span> Circle); <span class="comment">//trueif(c1 instanceof Circle);&#123;......&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-3-总结"><a href="#4-3-3-总结" class="headerlink" title="4.3.3 总结"></a>4.3.3 总结</h3><p> <strong>多态性综述</strong> </p>
<p> 子类实例处理其超类的所有属性操作。当需要一个超类实例时，它可以被一个子类实例替换。换句话说，对一个类的引用可能包含该类的一个实例或者它的一个子类的一个实例，这被称为可替换性。 </p>
<p> 如果将子类实例分配给超类引用，则只能调用在超类中定义的方法。不能调用子类中定义的方法。 </p>
<p> 但是，被替换的实例在重写方法和隐藏变量方面保留了自己的标识。如果子类重写了超类中的方法，则将执行子类的版本，而不是超类的版本。 </p>
<p> <strong>动态绑定或后期绑定</strong> </p>
<p> 我们通常不把对象当作它自己的类型，而是当作它的基类型（超类或接口）。这允许您编写不依赖于特定实现类型的代码。 </p>
<p> 然而，这带来了一个新问题。编译器在编译时无法精确地知道在运行时将执行哪段代码（例如，getArea（）对于矩形和三角形有不同的实现）。 </p>
<p> 为了支持多态性，面向对象语言使用了一种不同的机制，称为动态绑定（或后期绑定或运行时绑定）。调用方法时，只在运行时确定要执行的代码。在编译过程中，编译器检查方法是否存在，并对参数和返回类型执行类型检查，但不知道在运行时执行哪段代码。 </p>
<p> 虽然动态绑定解决了支持多态性的问题，但它也带来了另一个新问题。编译器无法检查类型转换运算符是否安全。它只能在运行时进行检查（如果类型检查失败，则抛出ClassCastException）。 </p>
<p> JDK1.5引入了一个名为泛型的新特性来解决这个问题。 </p>
<h2 id="4-4-抽象类-amp-接口"><a href="#4-4-抽象类-amp-接口" class="headerlink" title="4.4 抽象类&amp;接口"></a>4.4 抽象类&amp;接口</h2><h3 id="4-4-1-抽象类"><a href="#4-4-1-抽象类" class="headerlink" title="4.4.1 抽象类"></a>4.4.1 抽象类</h3><p> 抽象方法和抽象类。 </p>
<p> 抽象方法是只有签名（即方法名、参数列表和返回类型）而没有实现（即方法体）的方法。您可以使用关键字abstract来声明抽象方法。 </p>
<p> 这些抽象方法的实现将在知道实际形状之后提供。无法调用这些抽象方法，因为它们没有实现。 </p>
<p> <strong>包含一个或多个抽象方法的类称为抽象类。抽象类必须用类修饰符抽象声明。抽象类不能实例化，因为它的定义不完整。</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;    ......    ......   <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span></span>;   <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPerimeter</span><span class="params">()</span></span>;   <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;&#125;<span class="keyword">abstract</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;    <span class="keyword">private</span> String color;    <span class="function"><span class="keyword">public</span> <span class="title">Shape</span><span class="params">(String color)</span></span>&#123;        <span class="keyword">this</span>.color=color;    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;        <span class="keyword">return</span> <span class="string">&quot;Shape[color&quot;</span>+color+<span class="string">&quot;]&quot;</span>;    &#125;    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span></span>;&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestShape</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        Shape s1= <span class="keyword">new</span> Rectangle(<span class="string">&quot;red&quot;</span>,<span class="number">4</span>,<span class="number">5</span>);        System.out.println(s1);        System.out.println(<span class="string">&quot;Area is&quot;</span>+s1.getArea());                Shape s2=<span class="keyword">new</span> Triangle(<span class="string">&quot;blue&quot;</span>,<span class="number">4</span>,<span class="number">5</span>);        Shape s3=<span class="keyword">new</span> Shape(<span class="string">&quot;green&quot;</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p> 要使用抽象类，必须从抽象类派生子类。在派生的子类中，必须重写抽象方法并为所有抽象方法提供实现。 </p>
<p> 派生的子类现在已经完成，并且可以实例化(如果子类没有为超类的所有抽象方法提供实现，那么子类仍然是抽象的。） </p>
<p> 再加上多态性，您可以将子类实例向上转换为Shape，并在Shape级别编程，即在接口上编程。 </p>
<p> 接口和实现的分离使得软件设计更好，易于扩展。 </p>
<p> <strong>经验法则：</strong> </p>
<p> 抽象方法不能声明为final，因为final方法不能被重写。另一方面，抽象方法必须在子类中重写才能使用。 </p>
<p> 抽象方法不能是私有的（这会生成编译错误）。这是因为私有方法对子类不可见，因此不能被重写。 </p>
<h3 id="4-4-2-接口"><a href="#4-4-2-接口" class="headerlink" title="4.4.2 接口"></a>4.4.2 接口</h3><p> Java接口是一个100%抽象的超类，它定义了它的子类必须支持的一组方法。 </p>
<p> 接口只包含公共抽象方法（带有签名但没有实现的方法）和可能的常量（公共静态最终变量）。 </p>
<p> 必须使用关键字“interface”来定义接口（而不是普通类的关键字“class”）。它的抽象方法不需要关键字public和abstract，因为它们是必需的。 </p>
<p> 与抽象超类类似，接口不能实例化。 </p>
<p> 您必须创建一个实现接口的“子类”，并提供所有抽象方法的实际实现。 </p>
<h4 id="4-4-2-1-“implements”关键字"><a href="#4-4-2-1-“implements”关键字" class="headerlink" title="4.4.2.1 “implements”关键字"></a>4.4.2.1 “implements”关键字</h4><ul>
<li><p>关键字“implements”派生子类。 </p>
<p>在Java中，抽象类和接口用于将类的公共接口与其实现分离开来，从而允许程序员在接口上而不是在各种实现上进行编程。 </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">interfacename</span> <span class="keyword">extends</span>  <span class="title">superinterfacename</span></span>&#123;     		<span class="keyword">static</span> <span class="keyword">final</span>...;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span></span>&#123;    <span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span></span>;&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;    <span class="keyword">private</span> <span class="keyword">int</span> length,width;    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(<span class="keyword">int</span> length,<span class="keyword">int</span> width)</span></span>&#123;        <span class="keyword">this</span>.length=lenth;        <span class="keyword">this</span>.width=width;    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;        <span class="keyword">return</span> <span class="string">&quot;Rectangle[length=&quot;</span>+length+<span class="string">&quot;, width=&quot;</span>+width+<span class="string">&quot;]&quot;</span>;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span></span>&#123;        <span class="keyword">return</span> length*width;    &#125;&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;     <span class="keyword">private</span> <span class="keyword">int</span> base,height;    <span class="function"><span class="keyword">public</span> <span class="title">Triangle</span><span class="params">(<span class="keyword">int</span> base,<span class="keyword">int</span> height)</span></span>&#123;        <span class="keyword">this</span>.base=base;        <span class="keyword">this</span>.height=height;    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;        <span class="keyword">return</span> <span class="string">&quot;Traingle[base=&quot;</span>+base+<span class="string">&quot;, height=&quot;</span>+height+<span class="string">&quot;]&quot;</span>;    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span></span>&#123;        <span class="keyword">return</span> <span class="number">0.5</span>*base*height;    &#125;&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestShape</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        Shape s1=<span class="keyword">new</span> Rectangle(<span class="number">1</span>,<span class="number">2</span>);        System.out.println(s1);        System.out.println(<span class="string">&quot;Area is &quot;</span>+ s1.getArea());        Shape s2=<span class="keyword">new</span> Traingle(<span class="number">3</span>,<span class="number">4</span>);        System.out.println(s2);                System.out.println(<span class="string">&quot;Area is &quot;</span>+s2.getArea());        Shape s3=<span class="keyword">new</span> Shape(<span class="string">&quot;green&quot;</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>Java只支持单个继承。也就是说，子类可以从一个和只有一个超类派生。Java不支持多继承，以避免从多个超类继承冲突的属性。 </p>
<p> 然而，子类可以实现多个接口。Java中允许这样做，因为接口只定义抽象方法而不需要实际实现，并且不太可能从多个接口继承冲突的属性。 </p>
<p> 换句话说，Java通过实现多个接口间接地支持多个继承。 </p>
<h2 id="4-5-静态变量-方法"><a href="#4-5-静态变量-方法" class="headerlink" title="4.5 静态变量/方法"></a>4.5 静态变量/方法</h2><ol>
<li><p>静态变量/方法属于类，它被所有实例共有，因此，它也被称为 类变量/方法。</p>
</li>
<li><p>非静态成员/方法属于一个类的实例，也被称为实例变量。</p>
</li>
<li><p>每一个实例都有它的存储空间。</p>
</li>
<li><p>每一个实例变量/方法都有它们自己在实例的副本，他们和其他实例共享。</p>
</li>
<li><p>静态变量/方法在类中有一个公共内存位置，由所有实例共享。 </p>
</li>
<li><p>JVM在类加载期间分配静态变量。即使没有创建实例，静态变量也存在。 </p>
<p>AClassName.aStaticVariableName或AClassName.aStaticMethodName（）。 </p>
</li>
<li><p>非静态变量/方法属于实例。要使用非静态变量/方法，必须首先构造实例。 </p>
</li>
<li><p>静态变量/方法属于类，它们本质上是“全局的”。在使用它们之前不需要构造任何实例。 </p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="keyword">public</span> <span class="keyword">int</span> count=<span class="number">0</span>;    <span class="keyword">private</span> <span class="keyword">double</span> radius;    <span class="function"><span class="keyword">public</span> <span class="title">test1</span><span class="params">(<span class="keyword">double</span> radius)</span></span>&#123;        <span class="keyword">this</span>.radius=radius;        ++count;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        test1 c1=<span class="keyword">new</span> test1(<span class="number">1.1</span>);        System.out.println(<span class="string">&quot;count: &quot;</span>+c1.count);        test1 c2=<span class="keyword">new</span> test1(<span class="number">2.2</span>);        System.out.println(<span class="string">&quot;count: &quot;</span>+c2.count);        test1 c3=<span class="keyword">new</span> test1(<span class="number">3.3</span>);        System.out.println(<span class="string">&quot;count: &quot;</span>+c3.count);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">0</span>;    <span class="keyword">private</span> <span class="keyword">double</span> radius;    <span class="function"><span class="keyword">public</span> <span class="title">test1</span><span class="params">(<span class="keyword">double</span> radius)</span></span>&#123;        <span class="keyword">this</span>.radius=radius;        ++count;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        test1 c1=<span class="keyword">new</span> test1(<span class="number">1.1</span>);        System.out.println(<span class="string">&quot;count: &quot;</span>+test1.count);        System.out.println(<span class="string">&quot;count &quot;</span>+c1.count);        test1 c2=<span class="keyword">new</span> test1(<span class="number">2.2</span>);        System.out.println(<span class="string">&quot;count &quot;</span>+c2.count);        System.out.println(<span class="string">&quot;count: &quot;</span>+test1.count);        test1 c3=<span class="keyword">new</span> test1(<span class="number">3.3</span>);        System.out.println(<span class="string">&quot;count &quot;</span>+c3.count);        System.out.println(<span class="string">&quot;count: &quot;</span>+test1.count);        System.out.println(<span class="string">&quot;count &quot;</span>+c1.count);        System.out.println(<span class="string">&quot;count &quot;</span>+c2.count);        System.out.println(<span class="string">&quot;count &quot;</span>+c3.count);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>count: 1<br>count 1<br>count 2<br>count: 2<br>count 3<br>count: 3<br>count 3<br>count 3<br>count 3</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610000544871.png" alt="image-20210610000544871"></p>
<p><strong>静态方法只能访问静态变量/方法，它不能访问非静态方法/变量。</strong></p>
<p><strong>但是非静态变量/方法静态和非静态的都可也访问</strong></p>
<p> 静态初始值设定项是标记为static的代码块。 </p>
<p> 加载类时，代码只执行一次。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="keyword">static</span> <span class="keyword">int</span> number; <span class="comment">//静态变量    static&#123;  //静态变量的初始化代码块，当类加载时，只运行一次。        number=88;        System.out.println(&quot;running static initializer&quot;);    &#125;    public static void main(String[] args)&#123;        System.out.println(&quot;running main()...&quot;);        System.out.println(&quot;number is&quot;+number);    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>running static initializer<br>running main()…<br>number is 88</p>
<h2 id="4-6final关键字"><a href="#4-6final关键字" class="headerlink" title="4.6final关键字"></a>4.6final关键字</h2><p>final可以声明类、变量或方法</p>
<p>fina类不能被继承（或被扩展）。</p>
<p>final方法不能在子类被重新</p>
<p>final变量不能重新赋值。</p>
<p> 原语类型与引用类型的<strong>最终变量</strong> </p>
<p> 原语类型的最终变量是常量，其值不能更改。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.141592653589793</span>;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> E = <span class="number">2.718281828459045</span>;</span><br></pre></td></tr></table></figure>



<p> 引用类型的最后一个变量（例如，类或数组的实例）不能重新分配新的引用。 </p>
<p> 也就是说，您可以修改实例的内容，但不能将变量重新分配给另一个实例。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        <span class="keyword">final</span> StringBuffer sb=<span class="keyword">new</span> StringBuffer(<span class="string">&quot;hello&quot;</span>);        sb.append(<span class="string">&quot;, world&quot;</span>);<span class="comment">//可以改变引用类型的内容        System.out.println(sb);        //sb=new StringBuffer(&quot;world peace&quot;); 报错，不能重新分配        final int[] numbers=&#123;11,22,33&#125;;//最终变量        numbers[0]=44;        System.out.println(java.util.Arrays.toString(numbers));    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>hello, world<br>[44, 22, 33]</p>
<h3 id="4-6-2-final-vs-abstract"><a href="#4-6-2-final-vs-abstract" class="headerlink" title="4.6.2 final vs abstract"></a>4.6.2 final vs abstract</h3><table>
<thead>
<tr>
<th>abstract</th>
<th>final</th>
</tr>
</thead>
<tbody><tr>
<td>abstract类必须扩展，实例化扩展类</td>
<td>final类不能被扩展</td>
</tr>
<tr>
<td>必须重写abstract方法</td>
<td>不能重写final方法</td>
</tr>
</tbody></table>
<h3 id="4-6-3-总结"><a href="#4-6-3-总结" class="headerlink" title="4.6.3 总结"></a>4.6.3 总结</h3><p> 在java， 类是同类对象的定义。 </p>
<p> a class是定义和描述 静态属性 和 动态行为 同一种类的所有物体所共有的。 </p>
<p> 实例 是 类的特定项的实现。 </p>
<p> 实例是一个 实例化 一个类的内容。 </p>
<p> 类的所有实例都具有类似的属性，如类定义中所述 “对象” </p>
<h2 id="4-7-包-引用-路径-JAR"><a href="#4-7-包-引用-路径-JAR" class="headerlink" title="4.7 包/引用/路径/JAR"></a>4.7 包/引用/路径/JAR</h2><p> 包用于： </p>
<ol>
<li><p>组织类和相关实体。 </p>
</li>
<li><p>管理名称空间-每个包都是一个名称空间。 </p>
</li>
<li><p>解决命名冲突。 </p>
</li>
</ol>
<p> 例如，com.zzz.Circle和com.yyy.Circle被视为两个不同的类。这两个类可以共存，甚至可以通过完全限定名在同一个程序中使用。 </p>
<ol start="3">
<li><p>访问控制：除了public和private之外，您只能将类/变量/方法的访问权授予同一包中的类。 </p>
</li>
<li><p>分发Java类：包中的所有实体都可以组合并压缩成一个文件，称为JAR（Java Archive）文件，用于分发。 </p>
</li>
</ol>
<h3 id="4-7-1-Package-Naming-Convention"><a href="#4-7-1-Package-Naming-Convention" class="headerlink" title="4.7.1 Package Naming Convention"></a>4.7.1 Package Naming Convention</h3><p> 包名由域的背面加上您自己组织的项目名（以点分隔）组成。 </p>
<p> com.zzz.project1.subproject2子项目 </p>
<p> java.lang或java.util </p>
<p> java.net或javax.net。 </p>
<p> 包名中的“点”对应于用于存储类文件的目录结构。 </p>
<p> 例如，com.zzz.Cat存储在目录“..\com\zzz\Cat.class”中 </p>
<p> com.yyy.project1.subproject2.Orange存储在目录“..\com\yyy\project1\subproject2\Orange.class”中 </p>
<h3 id="4-7-2-import-语句"><a href="#4-7-2-import-语句" class="headerlink" title="4.7.2 import 语句"></a>4.7.2 import 语句</h3><p>在源代码中引用类有两种方法：<br>使用packagename.classname形式的完全限定名（例如java.util.Scanner）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScannerNoImport</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        java.util.Scanner in = <span class="keyword">new</span> java.util.Scanner(System.in);        System.out.print(<span class="string">&quot;Enter an integer&quot;</span>);        <span class="keyword">int</span> number = in.nextInt();        System.out.println(<span class="string">&quot;You have entered &quot;</span>+number);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>在源文件的开头添加“import fully qualified name”语句。然后可以在源代码中单独使用类名（不使用包名）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScannerWithImport</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        Scanner in = <span class="keyword">new</span> Scanner(System.in);        System.out.print(<span class="string">&quot;Enter an integer&quot;</span>);        <span class="keyword">int</span> number = in.nextInt();        System.out.println(<span class="string">&quot;You have entered &quot;</span>+number);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>在JDK1.5中，还可以通过“import static”声明“导入”类的静态变量和方法—可以省略导入的静态变量/方法的类名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out;<span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestImportStatic</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        out.println(<span class="string">&quot;Hello, PI is&quot;</span>+PI);        out.println(<span class="string">&quot;Square root of PI is&quot;</span>+sqrt(PI));    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-7-3-JAR-java-Archive"><a href="#4-7-3-JAR-java-Archive" class="headerlink" title="4.7.3 JAR (java Archive)"></a>4.7.3 JAR (java Archive)</h3><p>As an example, the reference “A.b.c().d.e()” can be interpreted as follows:<br>“A” is a class.<br>“b” is a public static variable of class “A”<br>The variable “b” belongs to a class say “X”.<br>The class “X” provides a public method “c()”.<br>The “c()” method returns an instance “y” of class say “Y”.<br>The “Y” class has a variable (static or instance) called “d”.<br>The variable “d” belongs to a class say “Z”.<br>The class “Z” provides a public method called “e()”.</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610004832979.png" alt="image-20210610004832979"></p>
<h1 id="4-8-变量类型"><a href="#4-8-变量类型" class="headerlink" title="4.8 变量类型"></a>4.8 变量类型</h1><p>The type of a variable determines what kinds of value the variable can hold and what operations can be performed on the variable.<br>Primitive type: byte, short, int, long, float, double, char, and boolean.<br>Reference type: Reference types include class, interface, enum and array.<br>A special null type, holding a special null reference. </p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610004949662.png" alt="image-20210610004949662"></p>
<h3 id="4-8-1-变量作用域和生存期"><a href="#4-8-1-变量作用域和生存期" class="headerlink" title="4.8.1 变量作用域和生存期"></a>4.8.1 变量作用域和生存期</h3><p> 变量的作用域是指可以访问变量的代码部分。 </p>
<p> 自动变量（或局部变量） </p>
<p> 类的成员变量（或实例变量） </p>
<p> 类的静态变量（或类变量） </p>
<p> 生存期是指变量在内存中创建到被销毁（垃圾收集）的时间跨度。 </p>
<h2 id="4-9-方法重写-重装"><a href="#4-9-方法重写-重装" class="headerlink" title="4.9 方法重写/重装"></a>4.9 方法重写/重装</h2><ul>
<li>方法重写：</li>
</ul>
<ol>
<li><p>必须与<strong>原始参数列表相同。</strong></p>
</li>
<li><p>必须具有与其原始返回类型<strong>相同的返回类型或子类型</strong></p>
</li>
<li><p>访问修饰符的限制性不能比原始的多，但限制性可以更小，例如，可以将受保护的方法重写为公共方法。</p>
</li>
<li><p>重写私有方法没有意义，因为私有方法并不是由它的子类真正继承的。</p>
</li>
<li><p>从技术上讲，子类不会覆盖静态方法，而只是隐藏它。</p>
</li>
<li><p>无法重写final方法。抽象方法必须在实现子类中重写（否则，子类仍然是抽象的）。</p>
</li>
</ol>
<ul>
<li>方法重装：</li>
</ul>
<ol>
<li><p><strong>必须通过其参数列表进行区分</strong>。不应根据返回类型、异常列表或访问修饰符（生成编译错误）进行区分。</p>
</li>
<li><p>可以存在于原始类或其子类中。</p>
</li>
</ol>
<h2 id="4-10-jdk-api中常用的包"><a href="#4-10-jdk-api中常用的包" class="headerlink" title="4.10  jdk api中常用的包"></a>4.10  jdk api中常用的包</h2><p> JDK API is huge and consists of many packages:</p>
<ul>
<li>java.lang (the core JDK package): contains classes that are core to the language, e.g., System, String, Math, Object, Integer, and etc.</li>
<li>java.util: contains utilities such as Scanner, Random, Date, ArrayList, Vector, Hashtable.</li>
<li>java.io: contains input and output classes for reading files and I/O streams, such as File.</li>
<li>java.net: contains networking support, such as Socket and URL.</li>
<li>java.awt (Abstract Windowing Toolkit): contains classes for implementing a graphical user interface, including classes like Frame, Button, CheckBox.</li>
<li>java.awt.event: contains event handling classes, such as key-press, mouse-click etc.</li>
<li>java.swing: Advanced GUI classes, e.g., JFrame, JButton, JApplet, etc.</li>
<li>java.sql: contains classes for database programming, such as Connection, Statement, ResultSet.</li>
</ul>
<h2 id="4-11-基本类型的包装类"><a href="#4-11-基本类型的包装类" class="headerlink" title="4.11 基本类型的包装类"></a>4.11 基本类型的包装类</h2><p>Java语言的设计者保留了面向对象语言中的原语类型。</p>
<p>JDK提供了所谓的包装器类，这些包装器类将八种原语类型中的每一种原语值包装到对象中。</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610005608963.png" alt="image-20210610005608963"></p>
<p> 每个包装器类都有一个构造函数，该构造函数接受它包装的数据类型。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer aIntObj=<span class="keyword">new</span> Integer(<span class="number">5566</span>);<span class="comment">//Wrap a double primitive value into a Double objectDouble aDoubleObj=new Double(55.66);//Wrap a char primitive value into a Character objectCharacter aCharObj=new Character(&#x27;z&#x27;);////Wrap a Boolean primitive value into a Boolean objectBoolean aBooleanObj=new Boolean(true);</span></span><br></pre></td></tr></table></figure>

<p> 抽象超类号定义了要展开的以下xxxValue（）方法，这些方法在具体的子类Byte、Short、Integer、Long、Float和Double中实现。换句话说，您可以从Integer对象获得int或double值。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer intObj=<span class="keyword">new</span> Integer(<span class="number">56677</span>);<span class="keyword">int</span> i=intObj.intValue();<span class="keyword">short</span> s=intObj.shortVaue();<span class="comment">//truncatebyte b=intObj.byteValue();//truncateDOuble doubleObj=new Double(55.66);double d=doubleObj.doubleValue();int il=doubleObj.intValue();//truncateBoolean booleanObj=new Boolean(false);//Unwrapboolean b1=booleanObj.booleanValue();</span></span><br></pre></td></tr></table></figure>



<h2 id="4-12-autoboxing"><a href="#4-12-autoboxing" class="headerlink" title="4.12 autoboxing"></a>4.12 autoboxing</h2><p> JDK1.5引入了一个称为自动装箱和拆箱的新特性，编译器可以根据上下文自动为您进行包装和拆箱。 </p>
<p> 通过自动装箱和拆箱，您实际上可以忽略原语与其包装器对象之间的区别。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java SE 5.0Integer intObj=5566;//autobox from int to Integerint i=intObk;//auto-unbox from Integer to intDouble doubleObj=55.66;//autobox from double to Doubledouble d=doubleObj;//auto-unbox from Double to double</span></span><br></pre></td></tr></table></figure>

<h1 id="5-字符串-amp-枚举类型"><a href="#5-字符串-amp-枚举类型" class="headerlink" title="5. 字符串&amp;枚举类型"></a>5. 字符串&amp;枚举类型</h1><p>class_8_string_enum.pptx</p>
<h2 id="5-1-字符串"><a href="#5-1-字符串" class="headerlink" title="5.1 字符串"></a>5.1 字符串</h2><p> 文本字符串类型具有以下特征： </p>
<ul>
<li><p>不是原始数据类型；是一个类 </p>
</li>
<li><p>用双引号（“”）括起来 </p>
</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String greeting =<span class="string">&quot;Good Morning!\n&quot;</span>;String errorMessage=<span class="string">&quot;Record Not Found&quot;</span>;String str1,str2;String s1=<span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="5-1-1-字符串的方法"><a href="#5-1-1-字符串的方法" class="headerlink" title="5.1.1 字符串的方法"></a>5.1.1 字符串的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>       <span class="comment">// returns the length of the Stringboolean isEmpty()  // same as str.length() == 0boolean equals(String another) // CANNOT use &#x27;==&#x27; or &#x27;!=&#x27; to compare two Strings in Javaboolean equalsIgnoreCase(String another)int compareTo(String another)  // return 0 if this string is the same as another;boolean startsWith(String another)boolean startsWith(String another, int fromIdx)  // search begins at fromIdxboolean endsWith(String another)int indexOf(String key)int indexOf(String key, int fromIdx)int indexOf(int char)int indexOf(int char, int fromIdx)      // search forward starting at fromIdxchar charAt(int idx)String substring(int fromIdx)String toLowerCase()String toUpperCase()String concat(String another)  // same as str+anotherchar[] toCharArray() boolean matches(String regex)String replace(char old, char new)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>Java字符串是Java.lang.String类的对象。 </p>
</li>
<li><p>然而，Java字符串是特殊的。 </p>
</li>
<li><p>字符串以双引号文本的形式与字符串文本相关联，例如“hello，world”。 </p>
</li>
<li><p>“+”运算符重载以连接两个字符串操作数。 </p>
</li>
<li><p>字符串是不可变的。也就是说，它的内容一旦被创建就不能被修改。 </p>
</li>
<li><p>字符串在Java中受到特殊处理，因为它们在程序中经常使用。 </p>
</li>
<li><p><strong>原语存储在方法栈中</strong>，方法栈需要较少的存储空间，并且操作成本较低。 </p>
</li>
<li><p><strong>对象存储在程序堆中</strong>，这需要复杂的内存管理和更多的存储空间。 </p>
</li>
<li><p>出于性能考虑，Java的字符串被设计为介于原语和对象之间。 </p>
</li>
<li><p>字符串的特殊功能包括： </p>
</li>
</ul>
<ol>
<li><p>“+”运算符对原语（如int和double）执行加法，重载后可对字符串对象进行操作对两个字符串操作数执行串联。 </p>
<p>出于软件工程的考虑，Java不支持操作符重载。 </p>
<p>请注意，“+”不适用于任意两个对象，例如点或圆。 </p>
</li>
<li><p>字符串可以通过以下方式构造： </p>
<p>直接<strong>将字符串文字赋给字符串引用</strong>-就像原语一样 </p>
<p><strong>通过“new”操作符和构造函数</strong>，类似于任何其他类。</p>
</li>
<li><p>字符串文本存储在公共池中。通过new操作符分配的字符串对象存储在堆中 </p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="string">&quot;Hello&quot;</span>;<span class="comment">//String literalString s2=&quot;Hello&quot;;//String literalString s3=s1; //same referenceString s4=new String(&quot;Hello&quot;);//String ObjectString s5=new String(&quot;Hello&quot;);//String Object</span></span><br></pre></td></tr></table></figure>



<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210610220036743.png" alt="image-20210610220036743"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        String m_kobe=<span class="string">&quot;1&quot;</span>;        String[] m_king=&#123;<span class="string">&quot;2&quot;</span>&#125;;        mb_oprate(m_kobe,m_king);        System.out.println(m_kobe+m_king[<span class="number">0</span>]);    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mb_oprate</span><span class="params">(String kobe,String[] king)</span></span>&#123;        kobe=<span class="keyword">new</span> String(<span class="string">&quot;3&quot;</span>);        king[<span class="number">0</span>]=<span class="keyword">new</span> String(<span class="string">&quot;4&quot;</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>14</p>
<h3 id="5-1-2-字符串是不可变的"><a href="#5-1-2-字符串是不可变的" class="headerlink" title="5.1.2 字符串是不可变的"></a>5.1.2 字符串是不可变的</h3><p> 由于具有相同内容的字符串文本共享公共池中的存储，因此Java的字符串被设计为不可变的。 </p>
<p> 也就是说，一旦构造了字符串，就不能修改其内容。否则，共享同一存储位置的其他字符串引用将受到更改的影响，这可能是不可预测的，因此是不可取的。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        String str=<span class="string">&quot;Hello&quot;</span>;        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;            str=str+i;            System.out.println(str);        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>Hello123<br>Hello1234<br>Hello12345<br>Hello123456<br>Hello1234567<br>Hello12345678<br>Hello123456789</p>
<h2 id="5-2-StringBuffer-amp-StringBuilder"><a href="#5-2-StringBuffer-amp-StringBuilder" class="headerlink" title="5.2 StringBuffer&amp;StringBuilder"></a>5.2 StringBuffer&amp;StringBuilder</h2><ul>
<li>JDK提供了两个类来支持可变字符串：StringBuffer和StringBuilder </li>
</ul>
<p> （在核心包java.lang中）。 </p>
<ul>
<li><p>StringBuffer或StringBuilder对象与任何普通对象一样，它们存储在堆中，不共享，因此可以修改，而不会对其他对象造成不利的副作用。 </p>
</li>
<li><p>StringBuilder类是在JDK5中引入的。StringBuilder对于多线程操作不同步。 </p>
</li>
<li><p>然而，对于单线程程序，StringBuilder没有同步开销，效率更高。 </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.lang.StringBufferint length()StringBuffer append(type arg) StringBuffer insert(int offset, arg)StringBuffer delete(int fromIdx, int toIdx)StringBuffer deleteCharAt(int idx)void setLength(int newSize)void setCharAt(int idx, char newChar)StringBuffer replace(int fromIdx, int toIdx, String s)StringBuffer reverse()char charAt(int idx)String substring(int fromIdx)String substring(int fromIdx, int toIdx)String toString()int indexOf(String key)int indexOf(String key, int fromIdx)int lastIndexOf(String key)int lastIndexOf(String key, int fromIdx)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        <span class="keyword">int</span> year=<span class="number">2010</span>,month=<span class="number">10</span>,day=<span class="number">10</span>;        <span class="keyword">int</span> hour=<span class="number">10</span>,minute=<span class="number">10</span>,second=<span class="number">10</span>;        String dateStr=<span class="keyword">new</span> StringBuilder().append(year).append(<span class="string">&quot;-&quot;</span>).append(month).append(<span class="string">&quot;-&quot;</span>).append(day).append(<span class="string">&quot; &quot;</span>).append(hour).append(<span class="string">&quot;:&quot;</span>).append(minute).append(<span class="string">&quot;:&quot;</span>).append(second).toString();        System.out.println(dateStr);        String anotherDataStr=year+<span class="string">&quot;-&quot;</span>+month+<span class="string">&quot;-&quot;</span>+day+<span class="string">&quot; &quot;</span>+hour+<span class="string">&quot;:&quot;</span>+minute+<span class="string">&quot;:&quot;</span>+second;        System.out.println(anotherDataStr);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>2010-10-10 10:10:10<br>2010-10-10 10:10:10</p>
<ul>
<li><strong>经验法则</strong>：</li>
</ul>
<p>如果不修改字符串（因为它们在字符串公共池中共享），那么它们的效率会更高。</p>
<p>但是，如果必须经常修改字符串的内容（如状态消息），则应改用StringBuffer类（或下面描述的StringBuilder）。</p>
<p>StringBuilder的API与StringBuffer类兼容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        <span class="keyword">long</span> beginTime,elapsedTime;        String str=<span class="string">&quot;&quot;</span>;        <span class="keyword">int</span> size=<span class="number">16536</span>;        <span class="keyword">char</span> ch=<span class="string">&#x27;a&#x27;</span>;        beginTime=System.nanoTime();        <span class="keyword">for</span>(<span class="keyword">int</span> count=<span class="number">0</span>;count&lt;size;++count)&#123;            str+=ch;            ++ch;            <span class="keyword">if</span>(ch&gt;<span class="string">&#x27;z&#x27;</span>)&#123;                ch=<span class="string">&#x27;a&#x27;</span>;            &#125;        &#125;        elapsedTime=System.nanoTime()-beginTime;        System.out.println(<span class="string">&quot;Elapsed Time is:&quot;</span>+elapsedTime/<span class="number">1000</span>+<span class="string">&quot;usec(Build String&quot;</span>);        String strReverse=<span class="string">&quot;&quot;</span>;        beginTime=System.nanoTime();        <span class="keyword">for</span>(<span class="keyword">int</span> pos=str.length()-<span class="number">1</span>;pos&gt;=<span class="number">0</span>;pos--)&#123;            strReverse+=str.charAt(pos);<span class="comment">//Concatenate        &#125;        elapsedTime=System.nanoTime()-beginTime;        System.out.println(&quot;Elapsed Time is&quot;+elapsedTime/1000+&quot;usec(Using String to reverse&quot;);        beginTime=System.nanoTime();        StringBuffer sBufferReverse=new StringBuffer(size);        for(int pos=str.length()-1;pos&gt;=0;pos--)&#123;            sBufferReverse.append(str.charAt(pos));        &#125;        elapsedTime=System.nanoTime()-beginTime;        System.out.println(&quot;Elapsed Time is &quot;+elapsedTime/1000+&quot;usec(Using StringBuffer to reverse&quot;);        beginTime=System.nanoTime();        StringBuffer stringBufferReverseMethod=new StringBuffer(str);        stringBufferReverseMethod.reverse();        elapsedTime=System.nanoTime()-beginTime;        System.out.println(&quot;Elapsed Time is&quot;+elapsedTime/1000+&quot; usec (Using Stringbuffer&#x27;s reberse() method&quot;);        beginTime=System.nanoTime();        StringBuffer sBuilderReverse=new StringBuffer(size);        for(int pos=str.length()-1;pos&gt;=0;pos--)&#123;            sBuilderReverse.append(str.charAt(pos));        &#125;        elapsedTime=System.nanoTime()-beginTime;        System.out.println(&quot;Elapsed Time is &quot;+elapsedTime/1000+&quot; usec (Using StringBuilder to reverse)&quot;);        beginTime=System.nanoTime();        StringBuffer sBuilderReverseMethod=new StringBuffer(str);        sBuilderReverseMethod.reverse();        elapsedTime=System.nanoTime()-beginTime;        System.out.println(&quot;Elapsed Time is &quot;+elapsedTime/1000+ &quot; usec(Using StringBuilder&#x27;s reverse())&quot;);    &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>Elapsed Time is:447360usec(Build String<br>Elapsed Time is415946usec(Using String to reverse<br>Elapsed Time is 1171usec(Using StringBuffer to reverse<br>Elapsed Time is821 usec (Using Stringbuffer’s reberse() method<br>Elapsed Time is 1022 usec (Using StringBuilder to reverse)<br>Elapsed Time is 522 usec(Using StringBuilder’s reverse())</p>
<h2 id="5-2-枚举"><a href="#5-2-枚举" class="headerlink" title="5.2 枚举"></a>5.2 枚举</h2><p>枚举是一种特殊的类，因此你需要保存这个公共的枚举并命名为“EnumName.java”.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*enum&#123;ITEM1,ITEM2,..;&#125;*/</span><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">HandSign</span></span>&#123;    SCISSOR,PAPER,STONE;&#125;</span><br></pre></td></tr></table></figure>

<p> 枚举是一种特殊类型，它提供程序中常量的类型安全实现。 </p>
<p> 假设我们正在写一个剪刀纸石游戏。我们可以使用三个任意整数（例如，0，1，2；或88、128、168），三个字符串（“剪刀”、“纸”、“石头”）或三个字符（“s”、“p”、“t”）代表三个手势。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;<span class="keyword">import</span> java.util.ArrayList; <span class="comment">// 引入 ArrayList 类import java.util.Random;import java.text.DecimalFormat;import java.text.NumberFormat;import java.util.*;enum HandSign&#123;    SCISSOR,PAPER,STONE;&#125;public class test1&#123;    public static void main(String[] args)&#123;        Random random=new Random();        boolean gameover=false;        HandSign playerMover=HandSign.SCISSOR;        HandSign computeMove;        int numTrails=0;        int numComputerWon=0,numPlayerWon=0,numTie=0;        Scanner in=new Scanner(System.in);        System.out.println(&quot;Let us begin&quot;);        while(!gameover)&#123;            System.out.println(&quot;Scissor-paprt-stone&quot;);            boolean validInput;            do&#123;                System.out.println(&quot; show me your sign(Enter s for scissor, p for paper, t for stone, q to quit&quot;);                char inchar=in.next().toLowerCase().charAt(0);                validInput=true;                switch (inchar)&#123;                    case &#x27;q&#x27;:gameover=true;break;                    case &#x27;s&#x27;:playerMover=HandSign.SCISSOR;break;                    case &#x27;p&#x27;:playerMover=HandSign.PAPER;break;                    case &#x27;t&#x27;:playerMover=HandSign.STONE;break;                    default:                        System.out.println(&quot; Invalid input, try again&quot;);                        validInput=false;                &#125;            &#125;while (!validInput);            if(!gameover)&#123;                int rand=random.nextInt(3);                computeMove=HandSign.values()[rand];                System.out.println(&quot;My Sign is &quot;+computeMove);                if(computeMove==playerMover)&#123;                    System.out.println(&quot; Tie!&quot;);                    ++numTie;                &#125;else if(computeMove==HandSign.SCISSOR&amp;&amp;playerMover==HandSign.PAPER)&#123;                    System.out.println(&quot; Scissor cuts paper, I won&quot;);                    ++numComputerWon;                &#125;else if(computeMove==HandSign.PAPER&amp;&amp;playerMover==HandSign.STONE)&#123;                    System.out.println(&quot; Paper wraps stone, I won!&quot;);                    ++numComputerWon;                &#125;else if(computeMove==HandSign.STONE&amp;&amp;playerMover==HandSign.SCISSOR)&#123;                    System.out.println(&quot;Stonr breals Scissorr, I won&quot;);                    ++numComputerWon;                &#125;else &#123;                    System.out.println(&quot; You won!&quot;);                    ++numPlayerWon;                &#125;                ++numTrails;            &#125;        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p> 枚举是一种引用类型（就像类、接口和数组一样），它保存对堆中内存的引用。 </p>
<p> <strong>它是隐式的final，因为常量不应更改。</strong> </p>
<p> 它可以包含传统类的其他组件，例如构造函数、成员变量和方法。 </p>
<p> <strong>属性：</strong> </p>
<ol>
<li>枚举是类型安全的！ </li>
<li>枚举提供它们的命名空间。 </li>
<li>无论何时定义枚举，都会创建一个扩展java.lang.enum的类。因此，enum不能扩展另一个类或enum。编译器还为枚举中定义的每个常量创建类的实例。java.lang.Enum有以下方法 </li>
<li>枚举中定义的所有常量都是公共静态final。因为它们是静态的，所以可以通过EnumName.instanceName访问它们。 </li>
<li>不实例化枚举，而是依赖定义的常量。 </li>
<li>枚举可以在switch case语句中使用，就像int一样。</li>
</ol>
<h1 id="6-集合框架"><a href="#6-集合框架" class="headerlink" title="6. 集合框架"></a>6. 集合框架</h1><ul>
<li><p>尽管我们可以使用数组作为容器来存储一组相同类型的元素（原语或对象）。但是，<strong>数组不支持所谓的动态分配</strong>—它有一个固定长度，一旦分配就不能更改。 </p>
</li>
<li><p>此外，阵列是一种简单的线性结构。许多应用程序可能需要更复杂的数据结构，如<strong>链表、堆栈、哈希表、集合或树</strong>。 </p>
</li>
<li><p>在Java中，动态分配的数据结构（如ArrayList、LinkedList、Vector、Stack、HashSet、HashMap、Hashtable）在一个称为<strong>Collection Framework</strong>的统一体系结构中得到支持。 </p>
</li>
<li><p>集合只是一个<strong>容器对象</strong>，它包含一个对象集合。 </p>
</li>
<li><p>集合框架提供了一个统一的接口来存储、检索和操作集合的元素，而不考虑底层的实际实现。</p>
<p>Java集合框架包（Java.util）包含：</p>
</li>
</ul>
<ol>
<li><p>一套接口</p>
</li>
<li><p>实现类，以及</p>
</li>
<li><p>算法（如排序和搜索）。</p>
<p>类似于C++标准模板库（STL）。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;<span class="keyword">import</span> java.util.ArrayList;<span class="keyword">import</span> java.util.Iterator;<span class="keyword">import</span> java.util.Locale;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        List&lt;String&gt; coffeeLst=<span class="keyword">new</span> ArrayList&lt;&gt;();        coffeeLst.add(<span class="string">&quot;espresso&quot;</span>);        coffeeLst.add(<span class="string">&quot;latte&quot;</span>);        coffeeLst.add(<span class="string">&quot;cappuccino&quot;</span>);        System.out.println(coffeeLst);        Iterator&lt;String&gt; iter = coffeeLst.iterator();        <span class="keyword">while</span>(iter.hasNext())&#123;            String str=iter.next();            System.out.println(str);        &#125;        <span class="keyword">for</span>(String str:coffeeLst)System.out.println(str.toUpperCase(Locale.ROOT));        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;coffeeLst.size();++i)&#123;            System.out.println(coffeeLst.get(i).substring(<span class="number">0</span>,<span class="number">3</span>));        &#125;     <span class="comment">//   coffeeLst.add(new Integer(1234));       // Integer intObj=coffeeLst.get(0);    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>[espresso, latte, cappuccino]<br>espresso<br>latte<br>cappuccino<br>ESPRESSO<br>LATTE<br>CAPPUCCINO<br>esp<br>lat<br>cap</p>
<blockquote>
<p>第1-3行导入集合框架类和接口驻留在java.util包中。</p>
<p>在第7行中，我们构造了一个ArrayList<String>实例，并将其升级到List<String>接口。</p>
<p>这是可能的，因为ArrayList<String>是List<String>的子类型。</p>
<p>记住，一个好的程序是在规范上运行，而不是实际实现</p>
<p>List<String>coffeeLst=新ArrayList<String>（）</p>
<p>第8-10行将元素（实例化的实际类型字符串）添加到集合中</p>
<p>遍历集合元素的方法有三种：</p>
<p>通过关联迭代器<E>（第13-17行）</p>
<p>在JDK5（第19-20行）中引入的每个循环使用新的</p>
<p>在JDK 8中引入的流上使用聚合操作。（第22-24行）</p>
<p>第25-26行是编译的时间类型安全型。</p>
</blockquote>
<ul>
<li>集合框架中接口和常用实现类的层次结构 </li>
</ul>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210611095326678.png" alt="image-20210611095326678"></p>
<h2 id="6-1-泛型"><a href="#6-1-泛型" class="headerlink" title="6.1. 泛型"></a>6.1. 泛型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="keyword">private</span> <span class="keyword">int</span> size;   <span class="comment">//number of elements    private Object[] elements;   //can store all Java objects    public test1()&#123;        elements=new Object[10];//allocate initial capacity of 10        size=0;    &#125;    public void add(Object o)&#123;        if(size&gt;=elements.length)&#123;            Object[] newElements=new Object[size+10];            for(int i=0;i&lt;size;++i)newElements[i]=elements[i];        &#125;        elements[size]=o;        ++size;    &#125;    public Object get(int index)&#123;        if(index&gt;=size)throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+&quot;, Size: &quot;+size);        return elements[index];    &#125;    public int size()&#123;        return size;&#125;    public static void main(String[] args)&#123;        test1 strLst=new test1();        strLst.add(&quot;alpha&quot;);        strLst.add(&quot;belta&quot;);        System.out.println(strLst);        for (int i=0;i&lt; strLst.size();i++)&#123;            String str=(String) strLst.get(i);            System.out.println(str);        &#125;        strLst.add(new Integer(1234));        String str=(String)strLst.get(2);//报错：java.lang.Integer cannot be cast to java.lang.String    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>test.test1@4b67cf4d<br>alpha<br>belta</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        ArrayList&lt;String&gt; fruitlst=<span class="keyword">new</span> ArrayList&lt;String&gt;();        fruitlst.add(<span class="string">&quot;apple&quot;</span>);        fruitlst.add(<span class="string">&quot;orange&quot;</span>);        System.out.println(fruitlst);        <span class="keyword">for</span>(String str:fruitlst)&#123;            System.out.println(str);        &#125;        <span class="comment">// fruitlst.add(99); 报错        List&lt;String&gt; animalLst=new ArrayList&lt;&gt;();        animalLst.add(&quot;tiger&quot;);        System.out.println(animalLst);        List&lt;Integer&gt; intLst=new ArrayList&lt;&gt;();        intLst.add(11);        int i1=intLst.get(0);        System.out.println(intLst);        //intLst.add(2.2); 报错        List&lt;Number&gt; numLst=new ArrayList&lt;&gt;();        numLst.add(33);        numLst.add(4.4);        System.out.println(numLst);    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>[apple, orange]<br>apple<br>orange<br>[tiger]<br>[11]<br>[33, 4.4]</p>
<blockquote>
<p>The <E> is called the formal “type” parameter for passing type information into the generic class.<br>During instantiation, the formal type parameters are replaced by the actual type parameters.<br><E> for an element of a collection;<br>&lt;K, V&gt; for key and value.<br><N> for number<br><T> for type<br>S,U,V, etc. for 2nd, 3rd, 4th type parameters<br>Generic Wildcard (?)<br>&lt;?&gt;: called unbounded wildcard which accepts all types.<br>Bounded Type<br><T extends ClassName><br>&lt;? extends T&gt;<br>&lt;? super T&gt;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span>&lt;<span class="title">E</span>&gt;</span>&#123;    <span class="keyword">private</span> E content;    <span class="function"><span class="keyword">public</span> <span class="title">test1</span><span class="params">(E content)</span></span>&#123;        <span class="keyword">this</span>.content=content;    &#125;    <span class="function"><span class="keyword">public</span>  E <span class="title">getContent</span><span class="params">()</span></span>&#123;        <span class="keyword">return</span> content;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(E content)</span></span>&#123;        <span class="keyword">this</span>.content=content;    &#125;    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;        <span class="keyword">return</span> <span class="string">&quot;GenericBox[content=&quot;</span>+content+<span class="string">&quot;(&quot;</span>+content.getClass()+<span class="string">&quot;)]&quot;</span>;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-1-1-例子"><a href="#6-1-1-例子" class="headerlink" title="6.1.1 例子"></a>6.1.1 例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoxPrinter</span>&lt;<span class="title">T</span>&gt;</span>&#123;    <span class="keyword">private</span> T val;    <span class="function"><span class="keyword">public</span> <span class="title">BoxPrinter</span><span class="params">(T arg)</span></span>&#123;        val=arg;    &#125;    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;        <span class="keyword">return</span> <span class="string">&quot;[&quot;</span>+val+<span class="string">&quot;]&quot;</span>;    &#125;&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;        BoxPrinter&lt;Integer&gt; value1=<span class="keyword">new</span> BoxPrinter&lt;Integer&gt;(<span class="keyword">new</span> Integer(<span class="number">10</span>));        System.out.println(value1);        BoxPrinter&lt;String&gt;value2=<span class="keyword">new</span> BoxPrinter&lt;String&gt;(<span class="string">&quot;Hello world&quot;</span>);        System.out.println(value2);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>[10]<br>[Hello world]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T1</span>,<span class="title">T2</span>&gt;</span>&#123;    T1 object1;    T2 object2;    Pair(T1 one,T2 two)&#123;        object1=one;        object2=two;    &#125;    <span class="function"><span class="keyword">public</span> T1 <span class="title">getFirst</span><span class="params">()</span></span>&#123;        <span class="keyword">return</span> object1;    &#125;    <span class="function"><span class="keyword">public</span> T2 <span class="title">getSecond</span><span class="params">()</span></span>&#123;        <span class="keyword">return</span> object2;    &#125;&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;        Pair&lt;Integer,String&gt;worldCup=<span class="keyword">new</span> Pair&lt;Integer,String&gt;(<span class="number">2018</span>,<span class="string">&quot;Russia&quot;</span>);        System.out.println(<span class="string">&quot;World cup &quot;</span>+worldCup.getFirst()+<span class="string">&quot; in &quot;</span>+worldCup.getSecond());    &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>World cup 2018 in Russia</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;      List&lt;Number&gt;numLst=<span class="keyword">new</span> ArrayList&lt;&gt;();      numLst.add(<span class="number">1.1f</span>);      System.out.println(numLst);        Collection&lt;Integer&gt;intColl=<span class="keyword">new</span> LinkedList&lt;&gt;();        intColl.add(<span class="number">2</span>);        intColl.add(<span class="number">3</span>);        System.out.println(intColl);<span class="comment">//[2,3]        numLst.addAll(intColl);        System.out.println(numLst);        Set&lt;Double&gt; numSet=new HashSet&lt;&gt;();        numSet.add(4.4);        numSet.add(5.5);        System.out.println(numSet);        numLst.addAll(numSet);        System.out.println(numLst);    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>[1.1]<br>[2, 3]<br>[1.1, 2, 3]<br>[5.5, 4.4]<br>[1.1, 2, 3, 5.5, 4.4]</p>
<h2 id="6-2-迭代器-Iterable-lt-E-gt"><a href="#6-2-迭代器-Iterable-lt-E-gt" class="headerlink" title="6.2 迭代器 Iterable&lt;E&gt;"></a>6.2 迭代器 Iterable&lt;E&gt;</h2><p>There are three ways to traverse through all the elements of a Collection:</p>
<ol>
<li> Via the associated Iterator<E> object retrieved from the super-type Iterable<E></li>
<li> Using the for-each loop (introduced in JDK 5)</li>
<li> Via the Stream API</li>
</ol>
<p>java.lang.Iterable<E> interface<br>one abstract method called iterator()<br>abstract Iterator<E> iterator();<br>abstract boolean hasNext()<br>abstract E next()<br>abstract void remove()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;<span class="keyword">import</span> java.util.ArrayList;<span class="keyword">import</span> java.util.Iterator;<span class="keyword">import</span> java.util.Locale;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        List&lt;String&gt; coffeeLst=<span class="keyword">new</span> ArrayList&lt;&gt;();        coffeeLst.add(<span class="string">&quot;espresso&quot;</span>);        coffeeLst.add(<span class="string">&quot;latte&quot;</span>);        coffeeLst.add(<span class="string">&quot;cappuccino&quot;</span>);        System.out.println(coffeeLst);        Iterator&lt;String&gt; iter = coffeeLst.iterator();        <span class="keyword">while</span>(iter.hasNext())&#123;            String str=iter.next();            System.out.println(str);        &#125;        <span class="keyword">for</span>(String str:coffeeLst)System.out.println(str.toUpperCase(Locale.ROOT));        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;coffeeLst.size();++i)&#123;            System.out.println(coffeeLst.get(i).substring(<span class="number">0</span>,<span class="number">3</span>));        &#125;     <span class="comment">//   coffeeLst.add(new Integer(1234));       // Integer intObj=coffeeLst.get(0);    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-2-1-for-each-vs-Iterator"><a href="#6-2-1-for-each-vs-Iterator" class="headerlink" title="6.2.1 for-each vs Iterator"></a>6.2.1 for-each vs Iterator</h3><ol>
<li>for-loop provides a convenience way to traverse through a collection of elements. </li>
<li>for-loop hides the Iterator</li>
<li>Iterator <strong>would remove or replace the elements.</strong></li>
<li>the loop variable receives a “cloned” copy of the object reference. </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;<span class="keyword">import</span> java.util.ArrayList;<span class="keyword">import</span> java.util.Iterator;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;        List&lt;StringBuilder&gt; lst=<span class="keyword">new</span> ArrayList&lt;&gt;();        lst.add(<span class="keyword">new</span> StringBuilder(<span class="string">&quot;alpha&quot;</span>));        lst.add(<span class="keyword">new</span> StringBuilder(<span class="string">&quot;Delta&quot;</span>));        lst.add(<span class="keyword">new</span> StringBuilder(<span class="string">&quot;charlie&quot;</span>));        System.out.println(lst);        <span class="keyword">for</span> (StringBuilder sb:lst)&#123;          sb.append(<span class="string">&quot;123&quot;</span>);        &#125;        System.out.println(lst);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>[alpha, Delta, charlie]<br>[alpha123, Delta123, charlie123]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;        List&lt;String&gt; lst=<span class="keyword">new</span> ArrayList&lt;&gt;();        lst.add(<span class="string">&quot;alpha&quot;</span>);        lst.add(<span class="string">&quot;Delta&quot;</span>);        lst.add(<span class="string">&quot;charlie&quot;</span>);        System.out.println(lst);        <span class="keyword">for</span> (String str:lst)&#123;          str+=<span class="string">&quot;change!&quot;</span>;        &#125;        System.out.println(lst);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>[alpha, Delta, charlie]<br>[alpha, Delta, charlie]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;<span class="keyword">import</span> java.util.Iterator;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;        ArrayList&lt;Integer&gt;nums=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)nums.add(i);        System.out.println(<span class="string">&quot;Original list &quot;</span>+nums);        Iterator&lt;Integer&gt;numsIter = nums.iterator();        <span class="keyword">while</span> (numsIter.hasNext())&#123;          numsIter.remove();        &#125;        System.out.println(<span class="string">&quot;List after removing all elements &quot;</span>+ nums);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-3-集合接口"><a href="#6-3-集合接口" class="headerlink" title="6. 3 集合接口"></a>6. 3 集合接口</h2><p>It defines the common behaviors expected of all classes</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;<span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;    <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E element)</span></span>;<span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object element)</span></span>;<span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object element)</span></span>;<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;<span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;<span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;<span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;<span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;<span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;<span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;<span class="keyword">abstract</span> Object[] <span class="function">to <span class="title">Array</span><span class="params">()</span></span>;<span class="keyword">abstract</span> &lt;T&gt; T[] toArray(T[] a);</span><br></pre></td></tr></table></figure>

<h3 id="6-3-1-Sub-interface-of-Collection-lt-E-gt"><a href="#6-3-1-Sub-interface-of-Collection-lt-E-gt" class="headerlink" title="6.3.1. Sub-interface of Collection&lt;E&gt;"></a>6.3.1. Sub-interface of Collection&lt;E&gt;</h3><ul>
<li>3 sub-interface<br><strong>List<E></strong>: models a resizable linear array, which allows numerical indexed access, with index starting from 0.<br><strong>Set<E></strong>: models a mathematical set, where no duplicate elements are allowed.<br><strong>Queue</strong><E>: models queues such as First-in-First-out (FIFO) queue and priority queue. </li>
<li>a Map contains a collection of key-value pairs.<br>The interface Map&lt;K,V&gt;, which takes two generic types K and V, as a collection of “key-value pairs”. No duplicate key is allowed. </li>
</ul>
<h4 id="6-3-1-1-List"><a href="#6-3-1-1-List" class="headerlink" title="6.3.1.1. List"></a>6.3.1.1. List</h4><ol>
<li>A List<E> models a <strong>resizable linear array</strong>, which supports numerical indexed access, with index starts from 0. </li>
<li>Elements in a list can be retrieved and inserted at a specific index position based on an int index. </li>
<li>It can <strong>contain duplicate elements.</strong></li>
</ol>
<p> <img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210611111651970.png" alt="image-20210611111651970"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;<span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;<span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;<span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E element)</span></span>;<span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>;<span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object obj)</span></span>;<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span>;<span class="function"><span class="keyword">abstract</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,E element)</span></span>;<span class="function"><span class="keyword">abstract</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;<span class="function"><span class="keyword">abstract</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;<span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object obj)</span></span>;<span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object obj)</span></span>;<span class="function"><span class="keyword">abstract</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex,<span class="keyword">int</span> toIndex)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//List algorithmstatic void swap(List&lt;?&gt; lst,int i,int j);static void shuffle(List&lt;?&gt; lst);static void shuffle(List&lt;?&gt; lst,Ramdon rand);static void reverse(List&lt;?&gt; lst);static void rotate(List&lt;?&gt; lst,int distance);static &lt;T&gt; void fill(List&lt;? super T&gt;,T ,obj);static &lt;T&gt; void copy(List&lt;?super T&gt;dest,List&lt;?extends T&gt; src);static&lt;T&gt; boolean replaceAll(List&lt;T&gt; lst,T oldVal,T newVal);List&lt;E&gt; subList(int fromIdx,int toIdx)</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;<span class="keyword">import</span> java.util.ArrayList;<span class="keyword">import</span> java.util.Iterator;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;        List&lt;Integer&gt; lst=<span class="keyword">new</span> ArrayList&lt;&gt;();        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)lst.add(i*<span class="number">10</span>);        System.out.println(lst);                lst.subList(<span class="number">3</span>,<span class="number">6</span>).clear();        System.out.println(lst);                System.out.println(lst.subList(<span class="number">2</span>,<span class="number">5</span>).indexOf(<span class="number">60</span>));        System.out.println(Collection.indexOfSubList(lst,lst2));        System.out.println(Collection.lasIndexOfSubList(lst,lst2));    &#125;&#125;</span><br></pre></td></tr></table></figure>



<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210611113314639.png" alt="image-20210611113314639"></p>
<h4 id="6-3-1-2-Set-lt-E-gt-Interfaces"><a href="#6-3-1-2-Set-lt-E-gt-Interfaces" class="headerlink" title="6.3.1.2 Set&lt;E&gt;Interfaces"></a>6.3.1.2 Set&lt;E&gt;Interfaces</h4><p>The Set<E> interface models a mathematical set, where <strong>no duplicate elements are allowed</strong> (e.g., playing cards). </p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210611123238321.png" alt="image-20210611123238321"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;  <span class="keyword">private</span> <span class="keyword">int</span> id;  <span class="keyword">private</span> String title;  <span class="function"><span class="keyword">public</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> id,String title)</span></span>&#123;    <span class="keyword">this</span>.id=id;    <span class="keyword">this</span>.title=title;  &#125;  <span class="meta">@Override</span>  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;    <span class="keyword">return</span> id+<span class="string">&quot;: &quot;</span>+title;  &#125;  <span class="meta">@Override</span>  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;    <span class="keyword">return</span> id;  &#125;  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;        test1 book1=<span class="keyword">new</span> test1(<span class="number">1</span>,<span class="string">&quot;Java for Dummies&quot;</span>);        test1 book1Dup=<span class="keyword">new</span> test1(<span class="number">1</span>,<span class="string">&quot;Java for the Dummies&quot;</span>);        test1 book2=<span class="keyword">new</span> test1(<span class="number">2</span>,<span class="string">&quot;Java for more Dummies&quot;</span>);        test1 book3=<span class="keyword">new</span> test1(<span class="number">3</span>,<span class="string">&quot;more Java for more Dummies&quot;</span>);        Set&lt;test1&gt; set=<span class="keyword">new</span> LinkedHashSet&lt;test1&gt;();        set.add(book1);        set.add(book1Dup);        set.add(book1);        set.add(book3);        set.add(<span class="keyword">null</span>);        set.add(<span class="keyword">null</span>);        set.add(book2);        System.out.println(set);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>[1: Java for Dummies, 1: Java for the Dummies, 3: more Java for more Dummies, null, 2: Java for more Dummies]</p>
<h4 id="6-3-1-3-SortedSet-lt-E-gt-and-NavigableSet-lt-E-gt-Interfaces"><a href="#6-3-1-3-SortedSet-lt-E-gt-and-NavigableSet-lt-E-gt-Interfaces" class="headerlink" title="6.3.1.3 SortedSet&lt;E&gt; and NavigableSet&lt;E&gt; Interfaces"></a>6.3.1.3 SortedSet&lt;E&gt; and NavigableSet&lt;E&gt; Interfaces</h4><p>The NavigableSet&lt;E&gt; is a sub-interface of SortedSet&lt;E&gt;</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210611125929988.png" alt="image-20210611125929988"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">test1</span>&gt;</span>&#123;  <span class="keyword">private</span> String name,address,phone;  <span class="function"><span class="keyword">public</span> <span class="title">test1</span><span class="params">(String name)</span></span>&#123;    <span class="keyword">this</span>.name=name;  &#125;  <span class="meta">@Override</span>  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;    <span class="keyword">return</span> name;  &#125;  <span class="meta">@Override</span>  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(test1 other)</span></span>&#123;    <span class="keyword">return</span> <span class="keyword">this</span>.name.compareToIgnoreCase(other.name);  &#125;  <span class="meta">@Override</span>  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;    <span class="keyword">return</span> name.toLowerCase(Locale.ROOT).hashCode();  &#125;  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;        test1 addr1=<span class="keyword">new</span> test1(<span class="string">&quot;peter&quot;</span>);        test1 addr2=<span class="keyword">new</span> test1(<span class="string">&quot;paul&quot;</span>);        test1 addr3=<span class="keyword">new</span> test1(<span class="string">&quot;patrick&quot;</span>);        TreeSet&lt;test1&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();        set.add(addr1);        set.add(addr2);        set.add(addr3);        System.out.println(set);        System.out.println(set.floor(addr2));        System.out.println(set.lower(addr2));        System.out.println(set.tailSet(addr2));  &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>[patrick, paul, peter]<br>paul<br>patrick<br>[paul, peter]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;        String pangram =<span class="string">&quot;the quick brown fox jumps over the lazy dog&quot;</span>;        Set&lt;Character&gt; aToZee=<span class="keyword">new</span> TreeSet&lt;Character&gt;();        <span class="keyword">for</span>(<span class="keyword">char</span> gram:pangram.toCharArray())aToZee.add(gram);        System.out.println(<span class="string">&quot;The pangram is: &quot;</span>+pangram);        System.out.print(<span class="string">&quot;Sorted pangram character are: &quot;</span>+aToZee);  &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>The pangram is: the quick brown fox jumps over the lazy dog<br>Sorted pangram character are: [ , a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z]</p>
<h3 id="6-4-队列-Queue-lt-E-gt"><a href="#6-4-队列-Queue-lt-E-gt" class="headerlink" title="6.4 队列  Queue&lt;E&gt;"></a>6.4 队列  Queue&lt;E&gt;</h3><p> 队列是一个集合，其元素是按特定顺序添加和删除的，通常是以先进先出（FIFO）的方式。 </p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210611144612382.png" alt="image-20210611144612382"></p>
<h2 id="6-5-Map-lt-K-V-gt"><a href="#6-5-Map-lt-K-V-gt" class="headerlink" title="6.5 Map&lt;K,V&gt;"></a>6.5 Map&lt;K,V&gt;</h2><p>映射是键值对的集合。每个键只映射一个值。<strong>不允许重复键，但允许重复值。</strong></p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210611144751454.png" alt="image-20210611144751454"></p>
<p> Map&lt;K，V&gt;接口的实现包括： </p>
<ol>
<li><p>HashMap&lt;K，V&gt;：Map&lt;K，V&gt;接口的哈希表实现。最好的全方位实施。HashMap中的方法不同步。 </p>
</li>
<li><p>TreeMap&lt;K，V&gt;：<strong>SortedMap&lt;K，V&gt;接口的红黑树实现。</strong> </p>
</li>
<li><p>LinkedHashMap&lt;K，V&gt;：<strong>带有链接列表的哈希表，便于插入和删除。</strong> </p>
</li>
<li><p>哈希表：改进的遗留（JDK1.0）实现。<strong>Map&lt;K，V&gt;接口的一种同步哈希表实现，不允许使用旧方法使用空键或空值。</strong> </p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;<span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;<span class="function"><span class="keyword">abstract</span> V <span class="title">get</span><span class="params">(Object key)</span></span>;<span class="function"><span class="keyword">abstract</span> B <span class="title">put</span><span class="params">(K key,V value)</span></span>;<span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">contanKey</span><span class="params">(Object key)</span></span>;<span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">containValue</span><span class="params">(Object value)</span></span>;<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> V <span class="title">remove</span><span class="params">(Object key)</span></span>;<span class="keyword">abstract</span> Set&lt;K&gt;keySet();<span class="function"><span class="keyword">abstract</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>;<span class="keyword">abstract</span> Set&lt;Map,Entry&lt;K,V&gt;&gt; entrySet();</span><br></pre></td></tr></table></figure>

<h3 id="6-5-1-例子"><a href="#6-5-1-例子" class="headerlink" title="6.5.1 例子"></a>6.5.1 例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;       Map&lt;String,Double&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();       map.put(<span class="string">&quot;espresso&quot;</span>,<span class="number">1.1</span>);       map.put(<span class="string">&quot;latte&quot;</span>,<span class="number">2.2</span>);       map.put(<span class="string">&quot;cappuccino&quot;</span>,<span class="number">3.3</span>);       System.out.println(map);       <span class="keyword">for</span>(Map.Entry&lt;String,Double&gt;e:map.entrySet())&#123;         e.setValue(e.getValue()+<span class="number">10.0</span>);         System.out.println(e.getKey()+<span class="string">&quot;:&quot;</span>+e.getValue());       &#125;       System.out.println(map.keySet());       <span class="keyword">for</span>(String key:map.keySet())&#123;         System.out.println(key+<span class="string">&quot;=&quot;</span>+map.get(key));       &#125;       Iterator&lt;String&gt; iter=map.keySet().iterator();       <span class="keyword">while</span>(iter.hasNext())&#123;         String key=iter.next();         System.out.println(key+<span class="string">&quot;:&quot;</span>+map.get(key));       &#125;       System.out.println(map.values());  &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>{espresso=1.1, cappuccino=3.3, latte=2.2}<br>espresso:11.1<br>cappuccino:13.3<br>latte:12.2<br>[espresso, cappuccino, latte]<br>espresso=11.1<br>cappuccino=13.3<br>latte=12.2<br>espresso:11.1<br>cappuccino:13.3<br>latte:12.2<br>[11.1, 13.3, 12.2]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;       Scanner in=<span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(args[<span class="number">0</span>]));       Map&lt;String,Integer&gt;map=<span class="keyword">new</span> HashMap&lt;&gt;();       <span class="keyword">while</span>(in.hasNext())&#123;         String word=in.next();         <span class="keyword">int</span> freq=(map.get(word)==<span class="keyword">null</span>)?<span class="number">1</span>:map.get(word)+<span class="number">1</span>;         map.put(word,freq);       &#125;       System.out.println(map);  &#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;       NavigableMap&lt;Integer,String&gt;examScores=<span class="keyword">new</span> TreeMap&lt;Integer,String&gt;();       examScores.put(<span class="number">90</span>,<span class="string">&quot;Sophia&quot;</span>);       examScores.put(<span class="number">20</span>,<span class="string">&quot;Isabella&quot;</span>);       examScores.put(<span class="number">10</span>,<span class="string">&quot;Emma&quot;</span>);       examScores.put(<span class="number">50</span>,<span class="string">&quot;Olivea&quot;</span>);       System.out.println(<span class="string">&quot;The data in the map is:&quot;</span>+examScores); <span class="comment">//排序后的       System.out.println(&quot;The data descending order is: &quot;+examScores.descendingKeySet());       System.out.println(&quot;Drtails of those who passed the exam: &quot;+examScores.tailMap(40));//.tailMap():value高于x的       System.out.println(&quot;The lowset mark is: &quot;+examScores.firstEntry());  &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>The data in the map is:{10=Emma, 20=Isabella, 50=Olivea, 90=Sophia}<br>The data descending order is: [90, 50, 20, 10]<br>Drtails of those who passed the exam: {50=Olivea, 90=Sophia}<br>The lowset mark is: 10=Emma</p>
<h2 id="6-6-Compare"><a href="#6-6-Compare" class="headerlink" title="6.6 Compare"></a>6.6 Compare</h2><p>Comparable<T> Interface<br>Comparator<T> Class</p>
<h3 id="6-6-1-Searching-Sorting-and-Ordering"><a href="#6-6-1-Searching-Sorting-and-Ordering" class="headerlink" title="6.6.1 Searching,Sorting and Ordering"></a>6.6.1 Searching,Sorting and Ordering</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span>&lt;T&gt; <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;? extends T&gt; lst, T key,Comparator&lt;?<span class="keyword">super</span> T&gt;comp)</span></span>;<span class="function"><span class="keyword">static</span>&lt;T&gt; <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;?<span class="keyword">super</span> T&gt; lst, T key)</span></span>;<span class="function"><span class="keyword">static</span>&lt;T&gt; <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt;lst, Comparator&lt;? <span class="keyword">super</span> T&gt; comp)</span></span>;<span class="keyword">static</span>&lt;T extends Object &amp;Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function">T <span class="title">max</span><span class="params">(Collection&lt;? extends T&gt;coll)</span></span>;<span class="function"><span class="keyword">static</span>&lt;T&gt; T <span class="title">max</span><span class="params">(Collection&lt;? extends T&gt;coll,Comparator&lt;? <span class="keyword">super</span> T&gt; comp)</span></span>;<span class="function"><span class="keyword">static</span>&lt;T&gt; <span class="title">extends</span><span class="params">(Object &amp; Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; T max(Collection&lt;? extends T&gt; coll)</span></span>;<span class="keyword">static</span>&lt;T&gt;<span class="function">T <span class="title">min</span><span class="params">(Collection&lt;? extends T&gt;coll,Comparator&lt;? <span class="keyword">super</span> T&gt;comp)</span></span>;<span class="keyword">static</span>&lt;T extends Object &amp; Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function">T <span class="title">min</span><span class="params">(Collection&lt;? extends T&gt; coll)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在这两种情况下需要排序：</p>
<p>要对集合或数组进行排序（使用Collections.sort（）或Arrays.sort（）方法），需要一个排序规范。</p>
<p>一些集合，特别是SortedSet（TreeSet）和SortMap（TreeMap）是被排序的。</p>
<p><strong>有两种方法可以指定对象的顺序：</strong></p>
<p><strong>1.使对象实现java.lang.Comparable<T>接口，并重写compareTo（）方法来指定比较两个对象的顺序。</strong></p>
<p><strong>2.创建一个特殊的java.util.Comparator<T>对象，使用compare（）方法指定比较两个对象的顺序。</strong></p>
<h4 id="6-6-1-1-Comparable-lt-T-gt"><a href="#6-6-1-1-Comparable-lt-T-gt" class="headerlink" title="6.6.1.1 Comparable&lt;T&gt;"></a>6.6.1.1 Comparable&lt;T&gt;</h4><p>A java.lang.Comparable<T> interface 确定了为了排序两个对象是如何被比较的，它定义了一个抽象类型：</p>
<p>CompareTo(T o)</p>
<p>返回1如果 当前对象&gt;被传递的对象</p>
<p>返回0如果 当前对象==被传递的对象</p>
<p>返回-1如果当前对象小于被传递的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;       String[] strArray=&#123;<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;Hi&quot;</span>,<span class="string">&quot;HI&quot;</span>,<span class="string">&quot;Hello&quot;</span>&#125;;       Arrays.sort(strArray);       <span class="keyword">for</span>(String st:strArray)       System.out.println(st);       System.out.println(Arrays.binarySearch(strArray,<span class="string">&quot;Hello&quot;</span>));       System.out.println(Arrays.binarySearch(strArray,<span class="string">&quot;Hello&quot;</span>));       List&lt;Integer&gt; lst=<span class="keyword">new</span> ArrayList&lt;&gt;();       lst.add(<span class="number">22</span>);       lst.add(<span class="number">11</span>);       lst.add(<span class="number">44</span>);       lst.add(<span class="number">11</span>);       Collections.sort(lst);       System.out.println(lst);       System.out.println(Collections.binarySearch(lst,<span class="number">22</span>));       System.out.println(Collections.binarySearch(lst,<span class="number">35</span>));  &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>HI<br>Hello<br>Hello<br>Hi<br>hello<br>2<br>2<br>[11, 11, 22, 44]<br>2<br>-4</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparablePerson</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;    <span class="function"><span class="keyword">public</span> <span class="title">ComparablePerson</span><span class="params">(String name,<span class="keyword">int</span> ages)</span></span>&#123;        <span class="keyword">super</span>(name,age);    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person p)</span></span>&#123;        <span class="keyword">return</span> <span class="keyword">this</span>.getName().compareToIgnoreCase(p.getName());    &#125;&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparablePersonTest</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        List&lt;ComparablePerson&gt;plst=<span class="keyword">new</span> ArrayList&lt;&gt;();        plst.add(ComparablePerson(<span class="string">&quot;peter&quot;</span>,<span class="number">21</span>));        plst.add(ComparablePerson(<span class="string">&quot;Paul&quot;</span>,<span class="number">18</span>));        plst.add(ComparablePerson(<span class="string">&quot;John&quot;</span>,<span class="number">60</span>));        System.out.println(plst);                Collections.sort(plst);        System.out.printlm(plst);                System.out.println(Collections.binarySearch(plst,<span class="keyword">new</span> ComparablePerson(<span class="string">&quot;PAUL&quot;</span>,<span class="number">18</span>)));        System.out.println(Collections.binarySearch(plsr,<span class="keyword">new</span> ComparablePerson(<span class="string">&quot;PAUL&quot;</span>,<span class="number">16</span>)));        System.out.println(collections.binarySearch(plst, <span class="keyword">new</span> ComparablePerson(<span class="string">&quot;Kelly&quot;</span>,<span class="number">18</span>)));    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-6-1-2-Comparator-lt-T-gt-Interface"><a href="#6-6-1-2-Comparator-lt-T-gt-Interface" class="headerlink" title="6.6.1.2 Comparator&lt;T&gt;Interface"></a>6.6.1.2 Comparator&lt;T&gt;Interface</h4><p>compare(T o1,To2)</p>
<p>return 1,o1&gt;o2</p>
<p>return 0, o1==o2</p>
<p>return -1,o1&lt;o2</p>
<p> Comparator&lt;T&gt;接口声明了一个抽象方法（在jdk8中称为函数接口）： </p>
<p> Comparator&lt;T&gt;：下列任何一种方式： </p>
<p> 1.命名的<strong>内部类</strong> </p>
<p> 2.匿名<strong>内部类</strong> </p>
<p> 3.Lambda表达式（JDK 8） </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StringComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt;</span>&#123;        <span class="meta">@Override</span>        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1,String s2)</span></span>&#123;            <span class="keyword">return</span> s1.compareToIgnoreCase(s2);        &#125;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;    Comparator&lt;String&gt; strComp=<span class="keyword">new</span> StringComparator();    String[] array=&#123;<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;Hi&quot;</span>,<span class="string">&quot;HI&quot;</span>,<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;Hello&quot;</span>&#125;;    Arrays.sort(array,strComp);    System.out.println(Arrays.toString(array));    System.out.println(Arrays.binarySearch(array,<span class="string">&quot;Hello&quot;</span>,strComp));    System.out.println(Arrays.binarySearch(array,<span class="string">&quot;HELLO&quot;</span>,strComp));  &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>[Hello, hello, Hello, Hi, HI]<br>2<br>2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="comment">/*    public static class StringComparator implements Comparator&lt;String&gt;&#123;        @Override        public int compare(String s1,String s2)&#123;            return s1.compareToIgnoreCase(s2);        &#125;    &#125;     */</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;    Comparator&lt;Integer&gt; intComp=<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;        <span class="meta">@Override</span>        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer i1,Integer i2)</span></span>&#123;            <span class="keyword">return</span> i1*<span class="number">10</span>-i2*<span class="number">10</span>;        &#125;    &#125;;    List&lt;Integer&gt; lst=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();    lst.add(<span class="number">42</span>);    lst.add(<span class="number">21</span>);    lst.add(<span class="number">34</span>);    lst.add(<span class="number">13</span>);    Collections.sort(lst,intComp);    System.out.println(lst);    System.out.println(Collections.binarySearch(lst,<span class="number">22</span>,intComp));    System.out.println(Collections.binarySearch(lst,<span class="number">35</span>,intComp));  &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>[13, 21, 34, 42]<br>-3<br>-4</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;    Comparator&lt;String&gt; strComp=(s1,s2)-&gt;s1.compareToIgnoreCase(s2);    String[] array=&#123;<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;Hi&quot;</span>,<span class="string">&quot;HI&quot;</span>,<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;Hello&quot;</span>&#125;;    Arrays.sort(array,strComp);    System.out.println(Arrays.toString(array));    System.out.println(Arrays.binarySearch(array,<span class="string">&quot;Hello&quot;</span>,strComp));    System.out.println(Arrays.binarySearch(array,<span class="string">&quot;HELLO&quot;</span>,strComp));    Comparator&lt;Integer&gt; intComp =(i1,i2)-&gt;i1%<span class="number">10</span>-i2%<span class="number">10</span>;    List&lt;Integer&gt;lst=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();    lst.add(<span class="number">42</span>);    lst.add(<span class="number">21</span>);    lst.add(<span class="number">34</span>);    lst.add(<span class="number">13</span>);    Collections.sort(lst,intComp);    System.out.println(lst);    System.out.println(Collections.binarySearch(lst,<span class="number">22</span>,intComp));    System.out.println(Collections.binarySearch(lst,<span class="number">35</span>,intComp));    &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>[Hello, hello, Hello, Hi, HI]<br>2<br>2<br>[21, 42, 13, 34]<br>1<br>-5</p>
<p>Process finished with exit code 0</p>
<h1 id="7-exception"><a href="#7-exception" class="headerlink" title="7.exception"></a>7.exception</h1><p>class_10_exception.pptx</p>
<h2 id="7-1-异常处理-Exceoption-Handing"><a href="#7-1-异常处理-Exceoption-Handing" class="headerlink" title="7.1 异常处理 Exceoption Handing"></a>7.1 异常处理 Exceoption Handing</h2><ul>
<li> 异常是在程序执行期间发生的异常事件，它会中断程序的正常流程。 </li>
</ul>
<p> 您可能希望用户输入一个整数，但收到一个文本字符串； </p>
<p> 运行时会弹出意外的I/O错误。 </p>
<p> 网络连接 </p>
<p> 数据库连接 </p>
<p> 文件可能保持打开状态 </p>
<p> 数据库和文件记录可能处于不一致的状态。 </p>
<p> 如果这些异常处理不当，程序会突然终止，并可能导致严重后果。 </p>
<ul>
<li>Java将异常处理构建到语言中： </li>
</ul>
<p> 将通知您调用方法时可能出现的异常情况—异常在方法的签名中声明。 </p>
<p> 在编写主逻辑时，您必须处理异常，不能把它们作为事后的考虑——没有异常处理代码，您的程序就无法编译。 </p>
<p> 异常处理代码通过try-catch-finally构造与主逻辑分离。 </p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li>Exceptions 必须被声明</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Scanner</span><span class="params">(File sources)</span> <span class="keyword">throws</span> FileNotFoundException</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Exceptions必须被处理</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;<span class="keyword">import</span> java.io.File;<span class="keyword">import</span> java.io.FileNotFoundException;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScannerFromFileWithCatch</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        <span class="keyword">try</span>&#123;            Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">&quot;test.in&quot;</span>));        &#125;<span class="keyword">catch</span>(FileNotFoundException ex)&#123;            ex.printStackTrace();        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-方法调用堆栈-Method-Call-Stack"><a href="#7-2-方法调用堆栈-Method-Call-Stack" class="headerlink" title="7.2 方法调用堆栈 Method Call Stack"></a>7.2 方法调用堆栈 Method Call Stack</h2><pre><code> 一个典型的应用程序涉及许多级别的方法调用，这些调用由所谓的方法调用堆栈管理。堆栈是后进先出队列。 
</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;    System.out.println(<span class="string">&quot;Enter main()&quot;</span>);    methodA();    System.out.println(<span class="string">&quot;Exit main()&quot;</span>);    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;        System.out.println(<span class="string">&quot;Enter methodA()&quot;</span>);        methodB();        System.out.println(<span class="string">&quot;Exit methodA()&quot;</span>);    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;        System.out.println(<span class="string">&quot;Enter methodB()&quot;</span>);        methodC();        System.out.println(<span class="string">&quot;Exit methodB()&quot;</span>);    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodC</span><span class="params">()</span></span>&#123;        System.out.println(<span class="string">&quot;Enter methodC()&quot;</span>);        System.out.println(<span class="string">&quot;Exit methodC()&quot;</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>Enter main()<br>Enter methodA()<br>Enter methodB()<br>Enter methodC()<br>Exit methodC()<br>Exit methodB()<br>Exit methodA()<br>Exit main()</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210612174508584.png" alt="image-20210612174508584"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;        System.out.println(<span class="string">&quot;Enter main()&quot;</span>);        methodA();        System.out.println(<span class="string">&quot;Exit main()&quot;</span>);    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;        System.out.println(<span class="string">&quot;Enter methodA()&quot;</span>);        methodB();        System.out.println(<span class="string">&quot;Exit methodA()&quot;</span>);    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;        System.out.println(<span class="string">&quot;Enter methodB()&quot;</span>);        methodC();        System.out.println(<span class="string">&quot;Exit methodB()&quot;</span>);    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodC</span><span class="params">()</span></span>&#123;        System.out.println(<span class="string">&quot;Enter methodC()&quot;</span>);        System.out.println(<span class="number">1</span>/<span class="number">0</span>);        System.out.println(<span class="string">&quot;Exit methodC()&quot;</span>);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>Enter main()<br>Enter methodA()<br>Enter methodB()<br>Enter methodC()<br>Exception in thread “main” java.lang.ArithmeticException: / by zero<br>at MethodCallStackDemo.methodC(MethodCallStackDemo.java:XX)<br>at MethodCallStackDemo.methodB(MethodCallStackDemo.java:XX)<br>at MethodCallStackDemo.methodA(MethodCallStackDemo.java:XX)<br>at MethodCallStackDemo.main(MethodCallStackDemo.java:XX)</p>
<h2 id="7-3-异常调用堆栈-Exception-amp-Call-Stack"><a href="#7-3-异常调用堆栈-Exception-amp-Call-Stack" class="headerlink" title="7.3 异常调用堆栈 Exception &amp; Call Stack"></a>7.3 异常调用堆栈 Exception &amp; Call Stack</h2><ul>
<li><p>Exception对象包含异常的类型，以及发生异常时程序的状态。 </p>
</li>
<li><p>JVM负责查找异常处理程序来处理异常对象。它在调用堆栈中向后搜索，直到找到该异常对象的特定类的匹配异常处理程序。如果JVM在调用堆栈中的所有方法中都找不到匹配的异常处理程序，它将终止程序。 </p>
</li>
</ul>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210612175835906.png" alt="image-20210612175835906"></p>
<h2 id="7-4-Exception-Classes"><a href="#7-4-Exception-Classes" class="headerlink" title="7.4 Exception Classes"></a>7.4 Exception Classes</h2><p>Throwable, Error, Exception &amp; RuntimeException</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210612180124830.png" alt="image-20210612180124830"></p>
<p><strong>Throwable有两个子类</strong></p>
<p>java.lang.Exception异常</p>
<p>描述由程序引起的错误（例如FileNotFoundException、IOException）</p>
<p>这些错误可以由您的程序捕获和处理</p>
<p>java.lang.Error错误</p>
<p>描述很少发生的内部系统错误。如果发生这样的错误，您几乎无能为力，程序将被Java运行时终止。</p>
<h3 id="7-4-1-检查与未检查的异常"><a href="#7-4-1-检查与未检查的异常" class="headerlink" title="7.4.1 检查与未检查的异常"></a>7.4.1 检查与未检查的异常</h3><p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210612180349045.png" alt="image-20210612180349045"></p>
<p> Error和RuntimeException的子类称为unchecked异常。编译器不会检查这些异常，因此不需要捕获或声明在程序中抛出这些异常。 </p>
<p> 所有其他异常都称为检查异常。它们由编译器检查，必须被捕获或声明为抛出。 </p>
<h2 id="7-5-异常处理操作"><a href="#7-5-异常处理操作" class="headerlink" title="7.5 异常处理操作"></a>7.5 异常处理操作</h2><p>Five keywords are used in exception handling: try, catch, finally, throws and throw.</p>
<p>Java’s exception handling consists of three operations:</p>
<ol>
<li><p>Declaring exceptions;</p>
</li>
<li><p>Throwing an exception; </p>
</li>
<li><p>Catching an exception.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryCatchFinally</span></span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;	<span class="keyword">try</span>&#123;        System.out.println(<span class="string">&quot;Start of the main logic&quot;</span>);        System.out.println(<span class="string">&quot;Try opening a file&quot;</span>);        Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">&quot;test.in&quot;</span>));        System.out.println(<span class="string">&quot;File Found,processing the file...&quot;</span>);        System.out.println(<span class="string">&quot;End of the main logic&quot;</span>);    &#125;<span class="keyword">catch</span>(FileNotFoundException ex)&#123;        System.out.println(<span class="string">&quot;finally-block runs regardless of the state of exception&quot;</span>)    &#125;    System.out.println(<span class="string">&quot;After try-catch-finally, life goes on&quot;</span>);  &#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-6-常见异常类common-exception"><a href="#7-6-常见异常类common-exception" class="headerlink" title="7.6 常见异常类common exception"></a>7.6 常见异常类common exception</h2><p>ArrayIndexOutOfBoundsException</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] anArray=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];System.out.println(anArray[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure>

<p>NullPointerException</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] strs=<span class="keyword">new</span> String[<span class="number">3</span>];System.out.println(strs[<span class="number">0</span>].length());</span><br></pre></td></tr></table></figure>

<p>NumberFormatException</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer.parseInt(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>ClassCastException</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object o=<span class="keyword">new</span> Object();Integer i=(Integer)o;</span><br></pre></td></tr></table></figure>



<p>IllegalArgumentException<br>IllegalStateException<br>NoClassDefFoundError</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMagicExceptionTest</span></span>&#123;	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">magic</span><span class="params">(<span class="keyword">int</span> number)</span> <span class="keyword">throws</span> MyMagicException</span>&#123;	<span class="keyword">if</span>(number==<span class="number">8</span>)&#123;	<span class="keyword">throw</span> (<span class="keyword">new</span> MyMagicException(<span class="string">&quot;you hit the magic number&quot;</span>));	System.out.println(<span class="string">&quot;hello&quot;</span>);	&#125;  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;      <span class="keyword">try</span>&#123;          magic(<span class="number">9</span>);          magic(<span class="number">8</span>);      &#125;<span class="keyword">catch</span>(MyMagicException ex)&#123;          ex.printlnStackTrace();      &#125;        &#125;	&#125;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-I-O"><a href="#8-I-O" class="headerlink" title="8. I/O"></a>8. I/O</h1><p>class_12_IO.pptx</p>
<h2 id="8-1-基本输入输出"><a href="#8-1-基本输入输出" class="headerlink" title="8.1. 基本输入输出"></a>8.1. 基本输入输出</h2><p>编程简单的I/O操作很容易，只涉及几个类和方法。 </p>
<p>编程效率高，可移植的I/O是非常困难的，特别是如果你必须处理不同的字符集。 </p>
<p>JDK有两组I/O包： </p>
<p>标准I/O（在包java.io中）、用于基于流的I/O的JDK1.0，以及 </p>
<p>新的I/O（在java.nio包中）jdk1.4用于更高效的基于缓冲区的I/O。 </p>
<p>JDK1.5通过新类java.util.Scanner和Formatter引入格式化文本I/O，并使用类似C的printf（）和format（）方法使用格式说明符进行格式化输出。 </p>
<p>JDK1.7通过新包java.NIO.file及其辅助包中所谓的NIO.2（非阻塞I/O）增强了对文件I/O的支持。它还引入了一种新的try with resources语法来简化close（）方法的编码。 </p>
<ul>
<li>命令行参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArgs</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&gt;args.length;i++)&#123;            System.out.println(<span class="string">&quot;args[&quot;</span>+i<span class="string">&quot;] is &#x27;&quot;</span>+args[i]+<span class="string">&quot;&#x27;&quot;</span>);        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-2-Console-I-o"><a href="#8-2-Console-I-o" class="headerlink" title="8.2 Console I/o"></a>8.2 Console I/o</h2><p>The variable System.out enables you to write to standard output.<br>System.out is an object of type PrintStream.<br>The variable System.in enables you to read from standard input.<br>System.in is an object of type InputStream.<br>The variable System.err enables you to write to standard error.<br>System.err is an object of type PrintStream.</p>
<h2 id="8-3-File"><a href="#8-3-File" class="headerlink" title="8.3 File"></a>8.3 File</h2><p>Files and File I/O</p>
<p> <strong>java.io包允许您执行以下操作：</strong> </p>
<p> 创建文件对象 </p>
<p> 操纵文件对象 </p>
<p> 读取和写入文件流 </p>
<p> <strong>文件类</strong> </p>
<p> File类旨在提供一个抽象，以独立于机器的方式处理文件和路径名的大多数依赖于机器的复杂性。文件名是一个字符串。File类是文件名及其目录路径的包装类。 </p>
<p><strong>创建一个新的文件类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File myFile;myFile=<span class="keyword">new</span> File(<span class="string">&quot;myfile.txt&quot;</span>);myFile=<span class="keyword">new</span> File(<span class="string">&quot;MyDocs&quot;</span>,<span class="string">&quot;myfile.txt&quot;</span>);<span class="comment">//可以创建一个文件类然后用它去定义其他文件File myDir=new File(&quot;MyDocs&quot;);myFile=new File(myDir,&quot;myfile.txt&quot;);</span></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613152506667.png" alt="image-20210613152506667"></p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613152518088.png" alt="image-20210613152518088"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;        File dir=<span class="keyword">new</span> File(<span class="string">&quot;D:\\A大二下\\java\\test&quot;</span>);        listRecursive(dir);    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listRecursive</span><span class="params">(File dir)</span></span>&#123;        <span class="keyword">if</span>(dir.isDirectory())&#123;            File[] items=dir.listFiles();            <span class="keyword">for</span>(File item:items)&#123;                System.out.println(item.getAbsoluteFile());                <span class="keyword">if</span>(item.isDirectory())listRecursive(item);            &#125;        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>D:\A大二下\java\test\sub<br>D:\A大二下\java\test\sub\xx.txt<br>D:\A大二下\java\test\test.txt<br>D:\A大二下\java\test\text.txt</p>
<h3 id="8-3-1-File-I-O"><a href="#8-3-1-File-I-O" class="headerlink" title="8.3.1 File I/O"></a>8.3.1 File I/O</h3><p>File对象封装了文件或路径的属性，但不包含从文件中读/写数据的方法。</p>
<p>为了执行I/O，您需要使用适当的javai/O类创建对象。对象包含从文件中读取/写入数据的方法。</p>
<p>Scanner和PrintWriter类还可用于从文本文件读/写字符串和数值</p>
<p><strong>Writing Data Using PrintWriter</strong> </p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613153215634.png" alt="image-20210613153215634"></p>
<p><strong>Reading Data Using Scanner</strong> </p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613153308502.png" alt="image-20210613153308502"></p>
<p>流I/O操作包括三个步骤：</p>
<ol>
<li>Open  通过构造适当的I/O流实例，与物理设备（例如，文件、网络、控制台/键盘）相关联的输入/输出流。</li>
<li>Read  从打开的输入流到遇到“流结束”，或 写 到打开的输出流（可选地刷新缓冲输出）。</li>
<li>Close  输入/输出流。</li>
</ol>
<p><strong>PrintWriter/Scanner</strong></p>
<p>File对象封装了文件或路径的属性，但不包含从文件中读/写数据的方法。为了执行I/O，我们需要使用适当的java  I/O类创建对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;        Scanner input= <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">&quot;D:\\A大二下\\java\\test\\text.txt&quot;</span>));        System.out.println(input.nextLine());<span class="comment">//        PrintWriter output = new PrintWriter(&quot;D:\\A大二下\\java\\test\\text.txt&quot;);        output.println(&quot;Java 101&quot;);        output.close();    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613153655554.png" alt="image-20210613153655554"></p>
<ul>
<li>Output</li>
</ul>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613154403581.png" alt="image-20210613154403581"></p>
<p>buiabasb</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613154310899.png" alt="image-20210613154310899"></p>
<h2 id="8-4-基于字节的I-O和字节流"><a href="#8-4-基于字节的I-O和字节流" class="headerlink" title="8.4 基于字节的I/O和字节流"></a>8.4 基于字节的I/O和字节流</h2><p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613155043717.png" alt="image-20210613155043717"></p>
<p> FileInputStream/FileOutputStream将二进制输入/输出流与外部文件相关联。FileInputStream/fileoutputstream中的所有方法都是从其超类继承的。 </p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613155110614.png" alt="image-20210613155110614"></p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613155115572.png" alt="image-20210613155115572"></p>
<h3 id="8-4-1-文件输入流"><a href="#8-4-1-文件输入流" class="headerlink" title="8.4.1 文件输入流"></a>8.4.1 文件输入流</h3><p> 要构造FileInputStream，请使用以下构造函数： </p>
<p>public FileInputStream(String filename)<br>public FileInputStream(File file)</p>
<p> 如果尝试使用不存在的文件创建FileInputStream，则会发生java.io.FileNotFoundException。 </p>
<h3 id="8-4-2-文件输出流"><a href="#8-4-2-文件输出流" class="headerlink" title="8.4.2 文件输出流"></a>8.4.2 文件输出流</h3><p>要构造FileOutputStream，请使用以下构造函数：<br>public FileOutputStream(String filename)<br>public FileOutputStream(File file)<br>public FileOutputStream(String filename, boolean append)<br>public FileOutputStream(File file, boolean append)<br>如果文件不存在，将创建一个新文件。<br>如果文件已经存在，前两个构造函数将删除文件中的当前内容。<br>要<strong>保留当前内容并将新数据追加到文件中，请通过向append参数传递true来使用最后两个构造函数。</strong></p>
<h3 id="8-4-3-FilterInputStream-FilterOnputStream"><a href="#8-4-3-FilterInputStream-FilterOnputStream" class="headerlink" title="8.4.3 FilterInputStream  FilterOnputStream"></a>8.4.3 FilterInputStream  FilterOnputStream</h3><p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613155524735.png" alt="image-20210613155524735"></p>
<p>过滤流是<strong>出于某种目的过滤字节的流。</strong></p>
<p>基本字节输入流提供了一种只能用于读取字节的读取方法。<strong>如果要读取整数、双精度数或字符串，则需要一个过滤器类来包装字节输入流。</strong></p>
<p>使用过滤器类可以读取整数、双精度数和字符串，而不是字节和字符。</p>
<p><strong>FilterInputStream和FilterOutputStream是用于过滤数据的基类。当您需要处理原始数字类型时，请使用DataInputStream和DataOutputStream来过滤字节。</strong></p>
<h3 id="8-4-4-DataInputStream-DataOutputStream"><a href="#8-4-4-DataInputStream-DataOutputStream" class="headerlink" title="8.4.4 DataInputStream/DataOutputStream"></a>8.4.4 DataInputStream/DataOutputStream</h3><p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613160401542.png" alt="image-20210613160401542"></p>
<h3 id="8-4-5-Buffered-I-O-Byte-Streams"><a href="#8-4-5-Buffered-I-O-Byte-Streams" class="headerlink" title="8.4.5 Buffered I/O Byte-Streams"></a>8.4.5 Buffered I/O Byte-Streams</h3><p>为了缓冲、过滤或数据格式转换（在原始字节和基元类型之间），I/O流通常与其他I/O流分层或链接。</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613160509726.png" alt="image-20210613160509726"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;       String inFileStr=<span class="string">&quot;test-in.jpg&quot;</span>;       String outFileStr=<span class="string">&quot;test-out.jpg&quot;</span>;       FileInputStream in=<span class="keyword">null</span>;       FileOutputStream out=<span class="keyword">null</span>;       <span class="keyword">long</span> startTime,elapsedTime;       File fileIn=<span class="keyword">new</span> File(inFileStr);       System.out.println(<span class="string">&quot;File size is &quot;</span>+fileIn.length()+<span class="string">&quot;bytes&quot;</span>);       <span class="keyword">try</span>&#123;           in=<span class="keyword">new</span> FileInputStream(inFileStr);           out=<span class="keyword">new</span> FileOutputStream(outFileStr);           startTime=System.nanoTime();           <span class="keyword">int</span> byteRead;           <span class="keyword">while</span>((byteRead=in.read())!=-<span class="number">1</span>)&#123;               out.write(byteRead);           &#125;           elapsedTime=System.nanoTime()-startTime;           System.out.println(<span class="string">&quot;Elapsed Time is &quot;</span>+(elapsedTime/<span class="number">100000.0</span>)+<span class="string">&quot; msec&quot;</span>);       &#125; <span class="keyword">catch</span> (IOException ex) &#123;           ex.printStackTrace();       &#125;<span class="keyword">finally</span> &#123;           <span class="keyword">try</span> &#123;               &#123;                   <span class="keyword">if</span> (in!=<span class="keyword">null</span>)in.close();                   <span class="keyword">if</span>(out!=<span class="keyword">null</span>)out.close();               &#125;           &#125;<span class="keyword">catch</span> (IOException ex)&#123;               ex.printStackTrace();;           &#125;       &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-4-6-ObjectInputStream-amp-ObjectOutputStream"><a href="#8-4-6-ObjectInputStream-amp-ObjectOutputStream" class="headerlink" title="8.4.6 ObjectInputStream &amp; ObjectOutputStream"></a>8.4.6 ObjectInputStream &amp; ObjectOutputStream</h3><p>DataInputStream/DataOutputStream enables you to perform I/O for primitive type values and strings.<br>ObjectInputStream/ObjectOutputStream enables you to perform I/O for objects in addition for primitive type values and strings.</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613163515755.png" alt="image-20210613163515755"></p>
<p> <strong>可序列化接口</strong> </p>
<p> 并非所有对象都可以写入输出流。可以写入对象流的对象称为可序列化的。 </p>
<p> 可序列化对象是java.io.serializable接口的实例。因此可序列化对象的类必须实现可序列化。 </p>
<p> 可序列化接口是一个标记接口。它没有方法，所以不需要在实现可序列化的类中添加其他代码。 </p>
<p> 通过实现这个接口，Java序列化机制可以自动化存储对象和数组的过程。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySerializedObject</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;    <span class="keyword">public</span> <span class="keyword">int</span> number;    <span class="function"><span class="keyword">public</span> <span class="title">MySerializedObJect</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;        <span class="keyword">this</span>.number=number;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>&#123;        <span class="keyword">return</span> number;    &#125; &#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613163959545.png" alt="image-20210613163959545"></p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613164003512.png" alt="image-20210613164003512"></p>
<h3 id="8-4-7-The-transient-Keyword"><a href="#8-4-7-The-transient-Keyword" class="headerlink" title="8.4.7 The transient Keyword"></a>8.4.7 The transient Keyword</h3><p>如果一个对象是可序列化的实例，但它包含不可序列化的实例数据字段，那么该对象可以序列化吗？</p>
<p>答案是否定的。</p>
<p>要使对象能够被序列化，可以使用transient关键字标记这些数据字段，以告诉JVM在将对象写入对象流时忽略这些字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consider the following <span class="class"><span class="keyword">class</span>: <span class="title">public</span> <span class="title">class</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;    <span class="keyword">private</span> <span class="keyword">int</span> v1;  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> v2;  <span class="keyword">private</span> <span class="keyword">transient</span> A v3 = <span class="keyword">new</span> A();  &#125;<span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; &#125; <span class="comment">// A is not serializable</span></span><br></pre></td></tr></table></figure>

<p>When an object of the Foo class is serialized, only variable v1 is serialized. Variable v2 is not serialized because it is a static variable, and variable v3 is not serialized because it is marked transient.<br>If v3 were not marked transient, a java.io.NotSerializableException would occur.</p>
<h1 id="9-GUI"><a href="#9-GUI" class="headerlink" title="9.GUI"></a>9.GUI</h1><p>class_13_GUI.pptx</p>
<h2 id="9-1-例子"><a href="#9-1-例子" class="headerlink" title="9.1. 例子"></a>9.1. 例子</h2><p> <img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613164319279.png" alt="image-20210613164319279"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javafx.application.Application;<span class="keyword">import</span> javafx.event.EventHandler;<span class="keyword">import</span> javafx.scene.Scene;<span class="keyword">import</span> javafx.scene.control.Button;<span class="keyword">import</span> javafx.scene.layout.StackPane;<span class="keyword">import</span> javafx.stage.Stage;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> <span class="keyword">extends</span> <span class="title">Application</span></span>&#123;    <span class="keyword">public</span> Button btnHello;<span class="comment">//Declare a “Button” control    @Override    public void start(Stage primaryStage)&#123;        btnHello =new Button();        btnHello.setText(&quot;Say Hello&quot;);        btnHello.setOnAction((evt-&gt;System.out.println(&quot;Hello World&quot;)));        //Construct a  scene graph of nodes        StackPane root=new StackPane();//The root of scene graph is a layout node        root.getChildren().add(btnHello);//The root node adds Button as a child        Scene scene=new Scene(root,300,100);//Construct a scene given the root of scene graph        primaryStage.setScene(scene);//The stage sets scene        primaryStage.setTitle(&quot;Hello&quot;);//Set Window&#x27;s title        primaryStage.show();//Set Visible (show it)    &#125;    public static void main(String []args)&#123;       launch(args);    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="9-2-程序与事件驱动编程"><a href="#9-2-程序与事件驱动编程" class="headerlink" title="9.2 程序与事件驱动编程"></a>9.2 程序与事件驱动编程</h2><ul>
<li>Procedural programming is executed in procedural order.<br>In event-driven programming, code is executed upon activation of events. </li>
<li>A Taste of Event-Driven Programming<br>HandleEvent demo</li>
<li>Handling GUI Events<br>Source object (e.g., button)<br>Listener object contains a method for processing the event. </li>
</ul>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613191003189.png" alt="image-20210613191003189"></p>
<h2 id="9-3-Trace-execution"><a href="#9-3-Trace-execution" class="headerlink" title="9.3 Trace execution"></a>9.3 Trace execution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleEvent</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Stage primaryStage)</span> </span>&#123;    …    OKHandlerClass handler1 = <span class="keyword">new</span> OKHandlerClass();    btOK.setOnAction(handler1);    CancelHandlerClass handler2 = <span class="keyword">new</span> CancelHandlerClass();    btCancel.setOnAction(handler2);    …        primaryStage.show(); <span class="comment">// Display the stage  &#125;&#125;  class OKHandlerClass implements EventHandler&lt;ActionEvent&gt; &#123;  @Override  public void handle(ActionEvent e) &#123;    System.out.println(&quot;OK button clicked&quot;);   &#125;&#125; </span></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613191157958.png" alt="image-20210613191157958"></p>
<h2 id="9-4-事件类"><a href="#9-4-事件类" class="headerlink" title="9.4 事件类"></a>9.4 事件类</h2><p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613191336936.png" alt="image-20210613191336936"></p>
<p> 事件对象包含与事件相关的所有属性。 </p>
<p> 可以使用EventObject类中的getSource（）实例方法标识事件的源对象。 </p>
<p> EventObject的子类处理特殊类型的事件，例如按钮操作、窗口事件、鼠标移动和按键。 </p>
<p> 下一张幻灯片中的表列出了外部用户操作、源对象和生成的事件类型。 </p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613191710562.png" alt="image-20210613191710562"></p>
<h2 id="9-4-delegation-model"><a href="#9-4-delegation-model" class="headerlink" title="9.4 delegation model"></a>9.4 delegation model</h2><p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613192221650.png" alt="image-20210613192221650"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Button btOK=<span class="keyword">new</span> Buttion(<span class="string">&quot;OK&quot;</span>);OKHandlerClass handler =<span class="keyword">new</span> OKHandlerClass();btOK.setOnAction(handler);</span><br></pre></td></tr></table></figure>

<h1 id="10-Event"><a href="#10-Event" class="headerlink" title="10 Event"></a>10 Event</h1><h2 id="10-1-Inner-class"><a href="#10-1-Inner-class" class="headerlink" title="10.1. Inner class"></a>10.1. Inner class</h2><p> 监听器类是专门为GUI组件（例如按钮）创建监听器对象而设计的。它不会被其他应用程序共享。 </p>
<p> 因此，将frame类中的listener类定义为内部类是合适的。 </p>
<p> 内部类：一个类是另一个类的成员。 </p>
<p> 优点：在某些应用程序中，可以使用内部类使程序变得简单。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;    <span class="comment">//Inner class    public class A&#123;        ...    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>内部类可以使程序简单明了。</p>
<p>内部类支持其包含的外部类的工作，并被编译成名为OuterClassName$InnerClassName.class的类。</p>
<p>例如，OuterClass中的内部类InnerClass被编译为OuterClass$InnerClass.class。</p>
<p>内部类可以声明为public、protected或private，并遵循应用于该类成员的相同可见性规则。</p>
<p>内部类可以声明为<strong>静态</strong>的。可以使用外部类名访问静态内部类。<strong>静态内部类不能访问外部类的非静态成员</strong></p>
<h2 id="10-2-匿名内部类"><a href="#10-2-匿名内部类" class="headerlink" title="10.2 匿名内部类"></a>10.2 匿名内部类</h2><p>匿名内部类必须始终扩展超类或实现接口，<strong>但不能有显式的extends或implements子句。</strong><br>匿名内部类被编译成名为OuterClassNamen.class的类。<br>例如，如果外部类测试有两个匿名内部类，则这两个类将编译为Test​1.class和Test2.class。</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613193154030.png" alt="image-20210613193154030"></p>
<h2 id="10-3-使用Lambda表达式简化事件处理"><a href="#10-3-使用Lambda表达式简化事件处理" class="headerlink" title="10.3 使用Lambda表达式简化事件处理"></a>10.3 使用Lambda表达式简化事件处理</h2><p>Lambda表达式是java8中的一个新特性。Lambda表达式可以看作是一个语法简洁的匿名方法。<br>例如，使用（b）中的lambda表达式，可以将（a）中的以下代码简化为三行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//abtEnlarge.setOnAction&#123;    new EventHandler&lt;ActionEvent&gt;()&#123;        @Override        public void handle(ActionEvent e)&#123;                    &#125;    &#125;&#125;);</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bbtEnlarge.setOnAction(e-&gt;&#123;    &#125;);</span></span><br></pre></td></tr></table></figure>

<h3 id="10-3-1-Lambda表达式的基本语法"><a href="#10-3-1-Lambda表达式的基本语法" class="headerlink" title="10.3.1  Lambda表达式的基本语法"></a>10.3.1  Lambda表达式的基本语法</h3><p>ambda表达式的基本语法是</p>
<p>$（type1\ param1，type2\ param2，…）-&gt;表达式$</p>
<p>或</p>
<p>$（type1\ param1，type2\ param2，…)-&gt;{语句；}$</p>
<ul>
<li><p>编译器可以显式声明或隐式推断参数的数据类型。</p>
</li>
<li><p>如果只有一个参数没有显式数据类型，则可以省略括号。</p>
</li>
</ul>
<p>lambda表达式中的语句都用于该方法。<br>如果它包含多个方法，编译器将无法编译lambda表达式。<br>因此，编译器要理解lambda表达式，接口必须正好包含一个抽象方法。这样的接口称为函数接口或单一抽象方法（<strong>s</strong>ingle <strong>a</strong>bstract <strong>m</strong>ethod: SAM）接口。</p>
<h2 id="10-4-The-MouseEvent-Class"><a href="#10-4-The-MouseEvent-Class" class="headerlink" title="10.4 The MouseEvent Class"></a>10.4 The MouseEvent Class</h2><p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613195107741.png" alt="image-20210613195107741"></p>
<h2 id="10-5-The-KeyEvent-Class"><a href="#10-5-The-KeyEvent-Class" class="headerlink" title="10.5 The KeyEvent Class"></a>10.5 The KeyEvent Class</h2><p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613195444394.png" alt="image-20210613195444394"></p>
<h2 id="10-6-The-KeyCode-Constants"><a href="#10-6-The-KeyCode-Constants" class="headerlink" title="10.6 The KeyCode Constants"></a>10.6 The KeyCode Constants</h2><p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613195603287.png" alt="image-20210613195603287"></p>
<h2 id="10-7-lambda-练习"><a href="#10-7-lambda-练习" class="headerlink" title="10.7 lambda 练习"></a>10.7 lambda 练习</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">LambdaFunction</span></span>&#123;  <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;&#125;<span class="class"><span class="keyword">class</span> <span class="title">FirstLambe</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        LambdaFunction lambdaFunction = ()-&gt;System.out.println(<span class="string">&quot;Hello world&quot;</span>);        lambdaFunction.call();    &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Output </li>
</ul>
<p>Hello world</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="class"><span class="keyword">interface</span> <span class="title">LambdaFunction</span></span>&#123;        <span class="function">String <span class="title">intKind</span><span class="params">(<span class="keyword">int</span> a)</span></span>;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        LambdaFunction lambdaFunction = (<span class="keyword">int</span> i)-&gt; &#123;          <span class="keyword">if</span>((i%<span class="number">2</span>)==<span class="number">0</span>)<span class="keyword">return</span> <span class="string">&quot;even&quot;</span>;          <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&quot;odd&quot;</span>;        &#125;;        System.out.println(lambdaFunction.intKind(<span class="number">10</span>));    &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>even</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;    <span class="class"><span class="keyword">interface</span> <span class="title">LambdaFunction</span></span>&#123;        <span class="function"><span class="keyword">int</span> <span class="title">apply</span><span class="params">(<span class="keyword">int</span> j)</span></span>;        <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(java.lang.Object arg0)</span></span>;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        LambdaFunction lambdaFunction = i -&gt;i*i;        System.out.println(lambdaFunction.apply(<span class="number">10</span>));    &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>100</p>
<h1 id="11-thread"><a href="#11-thread" class="headerlink" title="11. thread"></a>11. thread</h1><p>class_15_thread.pptx</p>
<ul>
<li></li>
</ul>
<p>Java支持单线程和多线程操作。单线程程序有一个入口点（main（）方法）和一个出口点。<br>多线程程序有一个初始入口点（main（）方法），后跟许多入口点和出口点，这些入口点和出口点与main（）同时运行。<br>线程，也称为轻量级进程，是编程操作的单一顺序流，有明确的开始和结束。在线程的生命周期中，只有一个执行点。</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613201806739.png" alt="image-20210613201806739"></p>
<ul>
<li></li>
</ul>
<p>​        多任务系统可以通过共享计算资源（如CPU、内存和I/O通道）来同时执行许多任务。 </p>
<p> 通常有两种多任务操作系统： </p>
<pre><code> 协作多任务系统：每个任务必须自动地将控制权让给其他任务。 先发制人的多任务系统：任务被赋予CPU的时间片，一旦分配完毕，任务将被迫将控制权让给其他任务。 
</code></pre>
<ul>
<li></li>
</ul>
<p>​     与重量级进程不同，线程是轻量级的，在单个进程内运行——它们共享相同的地址空间、分配的资源和该进程的环境。</p>
<p>​    线程必须在运行的进程中划分出自己的资源。例如，线程有自己的堆栈、寄存器和程序计数器。在线程中运行的代码只在该上下文中工作，因此，线程（操作的顺序流）也称为执行上下文。</p>
<p>​    多线程处理对于提供与用户更好的交互也是必要的。例如，在字处理器中，当一个线程正在打印或保存文件时，可以使用另一个线程继续键入。在GUI应用程序中，多线程是提供响应用户界面的关键。</p>
<p>​    典型的Java程序在单个进程中运行，对多个进程不感兴趣。但是，在进程中，它经常使用多个线程来同时运行多个任务。</p>
<h2 id="11-1-并发编程是困难的"><a href="#11-1-并发编程是困难的" class="headerlink" title="11.1 并发编程是困难的"></a>11.1 并发编程是困难的</h2><p>编写多线程程序可能很棘手。</p>
<ul>
<li><p>实验：<br>打开三本书的第一页，试着同时阅读这些书。<br>读第一本书的几个单词，然后读第二本书的几个单词，然后读第三本书的几个单词，然后循环读第一本书的下几个单词，依此类推。 </p>
</li>
<li><p>多线程的挑战<br>在书与书之间切换，简单地阅读，<br>记住你在每本书中的位置，<br>把你正在读的书移近一点，这样你就能看到它，把你没有读的书推到一边<br>努力理解书的内容！</p>
</li>
</ul>
<h2 id="11-2-线程状态和生命周期"><a href="#11-2-线程状态和生命周期" class="headerlink" title="11.2 线程状态和生命周期"></a>11.2 线程状态和生命周期</h2><p>在任何时候，线程都处于几种线程状态之一。</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613202450550.png" alt="image-20210613202450550"></p>
<p><strong>新的可运行状态</strong><br>新线程在新状态下开始其生命周期。它将保持此状态，直到程序启动线程，从而使其处于可运行状态。处于可运行状态的线程被认为正在执行其任务。<br><strong>等待状态</strong><br>有时，可运行线程在等待另一个线程执行任务时会转换为等待状态。<br><strong>定时等待状态</strong><br>可运行线程可以在指定的时间间隔内进入定时等待状态。当时间间隔到期或等待的事件发生时，它将转换回可运行状态。<br><strong>阻塞状态</strong><br>当可运行线程尝试执行无法立即完成的任务时，它将转换为阻塞状态，并且必须临时等待该任务完成。<br><strong>终止状态</strong><br>可运行线程在成功完成任务或以其他方式终止（可能是由于错误）时进入终止状态（有时称为死状态）。</p>
<p> <strong>操作系统级别</strong> </p>
<p>操作系统对Java虚拟机（JVM）隐藏这些状态，<strong>JVM只看到可运行状态。</strong><br><strong>就绪</strong>和<strong>运行状态</strong>之间的转换仅由操作系统处理。<br>在大多数操作系统中，<strong>每个线程都有少量的处理器时间</strong>，称为执行其任务的时间片   (timeslice)。</p>
<h2 id="11-3-Thread-Runnable"><a href="#11-3-Thread-Runnable" class="headerlink" title="11.3 Thread Runnable"></a>11.3 Thread Runnable</h2><p>Thread类具有run（）、start（）和sleep（）等方法，这些方法对多线程非常有用。<br>如果不重写run（）方法，则将调用Thread类中的默认run（）方法，而该方法不执行任何操作。<br>您可以通过对thread类的对象调用<strong>start（）方法来创建线程</strong></p>
<h3 id="11-3-1-Thread"><a href="#11-3-1-Thread" class="headerlink" title="11.3.1 Thread"></a>11.3.1 Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">run</span><span class="params">()</span></span>&#123;        <span class="keyword">try</span>&#123;            sleep(<span class="number">1000</span>);        &#125;<span class="keyword">catch</span> (InterruptedException ex)&#123;            ex.printStackTrace();        &#125;        System.out.println(<span class="string">&quot;In run(); thread name is:&quot;</span>+getName());    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        Thread myThread = <span class="keyword">new</span> test1();        myThread.start();        System.out.println(<span class="string">&quot;In main();thread name: &quot;</span>);        Thread.currentThread().getName();    &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>In main();thread name:<br>In run(); thread name is:Thread-0</p>
<h3 id="11-3-2-Runnable"><a href="#11-3-2-Runnable" class="headerlink" title="11.3.2 Runnable"></a>11.3.2 Runnable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;        System.out.println(<span class="string">&quot;In run(); thread namse is: &quot;</span>);        Thread.currentThread().getName();    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;        Thread myThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> test1()); <span class="comment">//一定要upcasting,才能调用start()函数        myThread.start();        System.out.println(&quot;In main(); thread name is: &quot;+Thread.currentThread().getName());    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Output</li>
</ul>
<p>In main(); thread name is: main<br>In run(); thread namse is: </p>
<h2 id="11-4-线程同步"><a href="#11-4-线程同步" class="headerlink" title="11.4 线程同步"></a>11.4 线程同步</h2><p>​    当多个线程共享一个对象并被其中一个或多个线程修改时，可能会出现不确定的结果（我们将在示例中看到），除非对共享对象的访问得到正确管理。<br>​    这个问题可以通过一次只给一个线程对访问共享对象的代码的独占访问来解决。在此期间，希望访问该对象的其他线程一直在等待。当具有独占访问权限的线程完成对对象的访问时，允许其中一个等待线程继续。<br>​    这个过程称为线程同步，协调多个并发线程对共享数据的访问。</p>
<h3 id="11-4-1-Race-Conditions"><a href="#11-4-1-Race-Conditions" class="headerlink" title="11.4.1 Race Conditions"></a>11.4.1 Race Conditions</h3><p>​    线程共享内存，可以同时修改数据。由于修改可以在没有安全措施的情况下同时进行，这可能会导致不直观的结果。</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613211741244.png" alt="image-20210613211741244">    在synchronized块中，将<strong>synchronized关键字</strong>用于引用变量，并在其后跟随一个代码块。</p>
<p>​    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;<span class="keyword">import</span> java.lang.Thread.UncaughtExceptionHandler;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreeThreads</span></span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        PrintMe th1=<span class="keyword">new</span> PrintMe(<span class="string">&quot;A&quot;</span>);        PrintMe th2=<span class="keyword">new</span> PrintMe(<span class="string">&quot;B&quot;</span>);        PrintMe th3=<span class="keyword">new</span> PrintMe(<span class="string">&quot;C&quot;</span>);        th1.setName(<span class="string">&quot;A&quot;</span>);        th2.setName(<span class="string">&quot;B&quot;</span>);        th3.setName(<span class="string">&quot;C&quot;</span>);        <span class="keyword">new</span> Thread(th1).start();        <span class="keyword">new</span> Thread(th2).start();        <span class="keyword">new</span> Thread(th3).start();        <span class="keyword">while</span>(<span class="keyword">true</span>);    &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">PrintMe</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;    <span class="keyword">private</span> String name;    PrintMe(String n)&#123;        <span class="keyword">this</span>.name=n;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;        <span class="keyword">this</span>.name = name;    &#125;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;            System.out.println(<span class="keyword">this</span>.name);        &#125;        <span class="keyword">try</span> &#123;            System.out.println(<span class="string">&quot;停顿了 &quot;</span> + <span class="number">2</span> + <span class="string">&quot;秒&quot;</span>);            Thread.sleep(<span class="number">2000</span>);        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-4-2-sychronized"><a href="#11-4-2-sychronized" class="headerlink" title="11.4.2 sychronized"></a>11.4.2 sychronized</h3><ul>
<li>必须持有监视器锁才能指定线程执行代码块，应该将代码放在synchronized语句中。</li>
<li>这样的代码据说是由监视器锁保护的。</li>
<li>使用<strong>synchronized关键字</strong>声明synchronized语句：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(object)&#123;     statements&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613212533977.png" alt="image-20210613212533977"></p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613212538070.png" alt="image-20210613212538070"></p>
<p>为了防止多线程对临界资源的访问有时会导致数据的不一致性，<strong>Java提供了“互斥”机制，可以为这些资源对象加上一把“互斥锁”，在任一时刻只能由一个线程访问，即使该线程出现阻塞，该对象的被锁定状态也不会解除，其他线程仍不能访问该对象，这就是多线程同步。</strong>线程同步是保证线程安全的重要手段，但是线程同步客观上会导致性能下降。</p>
<p>可以<strong>使用synchronized关键字通过两种方式实现线程同步</strong>：一种是synchronized方法，使用s<strong>ynchronized关键字修饰方法</strong>，对方法进行同步；<strong>另一种是synchronized语句，将synchronized关键字放在对象前面限制一段代码的执行。</strong></p>
<h4 id="11-4-2-1-多线程方法"><a href="#11-4-2-1-多线程方法" class="headerlink" title="11.4.2.1 多线程方法"></a>11.4.2.1 多线程方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> duoxiancheng;<span class="comment">//机票数据库public class TicketDB &#123;	//机票的数量	private int ticketCount=5;		//获得当前机票数量	public synchronized int getTicketCount()	&#123;		return ticketCount;	&#125;		//销售机票	public synchronized void sellTicket()	&#123;		try &#123;			//线程休眠，阻塞当前线程，模拟等待用户付款			Thread.sleep(1000);		&#125; catch (InterruptedException e) &#123;			e.printStackTrace();		&#125;		System.out.printf(&quot;第%d号票，已经售出\n&quot;,ticketCount);		ticketCount--;	&#125;&#125;//调用代码如下package duoxiancheng; public class HelloWorld &#123;	public static void main(String[] args) &#123;		TicketDB db=new TicketDB();				//创建线程t1		Thread t1=new Thread(()-&gt;&#123;			while(true)			&#123;				int currTicketCount=db.getTicketCount();				//查询是否有票				if(currTicketCount&gt;0)				&#123;					db.sellTicket();				&#125;				else				&#123;					//无票退出					break;				&#125;			&#125;		&#125;);		//开始线程t1		t1.start();				//创建线程t2		Thread t2=new Thread(()-&gt;&#123;			while(true)			&#123;				int currTicketCount=db.getTicketCount();				//查询是否有票				if(currTicketCount&gt;0)				&#123;					db.sellTicket();				&#125;				else				&#123;					//无票退出					break;				&#125;			&#125;		&#125;);		//开始线程t2		t2.start();	&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="11-4-2-2-多线程语句"><a href="#11-4-2-2-多线程语句" class="headerlink" title="11.4.2.2 多线程语句"></a>11.4.2.2 多线程语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> duoxiancheng;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;		TicketDB db=<span class="keyword">new</span> TicketDB();				<span class="comment">//创建线程t1		Thread t1=new Thread(()-&gt;&#123;			while(true)			&#123;				synchronized (db) &#123;					int currTicketCount=db.getTicketCount();					//查询是否有票					if(currTicketCount&gt;0)					&#123;						db.sellTicket();					&#125;					else					&#123;						//无票退出						break;					&#125;				&#125;			&#125;		&#125;);		//开始线程t1		t1.start();				//创建线程t2		Thread t2=new Thread(()-&gt;&#123;			while(true)			&#123;				synchronized (db) &#123;					int currTicketCount=db.getTicketCount();					//查询是否有票					if(currTicketCount&gt;0)					&#123;						db.sellTicket();					&#125;					else					&#123;						//无票退出						break;					&#125;				&#125;			&#125;		&#125;);		//开始线程t2		t2.start();	&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;	<span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>; 	<span class="meta">@Override</span>	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;		<span class="keyword">while</span>(<span class="keyword">this</span>.sale()) &#123;&#125;	&#125;	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;			<span class="keyword">if</span>(ticket&lt;<span class="number">0</span>) &#123;				System.out.println(Thread.currentThread().getName() + <span class="string">&quot;的票已经全部售完，此时的票数量为：&quot;</span>+ticket);				<span class="keyword">return</span> <span class="keyword">false</span>;			&#125;			<span class="keyword">try</span> &#123;				Thread.sleep(<span class="number">10</span>); <span class="comment">// 延迟0.01秒，使得ticket可以被其它线程充分改变(可能此时的ticket小于等于0了)			&#125;catch(InterruptedException e) &#123;				e.printStackTrace();			&#125;			System.out.println(Thread.currentThread().getName()  + &quot; 正在售票,还剩余票数为：&quot; + ticket--);			return true;		&#125;&#125;//public class ThreadDemo &#123;	public static void main(String[] args) &#123;		// 一份资源		Runnable mt1 = new MyThread();				// 共享同一份资源		new Thread(mt1,&quot;售票员A&quot;).start();		new Thread(mt1,&quot;售票员B&quot;).start();		new Thread(mt1,&quot;售票员C&quot;).start();	&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="11-5-死锁"><a href="#11-5-死锁" class="headerlink" title="11.5 死锁"></a>11.5 死锁</h2><p>所谓死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去，死锁的操作一般是在程序运行时候才有可能出现，死锁是在多线程开发中较为常见的一种问题，过多的同步就有可能出现死锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">firstCorssBridge</span></span>&#123;	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">tell</span><span class="params">(secondCorssBridge scb)</span> </span>&#123;		System.out.println(<span class="string">&quot;张三告诉王五：我先过，你后过,否则你别想过这桥！&quot;</span>);		scb.cross();	&#125;	<span class="comment">// 以下函数不会执行	public synchronized void cross() &#123;		System.out.println(&quot;张三快快乐乐地过桥了……&quot;);	&#125;&#125;class secondCorssBridge&#123;	public synchronized void tell(firstCorssBridge fcb) &#123;		System.out.println(&quot;王五告诉张三：我先过，你后过,否则你别想过这桥！&quot;);		fcb.cross();	&#125;	// 以下函数不会执行	public synchronized void cross() &#123;		System.out.println(&quot;王五快快乐乐地过桥了……&quot;);	&#125;&#125;public class DeadLock implements Runnable&#123;	private firstCorssBridge fcb = new firstCorssBridge();	private secondCorssBridge scb = new secondCorssBridge();		public DeadLock() &#123;		// 启动线程 并执行以下语句		new Thread(this).start(); // 会运行run函数		fcb.tell(scb); // 运行到里面时 fcb会等待scb	&#125;	@Override	public void run() &#123;		scb.tell(fcb); // 运行到里面时 scb会等待fcb	&#125;		public static void main(String[] args) &#123;		new DeadLock();	&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p>要允许Runnable执行其任务，必须执行它。<br>Executor对象执行Runnables。它通过创建和管理一组称为线程池的线程来实现这一点。<br>当执行器开始执行Runnable时，执行器调用Runnable对象的run方法，该方法在新线程中执行。<br>Executor接口声明了一个名为execute的方法，该方法接受Runnable作为参数。</p>
<p><img src="C:\Users\86153\AppData\Roaming\Typora\typora-user-images\image-20210613215556091.png" alt="image-20210613215556091"></p>
<h2 id="JAVAFX-Thread"><a href="#JAVAFX-Thread" class="headerlink" title="JAVAFX Thread"></a>JAVAFX Thread</h2><p>JavaFX在处理多线程编程时有一系列独特的挑战。原因是JavaFX主要设计为以或多或少的线性方式工作。所有用户界面事件都在JavaFX应用程序线程中处理。<br>concurrent包管理与UI交互的多线程代码，并确保此交互在正确的线程中发生。JavaFX在处理多线程编程时有一系列独特的挑战。原因是JavaFX主要设计为以或多或少的线性方式工作。所有用户界面事件都在JavaFX应用程序线程中处理。<br>concurrent包管理与UI交互的多线程代码，并确保此交互在正确的线程中发生。</p>
<p>Worker接口提供后台Worker使用的API，后台Worker与UI通信。<br>因此，Worker是在后台线程中工作的对象。<br>Worker对象的状态可以从JavaFX应用程序的线程中观察和使用。<br>Task类是java.util.concurrent的完全可观察的实现。<br>FutureTask类，它允许开发人员在JavaFX应用程序中实现异步任务。</p>
<p>服务类执行这些任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;<span class="comment">/* */</span><span class="keyword">import</span> javafx.concurrent.Task;<span class="keyword">import</span>  javafx.event.ActionEvent;<span class="keyword">import</span> javafx.application.Application;<span class="keyword">import</span> javafx.event.EventHandler;<span class="keyword">import</span> javafx.geometry.Insets;<span class="keyword">import</span> javafx.geometry.Pos;<span class="keyword">import</span> javafx.scene.Parent;<span class="keyword">import</span> javafx.scene.Scene;<span class="keyword">import</span> javafx.scene.control.*;<span class="keyword">import</span> javafx.scene.layout.HBox;<span class="keyword">import</span> javafx.scene.layout.Priority;<span class="keyword">import</span> javafx.scene.layout.StackPane;<span class="keyword">import</span> javafx.scene.layout.VBox;<span class="keyword">import</span> javafx.stage.Stage;<span class="keyword">import</span> java.io.InputStream;<span class="keyword">import</span> java.lang.Thread;<span class="keyword">import</span> java.lang.Runnable;<span class="keyword">import</span> java.net.HttpURLConnection;<span class="keyword">import</span> java.net.URL;<span class="keyword">import</span> javafx.concurrent.Worker;<span class="class"><span class="keyword">class</span> <span class="title">test1</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;    <span class="keyword">private</span> HBox bottomControls;    <span class="keyword">private</span> ProgressBar pb;    <span class="keyword">private</span> Label messageLabel;    <span class="keyword">private</span> TextField tfURL;    <span class="keyword">private</span> TextArea contents;    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Stage primaryStage)</span><span class="keyword">throws</span> Exception</span>&#123;        Parent p=createMaininView();        Scene scnene=<span class="keyword">new</span> Scene(p);        primaryStage.setTitle(<span class="string">&quot;ProgressBarApp&quot;</span>);        primaryStage.setWidth(<span class="number">667</span>);        primaryStage.setHeight(<span class="number">376</span>);        primaryStage.setScene(scnene);        primaryStage.show();    &#125;    <span class="function"><span class="keyword">private</span> Parent <span class="title">createMaininView</span><span class="params">()</span></span>&#123;        VBox vbox=<span class="keyword">new</span> VBox();        vbox.setPadding(<span class="keyword">new</span> Insets(<span class="number">10</span>));        vbox.setSpacing(<span class="number">10</span>);        HBox topControls=<span class="keyword">new</span> HBox();        topControls.setAlignment(Pos.CENTER_LEFT);        topControls.setSpacing(<span class="number">4</span>);        Label label=<span class="keyword">new</span> Label(<span class="string">&quot;URL&quot;</span>);        tfURL=<span class="keyword">new</span> TextField();        HBox.setHgrow(tfURL, Priority.ALWAYS);        Button btnGetHTML=<span class="keyword">new</span> Button(<span class="string">&quot;Get HTML&quot;</span>);        btnGetHTML.setOnAction(<span class="keyword">this</span>::getHTML);        topControls.getChildren().addAll(label,tfURL,btnGetHTML);        contents=<span class="keyword">new</span> TextArea();        VBox.setVgrow(contents,Priority.ALWAYS);        bottomControls=<span class="keyword">new</span> HBox();        bottomControls.setSpacing(<span class="number">4</span>);        HBox.setMargin(bottomControls,<span class="keyword">new</span> Insets(<span class="number">4</span>));        pb=<span class="keyword">new</span> ProgressBar();        messageLabel=<span class="keyword">new</span> Label(<span class="string">&quot;&quot;</span>);        bottomControls.getChildren().addAll(pb,messageLabel);        vbox.getChildren().addAll(topControls,contents,bottomControls);        <span class="keyword">return</span> vbox;    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getHTML</span><span class="params">(ActionEvent evt)</span></span>&#123;        String url=tfURL.getText();        Task&lt;String&gt;task=<span class="keyword">new</span> Task&lt;String&gt;() &#123;            <span class="meta">@Override</span>            <span class="function"><span class="keyword">protected</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;                updateMessage(<span class="string">&quot;Getting HTML from&quot;</span>+url);                updateProgress(<span class="number">0.5d</span>,<span class="number">1.0d</span>);                HttpURLConnection c=<span class="keyword">null</span>;                InputStream is=<span class="keyword">null</span>;                String retval=<span class="string">&quot;&quot;</span>;                <span class="keyword">try</span> &#123;                    c=(HttpURLConnection) <span class="keyword">new</span> URL(url).openConnection();                    updateProgress(<span class="number">0.6d</span>,<span class="number">1.0d</span>);                    is=c.getInputStream();                    <span class="keyword">int</span> ch;                    <span class="keyword">while</span>((ch=is.read())!=-<span class="number">1</span>)&#123;                        retval+=(<span class="keyword">char</span>)ch;                    &#125;                &#125;<span class="keyword">finally</span> &#123;                    <span class="keyword">if</span>(is!=<span class="keyword">null</span>)&#123;                        is.close();                    &#125;                    <span class="keyword">if</span>(c!=<span class="keyword">null</span>)&#123;                        c.disconnect();                    &#125;                &#125;                updateMessage(<span class="string">&quot;HTML retrived&quot;</span>);                updateProgress(<span class="number">1.0d</span>,<span class="number">1.0d</span>);                <span class="keyword">return</span> retval;            &#125;            <span class="meta">@Override</span>            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">succeeded</span><span class="params">()</span></span>&#123;                contents.setText(getValue());            &#125;            <span class="meta">@Override</span>            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">()</span></span>&#123;                Alert alert=<span class="keyword">new</span> Alert(Alert.AlertType.getException.getMessage());                alert.showAndWait();            &#125;        &#125;;        bottomControls.visibleProperty().bind(task.runningProperty());        pb.paddingProperty().bind(task.progressProperty());        messageLabel.textProperty().bind(task.messageProperty());        <span class="keyword">new</span> Thread(task).start();    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;                launch(args);    &#125;&#125;</span><br></pre></td></tr></table></figure>



<h1 id="复习课"><a href="#复习课" class="headerlink" title="复习课"></a>复习课</h1><p>数组 （送）</p>
<p>控制流 （送）</p>
<p>x</p>
<h2 id="1-类"><a href="#1-类" class="headerlink" title="1.类"></a>1.类</h2><p>继承： （树状结构）</p>
<p>多态：子类生成子类的对象，父类生成父类的对象</p>
<p>类型转换： down-casting（显式） ，up-casting （隐式）   （不会考但是有细节）</p>
<p>显式不安全</p>
<p>Overloading</p>
<p>Overriding 父类和子类</p>
<h1 id="2-集合-（必考）"><a href="#2-集合-（必考）" class="headerlink" title="2.集合 （必考）"></a>2.集合 （必考）</h1><p>Iterator</p>
<h2 id="2-1-list"><a href="#2-1-list" class="headerlink" title="2.1 list"></a>2.1 list</h2><h2 id="2-2-set"><a href="#2-2-set" class="headerlink" title="2.2 set"></a>2.2 set</h2><h2 id="2-3map"><a href="#2-3map" class="headerlink" title="2.3map"></a>2.3map</h2><p>reference class 的类型放入集合，要考虑去重</p>
<h1 id="3-比较和排序"><a href="#3-比较和排序" class="headerlink" title="3.比较和排序"></a>3.比较和排序</h1><ul>
<li>重写接口</li>
<li>写父类</li>
</ul>
<p>comparator</p>
<p>comparable</p>
<h1 id="4-异常"><a href="#4-异常" class="headerlink" title="4.异常"></a>4.异常</h1><p>check的异常</p>
<p>unchecked的异常（错误+runtimeexception）</p>
<h1 id="5-文件"><a href="#5-文件" class="headerlink" title="5.文件"></a>5.文件</h1><p>文件的每种结构都要掌握</p>
<h2 id="6-JAVAFX"><a href="#6-JAVAFX" class="headerlink" title="6. JAVAFX"></a>6. JAVAFX</h2><h1 id="7-线程和Runnable"><a href="#7-线程和Runnable" class="headerlink" title="7.线程和Runnable"></a>7.线程和Runnable</h1><p>加锁</p>
<p>是否会造成死锁</p>
<h1 id="Network和数据库不考"><a href="#Network和数据库不考" class="headerlink" title="Network和数据库不考"></a>Network和数据库不考</h1><p>1-10题送分，送分的跟去年一样</p>
<ol start="11">
<li>ture true false true  B</li>
<li>实例化一个抽象类 CZ</li>
</ol>
<ol start="14">
<li><p>C  看throw的类跟 catch 的类是否有继承关系</p>
</li>
<li><p>B</p>
</li>
<li><p>c</p>
</li>
<li><p>b</p>
</li>
<li><p>a</p>
</li>
<li><p>a</p>
</li>
<li><p>都有</p>
</li>
<li><p>B</p>
</li>
<li><p>c</p>
</li>
<li><p>自己回去看   C</p>
</li>
<li><p>​                                                                                                                                                                                                                                                        </p>
</li>
<li><p>b</p>
</li>
</ol>
<p>多选题： </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/02/Jva%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" data-id="ckqmfed8e0001ekes6zy4elwj" data-title="Jva知识点总结" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/07/02/Jva%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Jva知识点总结
        
      </div>
    </a>
  
  
    <a href="/2021/07/01/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/07/02/Jva%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-1/">Jva知识点总结</a>
          </li>
        
          <li>
            <a href="/2021/07/02/Jva%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/">Jva知识点总结</a>
          </li>
        
          <li>
            <a href="/2021/07/01/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>